{"meta":{"title":"Hexo","subtitle":null,"description":"start from zero","author":"Ruffianjiang","url":"https://lossingdawn.top"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-06-16T15:15:00.029Z","updated":"2018-06-16T15:15:00.029Z","comments":false,"path":"/404.html","permalink":"https://lossingdawn.top//404.html","excerpt":"","text":""},{"title":"关于","date":"2019-04-14T04:47:39.514Z","updated":"2019-04-14T04:47:39.514Z","comments":true,"path":"about/index.html","permalink":"https://lossingdawn.top/about/index.html","excerpt":"","text":"个人详细介绍 邮箱 jiangyj0516@outlook.com 博客园 http://www.cnblogs.com/lossingdawn/ github https://github.com/Ruffianjiang gitee https://gitee.com/ruffianjiang/ 联系方式 QQ: 759372350 wechat: jiangyjcslg"},{"title":"分类","date":"2018-05-30T15:48:37.000Z","updated":"2018-06-16T15:26:33.373Z","comments":false,"path":"categories/index.html","permalink":"https://lossingdawn.top/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2018-06-16T15:15:18.405Z","updated":"2018-06-04T11:30:58.847Z","comments":false,"path":"books/index.html","permalink":"https://lossingdawn.top/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-16T16:46:48.901Z","updated":"2018-06-04T11:30:58.848Z","comments":true,"path":"links/index.html","permalink":"https://lossingdawn.top/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-08-11T08:11:59.710Z","updated":"2018-06-04T11:30:58.849Z","comments":false,"path":"repository/index.html","permalink":"https://lossingdawn.top/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-06-16T15:14:12.409Z","updated":"2018-06-04T11:30:58.850Z","comments":false,"path":"tags/index.html","permalink":"https://lossingdawn.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Github访问不到，登陆不上","slug":"github访问不到，登陆不上","date":"2018-06-10T05:50:00.000Z","updated":"2018-06-13T15:31:22.668Z","comments":true,"path":"2018/06/10/github访问不到，登陆不上/","link":"","permalink":"https://lossingdawn.top/2018/06/10/github访问不到，登陆不上/","excerpt":"摘要: 为github添加host 在host文件添加如下两行 再次 ping github.com 解析后的ip就会强制指向host中的ip 注1： host文件修改需要权限，建议使用 nodepad++ ，保存后会自动要求管理员权限，再次保存即可 注2： 关于IP的选择，可以去 站长工具 去查 参考： 阅读全文","text":"摘要: 为github添加host 在host文件添加如下两行 再次 ping github.com 解析后的ip就会强制指向host中的ip 注1： host文件修改需要权限，建议使用 nodepad++ ，保存后会自动要求管理员权限，再次保存即可 注2： 关于IP的选择，可以去 站长工具 去查 参考： 阅读全文 为github添加host 1C:\\WINDOWS\\System32\\drivers\\etc 在host文件添加如下两行 12192.30.253.112 github.com 151.101.113.194 github.global.SSL.fastly.net 再次 ping github.com 解析后的ip就会强制指向host中的ip 注1： host文件修改需要权限，建议使用 nodepad++ ，保存后会自动要求管理员权限，再次保存即可 注2： 关于IP的选择，可以去 站长工具 去查 参考： https://blog.csdn.net/wl_521/article/details/80154063","categories":[],"tags":[]},{"title":"Jdk安装错误1316，jdk-10.0.1","slug":"jdk安装错误1316，jdk-10.0.1","date":"2018-05-24T16:50:00.000Z","updated":"2018-06-13T15:31:22.668Z","comments":true,"path":"2018/05/25/jdk安装错误1316，jdk-10.0.1/","link":"","permalink":"https://lossingdawn.top/2018/05/25/jdk安装错误1316，jdk-10.0.1/","excerpt":"摘要: 打开注册表regedit ，定个位到 计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\JavaSoft\\ 把jdk，jre下面的目录删掉。即10.0.1 ，问题解决 参考： https://blog.csdn.net/lesorb/article/details/4389626阅读全文","text":"摘要: 打开注册表regedit ，定个位到 计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\JavaSoft\\ 把jdk，jre下面的目录删掉。即10.0.1 ，问题解决 参考： https://blog.csdn.net/lesorb/article/details/4389626阅读全文 打开注册表regedit ，定个位到 计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\JavaSoft\\ 把jdk，jre下面的目录删掉。即10.0.1 ，问题解决 参考： https://blog.csdn.net/lesorb/article/details/4389626","categories":[],"tags":[]},{"title":"Windows安装mongodb","slug":"windows安装mongodb","date":"2018-05-23T15:44:00.000Z","updated":"2018-06-13T15:31:21.408Z","comments":true,"path":"2018/05/23/windows安装mongodb/","link":"","permalink":"https://lossingdawn.top/2018/05/23/windows安装mongodb/","excerpt":"摘要: 一、资源 mongo下载地址： https://www.mongodb.com/download-center#community romongo下载： https://robomongo.org/ 如下三个文件，（mongodb-compass可以不用下在，这是管理mongo用的图形化界面，习惯用阅读全文","text":"摘要: 一、资源 mongo下载地址： https://www.mongodb.com/download-center#community romongo下载： https://robomongo.org/ 如下三个文件，（mongodb-compass可以不用下在，这是管理mongo用的图形化界面，习惯用阅读全文 一、资源 mongo下载地址： https://www.mongodb.com/download-center/#community romongo下载： https://robomongo.org/ 如下三个文件，（mongodb-compass可以不用下在，这是管理mongo用的图形化界面，习惯用romongo查询，studio3t可以自己学习使用） 安装好以上软件，我本地的mongo安装到了d:tools\\mongo 目录下，新建两个目录用于存储数据和日志 d:\\tools\\data\\db 和 d:\\tools\\data\\log 二、初始化工作 在命令行使用命令： 12345 启动脚本D:\\tools\\mongo\\bin\\mongod --dbpath D:\\tools\\data\\db连接脚本D:\\tools\\mongo\\bin\\mongo.exe 出现 waiting for connetions on port 27017 ，则表示启动成功，ctrl+c可以关闭 使用连接脚本连接数据库（新开一个命令行） 启动数据库命令行出现如下连接者的信息，连接成功 使用mongodb compass连接 romongo连接 后面主要使用romongo进行数据的查询，其中三种视图的切换 三、mongo的配置 配置 MongoDB 服务 创建一个配置文件位于 D:\\tools\\mongo\\mongod.cfg 具体内容如下： 12345 systemLog: destination: file path: D:\\tools\\data\\log\\mongod.logstorage: dbPath: D:\\tools\\data\\db 安装 MongoDB服务 1D:\\tools\\mongo\\bin\\mongod.exe --config \"D:\\tools\\mongo\\mongod.cfg\" --install 命令行需要管理员权限，没使用管理员权限的出现如下log信息 安装完成log信息如下： 在服务里可以找到MongoBD的服务 启动MongoDB服务 1net start MongoDB 关闭MongoDB服务 1net stop MongoDB 移除 MongoDB 服务 1C:\\mongodb\\bin\\mongod.exe --remove 其他的信息自行摸索吧，现在可以愉快的使用mongo了 参考： http://www.runoob.com/mongodb/mongodb-window-install.html","categories":[],"tags":[]},{"title":"Eclipse中Cannot Nest Src Folder解决方法","slug":"Eclipse中Cannot nest src folder解决方法","date":"2018-04-25T01:04:00.000Z","updated":"2018-06-13T15:31:22.668Z","comments":true,"path":"2018/04/25/Eclipse中Cannot nest src folder解决方法/","link":"","permalink":"https://lossingdawn.top/2018/04/25/Eclipse中Cannot nest src folder解决方法/","excerpt":"摘要: 错误示例： 解决方法： 右击项目 -&gt; properties -&gt; java build path -&gt; source 一般是上图的红框的问题，这个已经改过的，报错的时候，是一个还未新建的文件夹目录/bin/main，解决方案如下图所示： 第一种就是把allow output folders xxx阅读全文","text":"摘要: 错误示例： 解决方法： 右击项目 -&gt; properties -&gt; java build path -&gt; source 一般是上图的红框的问题，这个已经改过的，报错的时候，是一个还未新建的文件夹目录/bin/main，解决方案如下图所示： 第一种就是把allow output folders xxx阅读全文 错误示例： 1: Java Model Status [Cannot nest output folder 'xxx/bin/main' inside output folder 'xxx/bin'] 解决方法： 右击项目 -&gt; properties -&gt; java build path -&gt; source 一般是上图的红框的问题，这个已经改过的，报错的时候，是一个还未新建的文件夹目录/bin/main，解决方案如下图所示： 第一种就是把allow output folders xxx 的勾选去掉 第二种不去勾选，把default output folder目录改到bin目录 另外一种参考方法： https://blog.csdn.net/sinat_30397435/article/details/78522566","categories":[],"tags":[]},{"title":"restTemplate重定向问题 &Cookie问题","slug":"restTemplate重定向问题 &cookie问题","date":"2018-04-20T07:44:00.000Z","updated":"2018-06-13T15:31:21.408Z","comments":true,"path":"2018/04/20/restTemplate重定向问题 &cookie问题/","link":"","permalink":"https://lossingdawn.top/2018/04/20/restTemplate重定向问题 &cookie问题/","excerpt":"摘要: 最近在做一个转发功能，zuul + ribbon + resttemplate 进行路由、负载、转发的功能 基本准备就绪，在微信自动登陆那遇到了一个坑，ribbon 系统用resttemplate 转发A系统的资源，在微信自动登陆的地方，A系统重定向到微信的地址，类似下面的代码 结果resttemp阅读全文","text":"摘要: 最近在做一个转发功能，zuul + ribbon + resttemplate 进行路由、负载、转发的功能 基本准备就绪，在微信自动登陆那遇到了一个坑，ribbon 系统用resttemplate 转发A系统的资源，在微信自动登陆的地方，A系统重定向到微信的地址，类似下面的代码 结果resttemp阅读全文 最近在做一个转发功能，zuul + ribbon + resttemplate 进行路由、负载、转发的功能 基本准备就绪，在微信自动登陆那遇到了一个坑，ribbon 系统用resttemplate 转发A系统的资源，在微信自动登陆的地方，A系统重定向到微信的地址，类似下面的代码 1redirect: https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx3290f3d5****&amp;redirect_uri=http://***.com/weixin/wxAuthRedirect?redirectUrl=http%3A%2F%2F192.168.10.116%3A8081%2Finternal%2Fpage%2Fuser%2Flogin_wx&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=state#wechat_redirect 结果resttemplate 自动重定向到本地的地址，如下所示： 1http://192.168.10.116:**/connect/oauth2/authorize** 仔细思考了下，大概就是resttemplate 的重定向问题，查了查资料，找到一个类HttpComponentsClientHttpRequestFactory，RestTemplate初始化提供了这个类的参数 12345678910/** * Create a new instance of the &#123;@link RestTemplate&#125; based on the given &#123;@link ClientHttpRequestFactory&#125;. * @param requestFactory HTTP request factory to use * @see org.springframework.http.client.SimpleClientHttpRequestFactory * @see org.springframework.http.client.HttpComponentsClientHttpRequestFactory */ public RestTemplate(ClientHttpRequestFactory requestFactory) &#123; this(); setRequestFactory(requestFactory); &#125; HttpComponentsClientHttpRequestFactory继承自ClientHttpRequestFactory，这个类的子类有HttpComponentsClientHttpRequestFactory和SimpleClientHttpRequestFactory 找到SimpleClientHttpRequestFactory，有如下方法： 第一种方式： 12345678910111213141516171819202122232425262728293031323334/** * Template method for preparing the given &#123;@link HttpURLConnection&#125;. * &lt;p&gt;The default implementation prepares the connection for input and output, and sets the HTTP method. * @param connection the connection to prepare * @param httpMethod the HTTP request method (&#123;@code GET&#125;, &#123;@code POST&#125;, etc.) * @throws IOException in case of I/O errors */ protected void prepareConnection(HttpURLConnection connection, String httpMethod) throws IOException &#123; if (this.connectTimeout &gt;= 0) &#123; connection.setConnectTimeout(this.connectTimeout); &#125; if (this.readTimeout &gt;= 0) &#123; connection.setReadTimeout(this.readTimeout); &#125; connection.setDoInput(true); if (\"GET\".equals(httpMethod)) &#123; connection.setInstanceFollowRedirects(true); &#125; else &#123; connection.setInstanceFollowRedirects(false); &#125; if (\"POST\".equals(httpMethod) || \"PUT\".equals(httpMethod) || \"PATCH\".equals(httpMethod) || \"DELETE\".equals(httpMethod)) &#123; connection.setDoOutput(true); &#125; else &#123; connection.setDoOutput(false); &#125; connection.setRequestMethod(httpMethod); &#125; 可以看到setInstanceFollowRedirects，get请求是可以重定向的，其他方法禁止了重定向，于是建个SimpleClientHttpRequestFactory的子类，禁用重定向。 于是乎 NoRedirectClientHttpRequestFactory.java 123456789101112131415 import java.io.IOException;import java.net.HttpURLConnection;import org.springframework.http.client.SimpleClientHttpRequestFactory;public class NoRedirectClientHttpRequestFactory extends SimpleClientHttpRequestFactory &#123; @Override protected void prepareConnection(HttpURLConnection connection, String httpMethod) throws IOException &#123; // TODO Auto-generated method stub super.prepareConnection(connection, httpMethod); // 禁止自动重定向 connection.setFollowRedirects(false); &#125;&#125; 12 NoRedirectClientHttpRequestFactory httpRequestFactory = new NoRedirectClientHttpRequestFactory();RestTemplate restTemplate = new RestTemplate(httpRequestFactory); 接着，似乎更换ClientHttpRequestFactory并不合心意，还是要使用HttpComponentsClientHttpRequestFactory来实现，HttpComponentsClientHttpRequestFactory是可以自定义HttpClient的，于是查到了HttpClient头上，HttpClient是可以设置Redirect的， 第二种方式： 12345 HttpClient httpClient = HttpClientBuilder.create() .setRedirectStrategy(new LaxRedirectStrategy()) .build();httpRequestFactory.setHttpClient(httpClient);RestTemplate restTemplate = new RestTemplate(httpRequestFactory); 默认提供了两个类，DefaultRedirectStrategy和LaxRedirectStrategy，LaxRedirectStrategy继承自DefaultRedirectStrategy DefaultRedirectStrategy.java 1234567/** * Redirectable methods. */ private static final String[] REDIRECT_METHODS = new String[] &#123; HttpGet.METHOD_NAME, HttpHead.METHOD_NAME &#125;; LaxRedirectStrategy.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 /* * ==================================================================== * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation. For more * information on the Apache Software Foundation, please see * &lt;http://www.apache.org/&gt;. * */package org.apache.http.impl.client;import org.apache.http.annotation.Contract;import org.apache.http.annotation.ThreadingBehavior;import org.apache.http.client.methods.HttpDelete;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpHead;import org.apache.http.client.methods.HttpPost;/** * Lax &#123;@link org.apache.http.client.RedirectStrategy&#125; implementation * that automatically redirects all HEAD, GET, POST, and DELETE requests. * This strategy relaxes restrictions on automatic redirection of * POST methods imposed by the HTTP specification. * * @since 4.2 */@Contract(threading = ThreadingBehavior.IMMUTABLE)public class LaxRedirectStrategy extends DefaultRedirectStrategy &#123; public static final LaxRedirectStrategy INSTANCE = new LaxRedirectStrategy(); /** * Redirectable methods. */ private static final String[] REDIRECT_METHODS = new String[] &#123; HttpGet.METHOD_NAME, HttpPost.METHOD_NAME, HttpHead.METHOD_NAME, HttpDelete.METHOD_NAME &#125;; @Override protected boolean isRedirectable(final String method) &#123; for (final String m: REDIRECT_METHODS) &#123; if (m.equalsIgnoreCase(method)) &#123; return true; &#125; &#125; return false; &#125;&#125; 这就很清晰了，copy一份LaxRedirectStrategy的代码，改写掉REDIRECT_METHODS中的定义方法，如下： 1234567891011121314151617181920212223242526272829303132 import org.apache.http.annotation.Contract;import org.apache.http.annotation.ThreadingBehavior;import org.apache.http.impl.client.DefaultRedirectStrategy;/** * * @ClassName: MyRedirectStrategy * @Description: TODO* @author thinklight* @date 2018年4月20日 下午2:47:29 * */@Contract(threading = ThreadingBehavior.IMMUTABLE)public class MyRedirectStrategy extends DefaultRedirectStrategy &#123; public static final MyRedirectStrategy INSTANCE = new MyRedirectStrategy(); /** * Redirectable methods. */ private static final String[] REDIRECT_METHODS = new String[] &#123;&#125;; @Override protected boolean isRedirectable(final String method) &#123; for (final String m: REDIRECT_METHODS) &#123; if (m.equalsIgnoreCase(method)) &#123; return true; &#125; &#125; return false; &#125;&#125; ribbon+微信各种重定向问题，解决了。 第三种方式： 自己蠢了，今天因为cookie的问题发现了简单的方式 1HttpClient httpClient = HttpClientBuilder.create().disableCookieManagement().disableRedirectHandling().build(); 完整代码如下： 12345678910111213141516171819202122 @Autowired RestTemplate restTemplate; @Bean @LoadBalanced RestTemplate restTemplate() &#123; HttpComponentsClientHttpRequestFactory httpRequestFactory = new HttpComponentsClientHttpRequestFactory();// NoRedirectClientHttpRequestFactory httpRequestFactory = new NoRedirectClientHttpRequestFactory();// 此类型不能使用httpClient httpRequestFactory.setConnectionRequestTimeout(2000); httpRequestFactory.setConnectTimeout(10000); httpRequestFactory.setReadTimeout(7200000); // HttpClient httpClient = HttpClientBuilder.create() // .setRedirectStrategy(new MyRedirectStrategy()) // .build(); HttpClient httpClient = HttpClientBuilder.create().disableCookieManagement().disableRedirectHandling().build(); httpRequestFactory.setHttpClient(httpClient); RestTemplate restTemplate = new RestTemplate(httpRequestFactory); logger.debug(\"指定字符编码为UTF-8,原编码为ISO-8859-1\"); restTemplate.getMessageConverters().set(1, new StringHttpMessageConverter(StandardCharsets.UTF_8)); logger.debug(\"RestTemple默认能转换为application/json，转换追加text/plain类型\"); restTemplate.getMessageConverters().add(new WxMappingJackson2HttpMessageConverter()); return restTemplate; &#125; 重定向参考：https://www.dozer.cc/2014/05/disable-resttemplate-redirect.html cookie参考：https://stackoverflow.com/questions/10175649/resttemplate-and-cookie https://stackoverflow.com/questions/22853321/resttemplate-client-with-cookies","categories":[],"tags":[]},{"title":"Java ServletContextListener 实现UDP监听","slug":"java ServletContextListener 实现UDP监听","date":"2018-03-20T07:24:00.000Z","updated":"2018-06-13T15:31:21.408Z","comments":true,"path":"2018/03/20/java ServletContextListener 实现UDP监听/","link":"","permalink":"https://lossingdawn.top/2018/03/20/java ServletContextListener 实现UDP监听/","excerpt":"摘要: 使用spring boot实现项目启动时的监听， UDPListener import java.io.IOException;import java.io.UnsupportedEncodingException;import java.net.DatagramPacket;import java阅读全文","text":"摘要: 使用spring boot实现项目启动时的监听， UDPListener import java.io.IOException;import java.io.UnsupportedEncodingException;import java.net.DatagramPacket;import java阅读全文 使用spring boot实现项目启动时的监听， UDPListener 1 import java.io.IOException; import java.io.UnsupportedEncodingException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; 1 import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; import javax.servlet.annotation.WebListener; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 @WebListenerpublic class UDPListener implements ServletContextListener &#123; public static final int MAX_UDP_DATA_SIZE = 4096; public static final int UDP_PORT = 26666; @Override public void contextInitialized(ServletContextEvent sce) &#123; System.out.println(\"========UDPListener Initialized=========\"); try &#123; // 启动一个线程，监听UDP数据报 new Thread(new UDPProcess(UDP_PORT)).start(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; class UDPProcess implements Runnable &#123; DatagramSocket socket = null; public UDPProcess(final int port) throws SocketException &#123; socket = new DatagramSocket(port); &#125; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(\"=======UDPProcess======\"); while (true) &#123; byte[] buffer = new byte[MAX_UDP_DATA_SIZE]; DatagramPacket packet = new DatagramPacket(buffer, buffer.length); try &#123; socket.receive(packet); new Thread(new Process(packet)).start(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; class Process implements Runnable &#123; public Process(DatagramPacket packet) throws UnsupportedEncodingException &#123; // TODO Auto-generated constructor stub byte[] buffer = packet.getData();// 接收到的UDP信息，然后解码 String srt1 = new String(buffer,\"GBK\").trim(); String srt2 = new String(buffer, \"UTF-8\").trim(); String srt3 = new String(buffer,\"ISO-8859-1\").trim(); System.out.println(\"=======Process srt1 GBK======\" + srt1); System.out.println(\"=======Process srt2 UTF-8======\" + srt2); System.out.println(\"=======Process srt3 ISO-8859-1======\" + srt3); &#125; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(\"====Process run=====\"); &#125; &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; System.out.println(\"========UDPListener Destroyed=========\"); &#125;&#125; DemoApplication 12345678 @SpringBootApplication@ServletComponentScan public class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 1@ServletComponentScan Servlet扫描，启动时把servlet、filter、listener自动扫描注入 UDP测试客户端（也可以用测试工具发送UDP包测试）： 1 import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; 123456789101112131415161718192021222324252627 public class UDPClientTest &#123; public static final String SERVER_HOSTNAME = \"localhost\"; // 服务器端口 public static final int SERVER_PORT = 26666; // 本地发送端口 public static final int LOCAL_PORT = 8888; public static void main(String[] args) &#123; try &#123; // 1，创建udp服务。通过DatagramSocket对象。 DatagramSocket socket = new DatagramSocket(LOCAL_PORT); // 2，确定数据，并封装成数据包。DatagramPacket(byte[] buf, int length, InetAddress // address, int port) byte[] buf = \"你好，世界\".getBytes(); DatagramPacket dp = new DatagramPacket(buf, buf.length, InetAddress.getByName(SERVER_HOSTNAME), SERVER_PORT); // 3，通过socket服务，将已有的数据包发送出去。通过send方法。 socket.send(dp); // 4，关闭资源。 socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1结果： 1","categories":[],"tags":[]},{"title":"Weex起步","slug":"weex起步","date":"2018-03-01T06:56:00.000Z","updated":"2018-06-13T15:31:21.408Z","comments":true,"path":"2018/03/01/weex起步/","link":"","permalink":"https://lossingdawn.top/2018/03/01/weex起步/","excerpt":"摘要: weex文档地址： http://weex project.io/cn/guide/index.html weex的文档过于简单，加上js语法 &amp; android &amp; ios本身也有很多的问题，导致新接触weex，几乎步步是坑 在此记录一下weex的一些探索 一、初始化 按照官方的步骤走， 接着就遇阅读全文","text":"摘要: weex文档地址： http://weex project.io/cn/guide/index.html weex的文档过于简单，加上js语法 &amp; android &amp; ios本身也有很多的问题，导致新接触weex，几乎步步是坑 在此记录一下weex的一些探索 一、初始化 按照官方的步骤走， 接着就遇阅读全文 weex文档地址： http://weex-project.io/cn/guide/index.html weex的文档过于简单，加上js语法 &amp; android &amp; ios本身也有很多的问题，导致新接触weex，几乎步步是坑 在此记录一下weex的一些探索 一、初始化 按照官方的步骤走， 1234567891011 #安装node...#安装weex-toolkitnpm install weex-toolkit -g#创建项目weex create awesome-app#开发cd awesome-appnpm installnpm start 接着就遇到了语法问题，具体如下所示 https://segmentfault.com/q/1010000013417243?_ea=3379756 待续。。。","categories":[],"tags":[]},{"title":"Mongo去重统计","slug":"mongo去重统计","date":"2017-11-10T02:50:00.000Z","updated":"2018-06-13T15:31:22.668Z","comments":true,"path":"2017/11/10/mongo去重统计/","link":"","permalink":"https://lossingdawn.top/2017/11/10/mongo去重统计/","excerpt":"摘要: 表名：parkUserCost id: patkId: userId: phone: costVal: 适合特定条件下，对某些字段进行去重筛选。（比如限定抢购） 第一种，使用first操作符。first 会把数组的第一个元素取出，作为一个对象。 第二种，使用$slice操作符。从数组的第几个开始阅读全文","text":"摘要: 表名：parkUserCost id: patkId: userId: phone: costVal: 适合特定条件下，对某些字段进行去重筛选。（比如限定抢购） 第一种，使用first操作符。first 会把数组的第一个元素取出，作为一个对象。 第二种，使用$slice操作符。从数组的第几个开始阅读全文 表名：parkUserCost id: patkId: userId: phone: costVal: 适合特定条件下，对某些字段进行去重筛选。（比如限定抢购） 第一种，使用(first操作符。)first 会把数组的第一个元素取出，作为一个对象。 1234567891011121314151617 // 第一种（可转java版本）db.getCollection('parkUserCost').aggregate([ &#123;\"$match\" : &#123; \"$and\" : [ // &#123;\"name\" : \"1640\"&#125; // 筛选条件 ] &#125; &#125;, &#123;\"$group\" : &#123; \"_id\" : \"$phone\", \"val\" : &#123;\"$first\" : \"$costVal\" &#125;, &#125;&#125;, &#123;\"$group\" : &#123; \"_id\" : &#123;&#125;, \"totalVal\" :&#123;\"$sum\" : \"$val\"&#125; &#125;&#125;]) 第二种，使用$slice操作符。从数组的第几个开始，截取几个，保存到数组 1234567891011121314151617181920 // 第二种db.getCollection('parkUserCost').aggregate([ &#123;\"$match\" : &#123; \"$and\" : [ // &#123;\"name\" : \"1640\"&#125; // 筛选条件 ] &#125; &#125;, &#123;\"$group\" : &#123; \"_id\" : \"$phone\", \"val\" : &#123;\"$push\" : \"$costVal\" &#125;, &#125;&#125;, &#123;\"$project\" : &#123; \"val\" :&#123;\"$sum\" :&#123;\"$slice\" : [\"$val\", 0, 1 ] &#125;&#125; &#125;&#125;, &#123;\"$group\" : &#123; \"_id\" : &#123;&#125;, \"totalVal\" :&#123;\"$sum\" : \"$val\"&#125; &#125;&#125;]) 第三种，使用$arrayElemAt，返回数组的第几个元素。序号的循环的，最后一个使用-1 1234567891011121314151617181920 // 第三种db.getCollection('parkUserCost').aggregate([ &#123;\"$match\" : &#123; \"$and\" : [ // &#123;\"name\" : \"1640\"&#125; // 筛选条件 ] &#125; &#125;, &#123;\"$group\" : &#123; \"_id\" : \"$phone\", \"val\" : &#123;\"$push\" : \"$costVal\" &#125;, &#125;&#125;, &#123;\"$project\" : &#123; \"val\" : &#123; \"$arrayElemAt\" :[ \"$val\" , 0] &#125; &#125;&#125;, &#123;\"$group\" : &#123; \"_id\" : &#123;&#125;, \"totalVal\" :&#123;\"$sum\" : \"$val\"&#125; &#125;&#125;]) 若要表中的全部字段，可使用$$ROOT获取 12345678910111213 db.getCollection('parkUserCost').aggregate([ &#123;\"$match\" : &#123; \"$and\" : [ // &#123;\"name\" : \"1640\"&#125; // 筛选条件 ] &#125; &#125;, &#123;\"$group\" : &#123; \"_id\" : \"$phone\", \"item\": &#123;\"$first\": \"$$ROOT\"&#125;, \"val\" : &#123;\"$first\" : \"$costVal\" &#125;, &#125;&#125;,]) http://www.runoob.com/mongodb/mongodb-tutorial.html","categories":[],"tags":[]},{"title":"Backbone之路由锚点的替换","slug":"backbone之路由锚点的替换","date":"2017-09-26T02:10:00.000Z","updated":"2018-06-13T15:31:21.408Z","comments":true,"path":"2017/09/26/backbone之路由锚点的替换/","link":"","permalink":"https://lossingdawn.top/2017/09/26/backbone之路由锚点的替换/","excerpt":"摘要: 1、需求 由于项目一开始做的时候不甚完善，所有的网页没有路由功能，导致一些搜索结果在页面跳转之后，没有被记录下来，在页面跳转之后回退，得到的是页面最原始的结果，没有指定的搜索条件。最近项目的在完善这些小的细节，所以在此记录一下。 2、操作 由于项目的所有传参都是使用 ‘?’ 来标识的，而Backbo阅读全文","text":"摘要: 1、需求 由于项目一开始做的时候不甚完善，所有的网页没有路由功能，导致一些搜索结果在页面跳转之后，没有被记录下来，在页面跳转之后回退，得到的是页面最原始的结果，没有指定的搜索条件。最近项目的在完善这些小的细节，所以在此记录一下。 2、操作 由于项目的所有传参都是使用 ‘?’ 来标识的，而Backbo阅读全文 1、需求 由于项目一开始做的时候不甚完善，所有的网页没有路由功能，导致一些搜索结果在页面跳转之后，没有被记录下来，在页面跳转之后回退，得到的是页面最原始的结果，没有指定的搜索条件。最近项目的在完善这些小的细节，所以在此记录一下。 2、操作 由于项目的所有传参都是使用 ‘?’ 来标识的，而Backbone的路由是使用锚点 ‘/#’ 来的，为了兼容以前的做法，不得不去修改Backbone的源码，还好路由部分的源码不多 2.1 修改Backbone的源码，版本1.3.3 1）修改标识 ‘/#’ -&gt; ‘?’ 把源代码中的字符串中的’/#‘修改为’?’，把单个的’/#‘修改为’?’ 123456789101112131415 例：var pathStripper = /#.*$/;修改为：var pathStripper = /\\?.*$/;例：this.location.replace(rootPath + '#' + this.getPath());修改为：this.location.replace(rootPath + '?' + this.getPath()); 注：字符串中的?需要\\来转义，字符不需要 2)修改锚点的路由设置 1234567891011121314151617181920212223 _updateHash: function(location, fragment, replace) &#123;if (replace) &#123;var href = location.href.replace(/(javascript:|\\?).*$/, '');location.replace(href + '?' + fragment);&#125; else &#123;// Some browsers require that `hash` contains a leading #.// location.hash = '?' + fragment;var href = location.href.replace(/(javascript:|\\?).*$/, '');// window.history.pushState(&#123;&#125;, 0, href + '?' + fragment);window.history.replaceState(&#123;&#125;, 0, href + '?' + fragment);&#125;&#125; 注： location.hash是原始的修改参数方法，会替换url中’/#'以及后的所有内容 window.history.pushState可选目标方法，会增加一次历史记录，刷新页面 window.history.replaceState可选目标方法，会替换掉当前的页面记录，不刷新页面（目前选用方案） 2.2 写一个Util 写一个工具类用于Router的快速使用，和统一修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125 /*** RouterUtil.js*/var RouterUtil = (function() &#123;// Backbone Router with a custom parameter extractorvar Router = Backbone.Router.extend(&#123;params : \"\",routes : &#123;\"*actions\": \"defaultRoute\" // 匹配 http://example.com/#anything-here&#125;,defaultRoute : function(params) &#123;Router.params = params;&#125;,&#125;);var routerUtil = &#123;web_router : null,init()&#123;// 初始化if(!routerUtil.web_router)&#123;routerUtil.web_router = new Router;Backbone.history.start();&#125;&#125;,getParam(cbFn)&#123;routerUtil.init();// 获取#之后的参数if(cbFn)&#123;cbFn(Router.params);&#125;&#125;,route(returnUrl, cbFn)&#123;// 动态的调整 路由规则 例：topic/:pageno/:pagesizerouterUtil.web_router.route(returnUrl,\"page\", cbFn)&#125;,start()&#123;// 启用路由if(!Backbone.History.started)&#123;Backbone.history.start();&#125;&#125;,stop()&#123;// 关闭路由if(Backbone.History.started)&#123;Backbone.history.stop();&#125;&#125;,navigate(returnUrl)&#123;/*** 重构 ，路由导向*///此处根据自己的需求去构建参数拼接//returnUrl为'?'之后的内容if(returnUrl)&#123;&#125;else&#123;returnUrl = \"searchType=\" + SearchBoxUtil.searchType + \"&amp;\" + SearchBoxUtil.formData;&#125;routerUtil.web_router.navigate(returnUrl, &#123;trigger: true&#125;);&#125;&#125;return routerUtil;&#125;)(); 2.3 使用 在js中引用的一些方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445 // 页面的初始化initPagi : function()&#123;RouterUtil.getParam(function(params)&#123;if(!params)&#123;params = \"\";&#125;//处理参数...&#125;);&#125;,//查询函数queryData : function(returnUrl,isInitSearchBox)&#123;if(!returnUrl)&#123;returnUrl = \"\";&#125;if(isInitSearchBox)&#123;//第一次初始化查询&#125;else&#123;//非第一次初始化查询RouterUtil.navigate(returnUrl);&#125;...&#125;, 菜鸟一枚，随便弄弄的一点代码，有更好的方案请赐教","categories":[],"tags":[]},{"title":"Ctrl Shift O失效","slug":"ctrl shift o失效","date":"2017-08-25T02:24:00.000Z","updated":"2018-06-13T15:31:22.355Z","comments":true,"path":"2017/08/25/ctrl shift o失效/","link":"","permalink":"https://lossingdawn.top/2017/08/25/ctrl shift o失效/","excerpt":"摘要: 是这样的。preference -&gt; general -&gt; keys ,找到Organize Imports ,然后 在 “WHEN”里面 要选择 Editing JAVA SOURCE。 这个是最重要的阅读全文","text":"摘要: 是这样的。preference -&gt; general -&gt; keys ,找到Organize Imports ,然后 在 “WHEN”里面 要选择 Editing JAVA SOURCE。 这个是最重要的阅读全文 是这样的。preference -&gt; general -&gt; keys ,找到Organize Imports ,然后 在 “WHEN”里面 要选择 Editing JAVA SOURCE。 这个是最重要的","categories":[],"tags":[]},{"title":"findBugs英文代号的对照表","slug":"findBugs英文代号的对照表","date":"2017-04-28T03:09:00.000Z","updated":"2018-06-13T15:31:22.668Z","comments":true,"path":"2017/04/28/findBugs英文代号的对照表/","link":"","permalink":"https://lossingdawn.top/2017/04/28/findBugs英文代号的对照表/","excerpt":"摘要: findBugs错误英文翻译rule.findbugs.IMSE_DONT_CATCH_IMSE.name=不良实践 - 捕获可疑IllegalMonitorStateException rule.findbugs.BX_BOXING_IMMEDIATELY_UNBOXED.name=性能 - 基本类型包装之后立刻解包 rule.findbugs.IJU_SETUP_NO_SUPER.name=…阅读全文","text":"摘要: findBugs错误英文翻译rule.findbugs.IMSE_DONT_CATCH_IMSE.name=不良实践 - 捕获可疑IllegalMonitorStateException rule.findbugs.BX_BOXING_IMMEDIATELY_UNBOXED.name=性能 - 基本类型包装之后立刻解包 rule.findbugs.IJU_SETUP_NO_SUPER.name=…阅读全文 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408 findBugs错误英文翻译 rule.findbugs.IMSE_DONT_CATCH_IMSE.name=不良实践 - 捕获可疑IllegalMonitorStateExceptionrule.findbugs.BX_BOXING_IMMEDIATELY_UNBOXED.name=性能 - 基本类型包装之后立刻解包rule.findbugs.IJU_SETUP_NO_SUPER.name=使用错误 - TestCase定义的setUp没有调用super.setUp()rule.findbugs.TQ_ALWAYS_VALUE_USED_WHERE_NEVER_REQUIRED.name=使用错误 - 某个值使用了注解限制类型，但是这个限制永远不会发生rule.findbugs.TLW_TWO_LOCK_WAIT.name=多线程错误 - 等待两个被持有的锁rule.findbugs.RV_01_TO_INT.name=使用错误 - 0至1的随机数被当做整数0rule.findbugs.NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE.name=高危 - 参数必须非null但是标记为可为nullrule.findbugs.RV_ABSOLUTE_VALUE_OF_RANDOM_INT.name=使用错误 - 尝试计算32位随机整数的绝对值rule.findbugs.EC_INCOMPATIBLE_ARRAY_COMPARE.name=使用错误 - 使用equals()比较不兼容的数组rule.findbugs.UL_UNRELEASED_LOCK_EXCEPTION_PATH.name=多线程错误 - 方法没有在所有异常路径释放锁rule.findbugs.SE_NONSTATIC_SERIALVERSIONID.name=不良实践 - serialVersionUID不是static的rule.findbugs.UCF_USELESS_CONTROL_FLOW.name=高危 - 无用控制流rule.findbugs.BC_IMPOSSIBLE_CAST.name=使用错误 - 不可能的转换rule.findbugs.XSS_REQUEST_PARAMETER_TO_SEND_ERROR.name=安全风险 - servlet的反射导致跨站脚本漏洞rule.findbugs.DM_NEW_FOR_GETCLASS.name=性能 - 仅为了获得一个方法就创建了一个对象rule.findbugs.OBL_UNSATISFIED_OBLIGATION.name=试验 - 方法可能在清理流或资源时失败rule.findbugs.UW_UNCOND_WAIT.name=多线程错误 - 无条件等待rule.findbugs.DLS_DEAD_LOCAL_STORE_OF_NULL.name=高危 - 把null设置给不会用到的局部变量rule.findbugs.NM_CLASS_NAMING_CONVENTION.name=类名应该以大写字母开头rule.findbugs.RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN.name=使用错误 - 怀疑对两个布尔值的引用进行比较rule.findbugs.MWN_MISMATCHED_NOTIFY.name=多线程错误- 不匹配的notify()rule.findbugs.NM_VERY_CONFUSING.name=错误 - 非常容易迷惑的方法名rule.findbugs.FI_NULLIFY_SUPER.name=不良实践 - 空Finalizer禁用了超类的finalizerrule.findbugs.MTIA_SUSPECT_STRUTS_INSTANCE_FIELD.name=高危 - 继承了struts Action的类使用了实例变量rule.findbugs.DM_STRING_CTOR.name=性能 - 方法调用了效率很低的new String(String)构造方法rule.findbugs.STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE.name=多线程错误 - 调用静态DateFormatrule.findbugs.NP_NULL_PARAM_DEREF_NONVIRTUAL.name=使用错误 - 非虚拟方法调用向非空参数传入了nullrule.findbugs.FI_EMPTY.name=不良实践 - 应该删除空的finalizerrule.findbugs.CD_CIRCULAR_DEPENDENCY.name=试验 - 类间存在循环引用rule.findbugs.EC_UNRELATED_TYPES.name=使用错误 - 使用equals()比较不同类型rule.findbugs.EI_EXPOSE_STATIC_REP2.name=恶意代码漏洞 - 把可变对象保存到静态字段中可能会暴露内部静态状态rule.findbugs.DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY.name=错误 - 对数组执行toStringrule.findbugs.SIC_INNER_SHOULD_BE_STATIC_ANON.name=性能 - 可以重构成一个静态内部类rule.findbugs.STI_INTERRUPTED_ON_UNKNOWNTHREAD.name=错误 - 在thread实例上调用了静态Thread.interrupted()方法rule.findbugs.CN_IDIOM_NO_SUPER_CALL.name=不良实践 - clone方法没有调用super.clone()rule.findbugs.VA_FORMAT_STRING_BAD_ARGUMENT.name=错误用法 - 格式化字符串占位符与传入的参数不匹配rule.findbugs.EQ_DOESNT_OVERRIDE_EQUALS.name=高危 - 类没有覆盖父类的equals方法rule.findbugs.BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY.name=错误用法 - 集合转换为数组元素时发生的类型转换错误rule.findbugs.SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION.name=不良实践 - 类是可扩展的，但是没有提供无参数的构造方法rule.findbugs.TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_ALWAYS_SINK.name=错误用法 - 数值需要类型标示，但是却标记为未知rule.findbugs.SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS.name=性能 - 可以筹够成一个静态内部类rule.findbugs.EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS.name=不良实践 - equals检测不兼容的参数操作rule.findbugs.RV_RETURN_VALUE_OF_PUTIFABSENT_IGNORED.name=错误用法 - 忽略了putIfAbsent的返回值，传递给putIfAbsent的值被重用rule.findbugs.STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE.name=多线程错误 - 调用静态Calendarrule.findbugs.MS_CANNOT_BE_FINAL.name=恶意代码漏洞 - 字段不是final的，不能防止恶意代码的攻击rule.findbugs.IS_INCONSISTENT_SYNC.name=多线程错误 - 不一致的同步rule.findbugs.SE_NO_SERIALVERSIONID.name=不良实践 - 类是可序列化的，但是没有定义serialVersionUIDrule.findbugs.EI_EXPOSE_REP2.name=恶意代码漏洞 - 可能暴露内部实现，通过与可变对象引用协作rule.findbugs.NM_METHOD_CONSTRUCTOR_CONFUSION.name=错误用法 - 明显的方法/构造方法混淆rule.findbugs.ICAST_INTEGER_MULTIPLY_CAST_TO_LONG.name=高危 - 整形乘法的结果转换为long型rule.findbugs.QF_QUESTIONABLE_FOR_LOOP.name=高危 - for循环中存在复杂，微妙或者错误的自增rule.findbugs.DLS_DEAD_STORE_OF_CLASS_LITERAL.name=错误用法 - 类中保存了无用字符rule.findbugs.NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER.name=不良实践 - 使用了未来java版本中成为关键字的标识rule.findbugs.BC_VACUOUS_INSTANCEOF.name=高危 - instanceof会一直返回truerule.findbugs.INT_VACUOUS_BIT_OPERATION.name=高危 - 在整形上进行位操作时有一些位上出现空洞rule.findbugs.NP_NULL_INSTANCEOF.name=错误用法 - 一个已知的null值被检测它是否是一个类型的实例rule.findbugs.SIC_THREADLOCAL_DEADLY_EMBRACE.name=错误用法 - 非静态内部类和ThreadLocal的致命结合rule.findbugs.EQ_UNUSUAL.name=高危 - 罕见的equals方法rule.findbugs.IJU_NO_TESTS.name=错误用法 - TestCase没有任何测试rule.findbugs.EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC.name=错误用法 - equals方法覆盖了父类的equals可能功能不符rule.findbugs.XFB_XML_FACTORY_BYPASS.name=高危 - 方法直接调用了xml接口的一个具体实现rule.findbugs.SWL_SLEEP_WITH_LOCK_HELD.name=多线程错误 - 方法在获得锁时调用了Thread.sleep()rule.findbugs.CN_IDIOM.name=不良实践 - 类实现了Cloneable ，但是没有定义或使用clone方法rule.findbugs.WA_AWAIT_NOT_IN_LOOP.name=多线程错误 - 未在循环中使用的Condition.await()rule.findbugs.DM_FP_NUMBER_CTOR.name=性能 - 方法调用了低效的浮点书构造方法；应该使用静态的valueOf代替rule.findbugs.SF_SWITCH_NO_DEFAULT.name=Switch语句中没有包含defaultrule.findbugs.NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE.name=高危 - 调用返回返回值可能出现null值rule.findbugs.NP_CLONE_COULD_RETURN_NULL.name=不良实践 - Clone方法可能返回nullrule.findbugs.MS_OOI_PKGPROTECT.name=恶意代码漏洞 - 属性应该从接口中移除并将访问权限设置为包保护rule.findbugs.DM_BOXED_PRIMITIVE_TOSTRING.name=性能 - 方法使用了装箱的基本类型只为了调用toStringrule.findbugs.EQ_ABSTRACT_SELF.name=不良实践 - 抽象类定义了协变的equals方法rule.findbugs.DM_STRING_TOSTRING.name=性能 - 方法调用了String的toString()方法rule.findbugs.SE_METHOD_MUST_BE_PRIVATE.name=错误用法 - 方法必须是private的为了让序列化正常工作rule.findbugs.DL_SYNCHRONIZATION_ON_BOOLEAN.name=多线程错误 - 在Boolean上使用同步可能导致死锁rule.findbugs.UWF_UNWRITTEN_FIELD.name=错误用法 - 未赋值属性rule.findbugs.IS2_INCONSISTENT_SYNC.name=多线程错误 - 不一致的同步rule.findbugs.IM_AVERAGE_COMPUTATION_COULD_OVERFLOW.name=高危 - 计算平均值可能溢出rule.findbugs.BIT_SIGNED_CHECK_HIGH_BIT.name=错误用法 - 检查位运算的符号rule.findbugs.FL_MATH_USING_FLOAT_PRECISION.name=错误用法 - 方法进行数学运算时使用了浮点数的精度rule.findbugs.WS_WRITEOBJECT_SYNC.name=多线程错误 - 类的writeObject()方法是同步的，但是没有做其他事情rule.findbugs.RV_RETURN_VALUE_IGNORED.name=错误用法 - 方法忽略了返回值rule.findbugs.SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE.name=安全风险 - 非常量的字符串传递给方法执行SQL语句rule.findbugs.JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS.name=不良实践 - 不可变的类的属性应该是finalrule.findbugs.AM_CREATES_EMPTY_ZIP_FILE_ENTRY.name=不良实践 - 创建了一个空的zip文件的入口rule.findbugs.DM_NEXTINT_VIA_NEXTDOUBLE.name=性能 - 使用Random的nextInt方法来获得一个随机整数，而不是nextDoublerule.findbugs.UI_INHERITANCE_UNSAFE_GETRESOURCE.name=不良实践 - 如果类被扩展，GetResource的使用可能就是不安全的rule.findbugs.SIO_SUPERFLUOUS_INSTANCEOF.name=错误用法 - 不必要的类型检测使用instanceof操作符rule.findbugs.EQ_OTHER_NO_OBJECT.name=错误用法 - equals()方法定义，但是没有覆盖equals(Object)rule.findbugs.USM_USELESS_ABSTRACT_METHOD.name=试验 - 抽象方法已经在实现的接口中定义了rule.findbugs.MTIA_SUSPECT_SERVLET_INSTANCE_FIELD.name=高危 - 扩展Servlet的类使用了实例变量rule.findbugs.DM_USELESS_THREAD.name=多线程错误 - 使用默认的空run方法创建了一个线程rule.findbugs.ML_SYNC_ON_UPDATED_FIELD.name=多线程错误 - 方法在一个修改了的属性上进行了同步rule.findbugs.CO_SELF_NO_OBJECT.name=不良实践 - 协变的compareTo()定义rule.findbugs.BC_UNCONFIRMED_CAST.name=高危 - 未检查/未证实的类型转换rule.findbugs.FI_FINALIZER_NULLS_FIELDS.name=不良实践 - Finalizer空属性rule.findbugs.BIT_AND.name=错误用法 - 不兼容的位掩码(BIT_AND)rule.findbugs.FE_FLOATING_POINT_EQUALITY.name=高危 - 测试浮点数相等rule.findbugs.TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_NEVER_SINK.name=错误用法 - 值不要求有类型标示，但是标记为未知rule.findbugs.NP_NULL_PARAM_DEREF.name=错误用法 - 方法调用把null传递给一个非null参数rule.findbugs.FB_MISSING_EXPECTED_WARNING.name=试验 - findbugs丢失了期待或需要的警告rule.findbugs.DMI_INVOKING_HASHCODE_ON_ARRAY.name=错误用法 - 在数组上调用了hashCoderule.findbugs.QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT.name=错误用法 - 方法在布尔表达式中分配了boolean文字rule.findbugs.SA_FIELD_SELF_COMPARISON.name=错误用法 - 属性自己与自己进行了比较rule.findbugs.UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR.name=错误用法 - 父类的构造方法调用未初始化属性的方法rule.findbugs.ES_COMPARING_PARAMETER_STRING_WITH_EQ.name=不良实践 - 比较字符串参数使用了 == 或 !=rule.findbugs.INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE.name=错误用法 - 错误比较非负值与负数rule.findbugs.INT_BAD_COMPARISON_WITH_SIGNED_BYTE.name=错误用法 - 错误比较带符号的byterule.findbugs.IO_APPENDING_TO_OBJECT_OUTPUT_STREAM.name=错误用法 - 尝试向一个对象输出流添加信息rule.findbugs.FI_MISSING_SUPER_CALL.name=不良实践 - Finalizer没有调用父类的finalizerrule.findbugs.VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED.name=错误用法 - 传递了多余实际使用的格式化字符串的参数rule.findbugs.HE_EQUALS_USE_HASHCODE.name=不良实践 - 类定义了equals()，但使用了Object.hashCode()rule.findbugs.IJU_BAD_SUITE_METHOD.name=错误用法 - TestCase声明了一个错误的suite方法rule.findbugs.DMI_CONSTANT_DB_PASSWORD.name=安全风险 - 硬编码了数据库密码rule.findbugs.REC_CATCH_EXCEPTION.name=高危 - 捕获了没有抛出的异常rule.findbugs.PS_PUBLIC_SEMAPHORES.name=高危 - 类在公用接口中暴露了同步和信号rule.findbugs.EC_UNRELATED_INTERFACES.name=错误用法 - 调用equals()比较不同的接口类型rule.findbugs.UCF_USELESS_CONTROL_FLOW_NEXT_LINE.name=错误用法 - 执行到下一行的无用流程控制rule.findbugs.LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE.name=试验 - OpenJDK中存在潜在的丢失logger的风险，因为弱引用rule.findbugs.NP_UNWRITTEN_FIELD.name=错误用法 - 读取未初始化的属性rule.findbugs.DMI_UNSUPPORTED_METHOD.name=高危 - 调用不支持的方法rule.findbugs.RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE.name=高危 - 重复比较非空值和nullrule.findbugs.EC_BAD_ARRAY_COMPARE.name=错误用法 - 调用equals()，与==效果一样rule.findbugs.EI_EXPOSE_REP.name=恶意代码漏洞 - 可能通过返回一个可变对象的引用暴露了内部实现rule.findbugs.NP_DEREFERENCE_OF_READLINE_VALUE.name=高危 - 没有判断readLine()的结果是否为空rule.findbugs.UPM_UNCALLED_PRIVATE_METHOD.name=性能 - 从未用到的私有方法rule.findbugs.NP_NULL_ON_SOME_PATH.name=错误用法 - 可能出现空指针引用rule.findbugs.NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT.name=不良实践 - equals()方法没有检测null参数rule.findbugs.EC_NULL_ARG.name=错误用法 - 使用空参数调用equals()rule.findbugs.SE_BAD_FIELD_STORE.name=不良实践 - 非序列化值保存在序列化类的实例变量中rule.findbugs.VO_VOLATILE_REFERENCE_TO_ARRAY.name=多线程错误 - 数组的volatile引用不会把数组元素也当做volatile来引用rule.findbugs.NP_SYNC_AND_NULL_CHECK_FIELD.name=多线程错误 - 同步和空值检测发生在同一个属性上rule.findbugs.DM_EXIT.name=不良实践 - 方法调用了System.exit(...)rule.findbugs.RC_REF_COMPARISON.name=不良实践 - 怀疑进行了引用比较rule.findbugs.SE_NO_SUITABLE_CONSTRUCTOR.name=不良实践 - 类是可序列化的，但是父类没有定义无参数构造方法rule.findbugs.DC_DOUBLECHECK.name=多线程错误 - 可能对属性进行了双重检测rule.findbugs.DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT.name=错误用法 - 在int上调用了Double.longBitsToDoublerule.findbugs.RpC_REPEATED_CONDITIONAL_TEST.name=错误用法 - 重复判断条件rule.findbugs.WMI_WRONG_MAP_ITERATOR.name=性能 - keySet迭代是低效的，使用entrySet代替rule.findbugs.DLS_DEAD_LOCAL_STORE.name=高危 - 未用的局部变量rule.findbugs.INT_BAD_REM_BY_1.name=错误用法 - 整数剩余模1rule.findbugs.RV_RETURN_VALUE_IGNORED_BAD_PRACTICE.name=不良实践 - 方法忽略异常返回值rule.findbugs.SA_LOCAL_SELF_ASSIGNMENT.name=高危 - 局部变量的自我赋值rule.findbugs.MS_SHOULD_BE_FINAL.name=恶意代码漏洞 - 属性不是final，但是应该设置成finalrule.findbugs.SIC_INNER_SHOULD_BE_STATIC.name=性能 - 应该是一个静态内部类rule.findbugs.NP_GUARANTEED_DEREF.name=错误用法 - null值一定会被调用rule.findbugs.SE_READ_RESOLVE_MUST_RETURN_OBJECT.name=不良实践 - readResolve方法必须返回Objectrule.findbugs.NP_LOAD_OF_KNOWN_NULL_VALUE.name=高危 - 加载了已知的null值rule.findbugs.BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION.name=性能 - 基本数据被装箱又被拆箱rule.findbugs.CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE.name=不良实践 - 类定义了clone()但没有实现Cloneablerule.findbugs.CO_ABSTRACT_SELF.name=不良实践 - 抽象类定义了协变的compareTo()方法rule.findbugs.BAC_BAD_APPLET_CONSTRUCTOR.name=试验 - 错误的Applet构造方法依赖未初始化的AppletStubrule.findbugs.EQ_GETCLASS_AND_CLASS_CONSTANT.name=不良实践 - equals方法因为子类失败rule.findbugs.DB_DUPLICATE_SWITCH_CLAUSES.name=高危 - 在两个switch语句中使用了相同的代码rule.findbugs.DB_DUPLICATE_BRANCHES.name=高危 - 在两个分支中使用了相同的代码rule.findbugs.UOE_USE_OBJECT_EQUALS.name=试验 - 在final类上调用了equals，但是没有覆盖Object的equals方法rule.findbugs.FI_USELESS.name=不良实践 - Finalizer除了调用父类的finalizer以外什么也没做rule.findbugs.NP_ALWAYS_NULL.name=错误用法 - 调用了null指针rule.findbugs.DMI_VACUOUS_SELF_COLLECTION_CALL.name=错误用法 - 集合的调用不能被感知rule.findbugs.DLS_DEAD_LOCAL_STORE_IN_RETURN.name=错误用法 - 返回语句中的无用的赋值rule.findbugs.IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD.name=错误用法 - 在run方法中的JUnit检验不能报告给JUnitrule.findbugs.DMI_EMPTY_DB_PASSWORD.name=安全风险 - 空的数据库密码rule.findbugs.DM_BOOLEAN_CTOR.name=性能 - 方法调用了低效的Boolean构造方法；使用Boolean.valueOf(...)代替rule.findbugs.BC_IMPOSSIBLE_DOWNCAST.name=错误用法 - 不可能转型rule.findbugs.BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS.name=不良实践 - Equals方法不应该假设任何有关参数类型的事宜rule.findbugs.RV_EXCEPTION_NOT_THROWN.name=错误用法 - 异常创建后就丢弃了，没有抛出rule.findbugs.VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG.name=错误用法 - 基本类型数组传递给一个期待可变对象类型参数的方法rule.findbugs.LI_LAZY_INIT_UPDATE_STATIC.name=多线程错误 - 错误的延迟初始化和更新静态属性rule.findbugs.SA_FIELD_SELF_ASSIGNMENT.name=错误用法 - 属性自身赋值rule.findbugs.EQ_ALWAYS_FALSE.name=错误用法 - equals方法一直返回falserule.findbugs.DMI_RANDOM_USED_ONLY_ONCE.name=不良实践 - Random对象创建后只用了一次rule.findbugs.NM_CLASS_NOT_EXCEPTION.name=不良实践 - Class没有继承Exception，虽然名字像一个异常rule.findbugs.SA_LOCAL_DOUBLE_ASSIGNMENT.name=高危 - 给局部变量双重赋值rule.findbugs.NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS.name=错误用法 - 方法调用传递null给非空参数 (ALL_TARGETS_DANGEROUS)rule.findbugs.NP_TOSTRING_COULD_RETURN_NULL.name=不良实践 - toString方法可能返回nullrule.findbugs.BC_BAD_CAST_TO_ABSTRACT_COLLECTION.name=高危 - 转换成抽象集合值得怀疑rule.findbugs.NM_LCASE_HASHCODE.name=类定义了hashcode(); 应该是hashCode()吧？rule.findbugs.RU_INVOKE_RUN.name=多线程错误 - 在线程中调用了run（你的意思是再启动一次么？）rule.findbugs.DMI_INVOKING_TOSTRING_ON_ARRAY.name=错误用法 - 调用了数组的toStringrule.findbugs.NM_METHOD_NAMING_CONVENTION.name=方法名应该以小写字母开头rule.findbugs.RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES.name=高危 - 重复比较两个null值rule.findbugs.SA_LOCAL_SELF_COMPUTATION.name=错误用法 - 对一个变量进行无意义的自我计算 (比如 x &amp; x)rule.findbugs.MS_MUTABLE_HASHTABLE.name=恶意代码漏洞 - 属性是可变的Hashtablerule.findbugs.RV_DONT_JUST_NULL_CHECK_READLINE.name=高危 - 方法丢掉了readLine的结果，在检测它是非空之后。rule.findbugs.ES_COMPARING_STRINGS_WITH_EQ.name=不良实践 - 使用== 或 !=比较Stringrule.findbugs.DL_SYNCHRONIZATION_ON_SHARED_CONSTANT.name=多线程错误 - 同步内部String可能导致死锁rule.findbugs.MF_METHOD_MASKS_FIELD.name=错误用法 - 方法定义了一个变量，与实例变量同名。rule.findbugs.EQ_SELF_USE_OBJECT.name=错误用法 - 协变equals()方法定义，继承了Object.equals(Object)rule.findbugs.ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND.name=错误用法 - int值转换成float，然后传递给Math.roundrule.findbugs.GC_UNRELATED_TYPES.name=错误用法 - 泛型参数与方法参数没有相互关系rule.findbugs.BC_IMPOSSIBLE_INSTANCEOF.name=错误用法 - instanceof一直返回falserule.findbugs.SBSC_USE_STRINGBUFFER_CONCATENATION.name=性能 - 方法在循环中使用+进行字符串拼接rule.findbugs.ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL.name=错误用法 - int转换成double，然后传递给Math.ceilrule.findbugs.UG_SYNC_SET_UNSYNC_GET.name=多线程错误 - 未同步的getter方法，同步的setter方法rule.findbugs.RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION.name=错误用法 - 非法的正则表达式rule.findbugs.SA_FIELD_SELF_COMPUTATION.name=错误用法 - 无意义的自我计算 (比如 x &amp; x)rule.findbugs.DMI_SCHEDULED_THREAD_POOL_EXECUTOR_WITH_ZERO_CORE_THREADS.name=错误用法 - 创建了没有任何线程的ScheduledThreadPoolExecutorrule.findbugs.DMI_USELESS_SUBSTRING.name=高危 - 调用substring(0)会返回原值rule.findbugs.IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD.name=高危 - 被继承的或外部的方法的模棱两可的调用rule.findbugs.OS_OPEN_STREAM.name=不良实践 - 方法可能在关闭流时失败rule.findbugs.HE_INHERITS_EQUALS_USE_HASHCODE.name=不良实践 - 类继承了equals()，但使用了Object.hashCode()rule.findbugs.SE_NONFINAL_SERIALVERSIONID.name=不良实践 - serialVersionUID不是final的rule.findbugs.EQ_SELF_NO_OBJECT.name=不良实践 - 协变equals()方法定义rule.findbugs.SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH.name=由于switch语句导致的无用存储rule.findbugs.SW_SWING_METHODS_INVOKED_IN_SWING_THREAD.name=不良实践 - 某些swing方法需要在swing线程中调用rule.findbugs.VA_FORMAT_STRING_ILLEGAL.name=错误用法 - 非法的格式化字符串rule.findbugs.DM_NUMBER_CTOR.name=性能 - 方法调用低效的数字构造方法;使用静态valueOf代替rule.findbugs.RV_REM_OF_RANDOM_INT.name=高危 - 其余32位带符号随机整数rule.findbugs.EQ_COMPARING_CLASS_NAMES.name=错误用法 - equals方法比较类名而不是比较类rule.findbugs.ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD.name=高危 - 通过一个实例方法更新静态属性rule.findbugs.TQ_NEVER_VALUE_USED_WHERE_ALWAYS_REQUIRED.name=错误用法 - 某个值使用了注解标记不会限制类型，但是这个限制是必须的rule.findbugs.NS_NON_SHORT_CIRCUIT.name=高危 - 可疑的非短路逻辑rule.findbugs.VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT.name=错误用法 - 格式化字符串没有前面的参数rule.findbugs.SE_PRIVATE_READ_RESOLVE_NOT_INHERITED.name=高危 - 私有readResolve方法不是继承自父类rule.findbugs.RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE.name=高危 - 对一个已知不是null的值重复进行空值判断rule.findbugs.NM_LCASE_TOSTRING.name=类定义了tostring(); 应该是toString()吧？rule.findbugs.HSC_HUGE_SHARED_STRING_CONSTANT.name=性能 - 巨大的字符串常量在多个类文件中间重复了rule.findbugs.SE_TRANSIENT_FIELD_NOT_RESTORED.name=不良实践 - Transient属性没有再反序列化时被设置rule.findbugs.JLM_JSR166_LOCK_MONITORENTER.name=多线程错误 - 在java.util.concurrent Lock上进行了同步rule.findbugs.EQ_ALWAYS_TRUE.name=错误用法 - equals方法总是返回truerule.findbugs.ISC_INSTANTIATE_STATIC_CLASS.name=不良实践 - 只提供静态方法的类不需要实例化rule.findbugs.ICAST_IDIV_CAST_TO_DOUBLE.name=高危 - int相除的结果转换成double或floatrule.findbugs.RC_REF_COMPARISON_BAD_PRACTICE.name=错误用法 - 可疑的引用与常量的比较rule.findbugs.FI_EXPLICIT_INVOCATION.name=不良实践 - 直接调用finalizerrule.findbugs.ESync_EMPTY_SYNC.name=多线程错误 - 空的同步块rule.findbugs.DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION.name=错误用法 - 不要使用removeAll清空集合rule.findbugs.SE_BAD_FIELD.name=在序列化类中出现了非transient也非serializable的实例属性rule.findbugs.NP_STORE_INTO_NONNULL_FIELD.name=错误用法 - 属性已经标记为NonNull，但是设置了一个null值rule.findbugs.IT_NO_SUCH_ELEMENT.name=不良实践 - 迭代器的next()方法不能抛出NoSuchElementExceptionrule.findbugs.HRS_REQUEST_PARAMETER_TO_HTTP_HEADER.name=安全风险 - HTTP响应拆分漏洞rule.findbugs.DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED.name=高危 - 希望传入Runnable的地方传入了一个Threadrule.findbugs.NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH.name=错误用法 - null值会在exception处理中被用到rule.findbugs.RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE.name=高危 - 已知的null值被重复的检测rule.findbugs.DMI_CALLING_NEXT_FROM_HASNEXT.name=错误用法 - hasNext方法调用了next方法rule.findbugs.HE_HASHCODE_USE_OBJECT_EQUALS.name=不良实践 - 定义了hashCode()的类使用了Object.equals()rule.findbugs.VA_FORMAT_STRING_EXPECTED_MESSAGE_FORMAT_SUPPLIED.name=错误用法 - 需要使用printf样式时使用了MessageFormatrule.findbugs.NP_BOOLEAN_RETURN_NULL.name=不良实践 - 方法返回boolean类型返回了nullrule.findbugs.RI_REDUNDANT_INTERFACES.name=高危 - 类实现了父类一样的接口rule.findbugs.DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE.name=多线程错误 - 在装箱的基本属性上使用了同步rule.findbugs.STCAL_STATIC_CALENDAR_INSTANCE.name=多线程错误 - 静态Calendarrule.findbugs.RR_NOT_CHECKED.name=不良实践 - 方法忽略InputStream.read()的返回值rule.findbugs.IL_INFINITE_RECURSIVE_LOOP.name=错误用法 - 明显的无限递归循环rule.findbugs.DMI_NONSERIALIZABLE_OBJECT_WRITTEN.name=高危 - 非持久化的对象写入了ObjectOutputrule.findbugs.GC_UNCHECKED_TYPE_IN_GENERIC_CALL.name=不良实践 - 泛型调用中使用了未检查的类型rule.findbugs.IMA_INEFFICIENT_MEMBER_ACCESS.name=试验 - 方法访问了一个拥有的类的私有成员rule.findbugs.FI_PUBLIC_SHOULD_BE_PROTECTED.name=恶意代码漏洞 - Finalizer应该是protected，不能是publicrule.findbugs.RV_CHECK_FOR_POSITIVE_INDEXOF.name=高危 - 方法检查检查String.indexOf的结果是否为正数rule.findbugs.ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT.name=高危 - 无符号右移转换为short/byterule.findbugs.DM_STRING_VOID_CTOR.name=性能 - 方法调用了低效的new String()构造方法rule.findbugs.RE_POSSIBLE_UNINTENDED_PATTERN.name=错误用法 - \".\"用作正则表达式rule.findbugs.WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL.name=多线程错误 - 在getClass上使用同步而不是在class文字上rule.findbugs.ICAST_BAD_SHIFT_AMOUNT.name=错误用法 - 右移的数值不在0..31范围内rule.findbugs.SF_SWITCH_FALLTHROUGH.name=Switch语句中一个case失败以后进入了下一个caserule.findbugs.DP_DO_INSIDE_DO_PRIVILEGED.name=不良实践 - 方法调用应该在doPrivileged块中rule.findbugs.NO_NOTIFY_NOT_NOTIFYALL.name=多线程错误 - 使用notify()而不是notifyAll()rule.findbugs.SS_SHOULD_BE_STATIC.name=性能 - 未读取的属性：这个属性是否应该是static的？rule.findbugs.DM_RUN_FINALIZERS_ON_EXIT.name=不良实践 - 方法调用了危险的runFinalizersOnExit方法rule.findbugs.MS_FINAL_PKGPROTECT.name=恶意代码漏洞 - 属性应该同时是final 和 package protected的rule.findbugs.BC_BAD_CAST_TO_CONCRETE_COLLECTION.name=高危 - 转换成具体集合可能有问题rule.findbugs.BIT_IOR_OF_SIGNED_BYTE.name=错误用法 - 在带符号的byte值上进行位OR运算rule.findbugs.MSF_MUTABLE_SERVLET_FIELD.name=多线程错误 - 可变的servlet属性rule.findbugs.SE_BAD_FIELD_INNER_CLASS.name=不良实践 - 非serializable类有一个可序列化的内部类rule.findbugs.BIT_ADD_OF_SIGNED_BYTE.name=错误用法 - 在带符号的byte值上进行位add运算rule.findbugs.FI_FINALIZER_ONLY_NULLS_FIELDS.name=不良实践 - Finalizer中子还有null属性rule.findbugs.DE_MIGHT_IGNORE.name=不良实践 - 方法可能忽略异常rule.findbugs.XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER.name=安全风险 - Servlet反射跨域脚本漏洞rule.findbugs.ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD.name=多线程错误 - 使用同步的属性可能发生改变rule.findbugs.SQL_BAD_PREPARED_STATEMENT_ACCESS.name=错误用法 - 方法尝试访问PreparedStatement参数的索引是0rule.findbugs.DM_CONVERT_CASE.name=国际化 - 考虑使用国际化参数型的调用方法版本rule.findbugs.SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS.name=高危 - 类的transient属性不能序列化rule.findbugs.NN_NAKED_NOTIFY.name=多线程错误 - 未使用同步包裹的notifyrule.findbugs.VA_FORMAT_STRING_MISSING_ARGUMENT.name=错误用法 - 格式化字符串引用的参数丢失rule.findbugs.IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION.name=不良实践 - 父类初始化时使用了子类rule.findbugs.SA_LOCAL_SELF_COMPARISON.name=错误用法 - 自己和自己的值比较rule.findbugs.IM_BAD_CHECK_FOR_ODD.name=高危 - 对奇偶判断不能用于负数rule.findbugs.NP_CLOSING_NULL.name=错误用法 - close()调用了一个永远是null的值rule.findbugs.XSS_REQUEST_PARAMETER_TO_JSP_WRITER.name=安全风险 - JSP反射调用跨域脚本漏洞rule.findbugs.IS_FIELD_NOT_GUARDED.name=多线程错误 - 属性不能保证同步访问rule.findbugs.DM_GC.name=性能 - 直接调用垃圾回收，特别是在性能测试中的可疑代码rule.findbugs.IM_MULTIPLYING_RESULT_OF_IREM.name=错误用法 - 整数乘法的结果是整数rule.findbugs.SE_COMPARATOR_SHOULD_BE_SERIALIZABLE.name=不良实践 - Comparator没有实现Serializablerule.findbugs.HE_HASHCODE_NO_EQUALS.name=不良实践 - 类定义了hashCode()但是没定义equals()rule.findbugs.MF_CLASS_MASKS_FIELD.name=错误用法 - 类定义了属性覆盖了父类的属性rule.findbugs.NM_VERY_CONFUSING_INTENTIONAL.name=不良实践 - 非常迷惑的方法名称（可能是内部方法）rule.findbugs.SR_NOT_CHECKED.name=不良实践 - 方法忽略了InputStream.skip()的结果rule.findbugs.LI_LAZY_INIT_STATIC.name=多线程错误 - 错误的对static属性进行了延迟初始化rule.findbugs.DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION.name=错误用法 - 不能使用反射检测没有标记为runtime rentention的注解的存在rule.findbugs.ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH.name=不良实践 - 方法可能在关闭database资源时因为异常失败rule.findbugs.BIT_IOR.name=错误用法 - 不兼容的位掩码（BIT_IOR）rule.findbugs.ODR_OPEN_DATABASE_RESOURCE.name=不良实践 - 方法可能在关闭database资源时失败rule.findbugs.IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN.name=错误用法 - 参数没有被使用，但是被重新赋值了rule.findbugs.SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING.name=安全风险 - 使用非常量字符串创建了一个PreparedStatementrule.findbugs.UUF_UNUSED_FIELD.name=性能 - 无用的属性rule.findbugs.RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE.name=错误用法 - 对一个已经使用的值进行了null检测rule.findbugs.EQ_OTHER_USE_OBJECT.name=错误用法 - equals()方法定义没有覆盖Object.equals(Object)rule.findbugs.SP_SPIN_ON_FIELD.name=多线程错误 - 方法对一个属性循环复制rule.findbugs.SI_INSTANCE_BEFORE_FINALS_ASSIGNED.name=不良实践 - 在所有静态final属性赋值之前static初始化块创建了一个实例rule.findbugs.NP_ALWAYS_NULL_EXCEPTION.name=错误用法 - 方法的异常路径中引用了空指针rule.findbugs.MS_EXPOSE_REP.name=恶意代码漏洞 - Public static方法可能因为返回了一个数组而暴露内部实现rule.findbugs.VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN.name=高危 - 非布尔参数使用%b进行了格式化rule.findbugs.MS_PKGPROTECT.name=恶意代码漏洞 - 属性应该是package protectedrule.findbugs.NP_NONNULL_RETURN_VIOLATION.name=错误用法 - 方法可能返回null，但是声明了 @NonNullrule.findbugs.J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION.name=不良实践 - 在HttpSession中保存了不可序列化的对象rule.findbugs.NM_SAME_SIMPLE_NAME_AS_SUPERCLASS.name=不良实践 - 类名不应该和父类的名称相同rule.findbugs.DMI_BLOCKING_METHODS_ON_URL.name=性能 - URL的equals 和 hashCode 方法会被堵塞rule.findbugs.HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS.name=错误用法 - 在哈希构造中声明了不能哈希的类rule.findbugs.UR_UNINIT_READ.name=错误用法 - 构造方法中对未初始化的类进行了读取rule.findbugs.WA_NOT_IN_LOOP.name=多线程错误 - Wait不在循环中rule.findbugs.DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR.name=错误用法 - 尝试修改ScheduledThreadPoolExecutor的最大数rule.findbugs.RV_RETURN_VALUE_IGNORED2.name=错误用法 - 方法忽略了返回值rule.findbugs.NM_FIELD_NAMING_CONVENTION.name=属性名应该以小写字母开头rule.findbugs.FB_UNEXPECTED_WARNING.name=试验 - 未期待/未期望的findbugs警告rule.findbugs.BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR.name=错误用法 - 基础类型拆箱后用于三元表达式rule.findbugs.DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED.name=不良实践 - Classloaders应该只在doPrivileged块中被创建rule.findbugs.NM_WRONG_PACKAGE.name=错误用法 - 方法没有覆盖父类的方法，因为参数的包不正确rule.findbugs.IL_CONTAINER_ADDED_TO_ITSELF.name=错误用法 - 一个集合被添加到自身rule.findbugs.CI_CONFUSED_INHERITANCE.name=高危 - 类是final的，但是定义了protected属性rule.findbugs.HE_USE_OF_UNHASHABLE_CLASS.name=错误用法 - 在哈希数据结构中使用的类没有定义hashCode()方法rule.findbugs.IJU_SUITE_NOT_STATIC.name=错误用法 - TestCase实现了非static suite方法rule.findbugs.RS_READOBJECT_SYNC.name=多线程错误 - 类的readObject()方法不是同步的rule.findbugs.AM_CREATES_EMPTY_JAR_FILE_ENTRY.name=不良实践 - 创建了一个空的jar方法入口rule.findbugs.VA_FORMAT_STRING_BAD_CONVERSION_FROM_ARRAY.name=错误用法 - 使用格式化字符串对数组进行了无用的格式化rule.findbugs.SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW.name=switch语句失败抛出异常导致无用的存储rule.findbugs.RV_ABSOLUTE_VALUE_OF_HASHCODE.name=错误用法 - 错误的尝试计算带符号的32位hashcodde的绝对值rule.findbugs.EQ_DONT_DEFINE_EQUALS_FOR_ENUM.name=错误用法 - 枚举定义了协变equals()方法定义rule.findbugs.SA_FIELD_DOUBLE_ASSIGNMENT.name=错误用法 - 对属性进行双重赋值rule.findbugs.DMI_COLLECTION_OF_URLS.name=性能 - URL的Maps 和 sets可能是性能大问题rule.findbugs.NM_SAME_SIMPLE_NAME_AS_INTERFACE.name=不良实践 - 类名不应该和实现的接口名相同rule.findbugs.UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR.name=错误用法 - 构造方法没有初始化属性rule.findbugs.TQ_MAYBE_SOURCE_VALUE_REACHES_NEVER_SINK.name=错误用法 - 值可能带着一个类型修饰符，一直使用的方式是与这个类型修饰符相悖的rule.findbugs.SE_NONLONG_SERIALVERSIONID.name=不良实践 - serialVersionUID不是long型rule.findbugs.RV_REM_OF_HASHCODE.name=高危 - hashCode的结果可能是负数negativerule.findbugs.NS_DANGEROUS_NON_SHORT_CIRCUIT.name=高危 - 潜在危险使用非短跳出逻辑rule.findbugs.USM_USELESS_SUBCLASS_METHOD.name=试验 - 方法代理到父类方法rule.findbugs.ITA_INEFFICIENT_TO_ARRAY.name=性能 - 方法使用了toArray()对空数组参数rule.findbugs.DM_MONITOR_WAIT_ON_CONDITION.name=多线程错误 - 根据条件监控wait()的调用rule.findbugs.BOA_BADLY_OVERRIDDEN_ADAPTER.name=错误用法 - 类覆盖了父类中实现的方法适配器错误rule.findbugs.IC_INIT_CIRCULARITY.name=高危 - 初始化死循环rule.findbugs.NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER.name=不良实践 - 使用的标记是未来java版本中的关键字rule.findbugs.EC_UNRELATED_CLASS_AND_INTERFACE.name=错误用法 - equals()比较无关的类和接口rule.findbugs.TQ_MAYBE_SOURCE_VALUE_REACHES_ALWAYS_SINK.name=错误用法 - 值可能没有携带一个类修饰符，但是使用中会一直需要这个类修饰符rule.findbugs.FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER.name=错误用法 - 测试是否与NaN相等rule.findbugs.NM_CONFUSING.name=不良实践 - 迷惑的方法名rule.findbugs.VA_FORMAT_STRING_ARG_MISMATCH.name=错误用法 - 格式化字符串参数的数目与占位符不相等rule.findbugs.NP_NULL_ON_SOME_PATH_EXCEPTION.name=错误用法 - 方法的异常路径中可能引用空指针rule.findbugs.DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE.name=多线程错误 - 同步装箱基本类型可能导致死锁rule.findbugs.IJU_TEARDOWN_NO_SUPER.name=错误用法 - TestCase定义的tearDown没有调用super.tearDown()rule.findbugs.SE_READ_RESOLVE_IS_STATIC.name=错误用法 - readResolve方法没有生命为static方法rule.findbugs.NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE.name=高危 - 这个路径上空指针引用是不可实现的rule.findbugs.UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS.name=错误用法 - 匿名内部类中定义的不可调用的方法rule.findbugs.VA_FORMAT_STRING_BAD_CONVERSION.name=错误用法 - 提供的参数类型与格式化标记不符rule.findbugs.EC_ARRAY_AND_NONARRAY.name=错误用法 - equals()用来比较数组和非数组rule.findbugs.NM_BAD_EQUAL.name=类定义了equal(Object)，应该是equals(Object)吧？rule.findbugs.EC_UNRELATED_TYPES_USING_POINTER_EQUALITY.name=错误用法 - 使用指针比较不同的类型rule.findbugs.STI_INTERRUPTED_ON_CURRENTTHREAD.name=错误用法 - currentThread()调用的不必要用法，调用了interrupted()rule.findbugs.RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION.name=错误用法 - File.separator用做正则表达式rule.findbugs.MWN_MISMATCHED_WAIT.name=多线程错误 - 不匹配的wait()rule.findbugs.IL_INFINITE_LOOP.name=错误用法 - 明显的无限循环rule.findbugs.NP_IMMEDIATE_DEREFERENCE_OF_READLINE.name=高危 - 立刻使用了readLine()的结果rule.findbugs.SC_START_IN_CTOR.name=多线程错误 - 构造方法调用了Thread.start()rule.findbugs.STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE.name=多线程错误 - 静态DateFormatrule.findbugs.HE_EQUALS_NO_HASHCODE.name=不良实践 - 类定义了equals()，但是没有hashCode()rule.findbugs.UL_UNRELEASED_LOCK.name=多线程错误 - 方法没有在任何路径中释放锁rule.findbugs.PZLA_PREFER_ZERO_LENGTH_ARRAYS.name=高危 - 考虑返回空数组而不是nullrule.findbugs.SKIPPED_CLASS_TOO_BIG.name=高危 - 类太大不能分析rule.findbugs.NP_ARGUMENT_MIGHT_BE_NULL.name=错误用法 - 方法没有检查空参数rule.findbugs.UM_UNNECESSARY_MATH.name=性能 - 方法常量调用了静态Math类方法rule.findbugs.NM_WRONG_PACKAGE_INTENTIONAL.name=不良实践 - 方法没有覆盖父类的方法因为参数包名错误rule.findbugs.NP_NONNULL_PARAM_VIOLATION.name=错误用法 - 方法传递null给一个非空参数rule.findbugs.BIT_AND_ZZ.name=错误用法 - 检查 ((...) &amp; 0) == 0 是否成立rule.findbugs.HRS_REQUEST_PARAMETER_TO_COOKIE.name=安全风险 - HTTP cookie可能来自不被信任的输入rule.findbugs.SQL_BAD_RESULTSET_ACCESS.name=错误用法 - 方法尝试访问一个ResultSet，但是使用的index是0rule.findbugs.INT_VACUOUS_COMPARISON.name=高危 - 整形的空比较rule.findbugs.EQ_COMPARETO_USE_OBJECT_EQUALS.name=不良实践 - 类定义了compareTo(...)，但使用了Object.equals()rule.findbugs.DMI_HARDCODED_ABSOLUTE_FILENAME.name=高危 - 类包含一个硬编码的绝对路径rule.findbugs.DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES.name=错误用法 - 集合不应该包含自身rule.findbugs.URF_UNREAD_FIELD.name=性能 - 读不到的属性rule.findbugs.DLS_OVERWRITTEN_INCREMENT.name=错误用法 - 重写了自增rule.findbugs.BIT_SIGNED_CHECK.name=不良实践 - 检测带符号的位运算rule.findbugs.UWF_NULL_FIELD.name=错误用法 - 属性曾经设置为nullrule.findbugs.DE_MIGHT_DROP.name=不良实践 - 方法可能抛出异常rule.findbugs.DMI_BAD_MONTH.name=错误用法 - 对于month错误的常量值rule.findbugs.MS_MUTABLE_ARRAY.name=恶意代码漏洞 - 属性是可变数组rule.findbugs.SE_INNER_CLASS.name=不良实践 - 可序列化的内部类rule.findbugs.OS_OPEN_STREAM_EXCEPTION_PATH.name=不良实践 - 方法可能在关闭流时因为异常而失败rule.findbugs.AT_OPERATION_SEQUENCE_ON_CONCURRENT_ABSTRACTION.name=并发抽象的顺序调用可能不是原子的rule.findbugs.BX_UNBOXING_IMMEDIATELY_REBOXED.name=装箱的值被拆箱，然后立刻重新装箱了rule.findbugs.CO_COMPARETO_RESULTS_MIN_VALUE.name=compareTo()或compare()返回Integer.MIN_VALUErule.findbugs.DLS_DEAD_LOCAL_STORE_SHADOWS_FIELD.name=无用的局部变量可能与实例属性同名rule.findbugs.DMI_ARGUMENTS_WRONG_ORDER.name=方法参数顺序翻转rule.findbugs.DMI_BIGDECIMAL_CONSTRUCTED_FROM_DOUBLE.name=由double构造BigDecimal时没有指定精确度rule.findbugs.DMI_DOH.name=一个明显不合理的方法调用rule.findbugs.DMI_ENTRY_SETS_MAY_REUSE_ENTRY_OBJECTS.name=一个入口的添加可能因为重用Entry对象导致失败rule.findbugs.DM_DEFAULT_ENCODING.name=信任默认字符编码rule.findbugs.ICAST_INT_2_LONG_AS_INSTANT.name=int转换成long，用来当做绝对时间rule.findbugs.INT_BAD_COMPARISON_WITH_INT_VALUE.name=错误比较int值和long常量rule.findbugs.JML_JSR166_CALLING_WAIT_RATHER_THAN_AWAIT.name=在util.concurrent抽象中使用监控样式的wait方法rule.findbugs.NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD.name=读取了未初始化的public或protected属性rule.findbugs.OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE.name=方法可能因为checked exception导致清理流或资源失败rule.findbugs.PZ_DONT_REUSE_ENTRY_OBJECTS_IN_ITERATORS.name=不用在iterator里重用entry对象rule.findbugs.RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE.name=compareTo返回的值与指定的值进行检测rule.findbugs.RV_NEGATING_RESULT_OF_COMPARETO.name=调换了compareTo()/compare()结果的正负rule.findbugs.RV_RETURN_VALUE_IGNORED_INFERRED.name=方法忽略了返回值，这是正常的吗？rule.findbugs.SA_LOCAL_SELF_ASSIGNMENT_INSTEAD_OF_FIELD.name=局部变量给自己赋值而不是赋值到实例变量中rule.findbugs.URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD.name=未被读取的public/protected属性rule.findbugs.UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD.name=未被使用的public 或 protected 属性rule.findbugs.UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD.name=未初始化的public 或 protected 属性rule.findbugs.VA_FORMAT_STRING_USES_NEWLINE.name=格式化代码应该使用%n代替\\nrule.findbugs.VO_VOLATILE_INCREMENT.name=volatile的自增操作不是原子的","categories":[],"tags":[]},{"title":"枚举类工具","slug":"枚举类工具","date":"2017-04-19T02:22:00.000Z","updated":"2018-06-13T15:31:22.668Z","comments":true,"path":"2017/04/19/枚举类工具/","link":"","permalink":"https://lossingdawn.top/2017/04/19/枚举类工具/","excerpt":"摘要: 枚举类是程序中常用的一种类型，当经常面对说明与标识混乱的情况。在此记录一个枚举类的写法，方便标识与说明的绑定 基类： 枚举类： 使用：阅读全文","text":"摘要: 枚举类是程序中常用的一种类型，当经常面对说明与标识混乱的情况。在此记录一个枚举类的写法，方便标识与说明的绑定 基类： 枚举类： 使用：阅读全文 枚举类是程序中常用的一种类型，当经常面对说明与标识混乱的情况。在此记录一个枚举类的写法，方便标识与说明的绑定 基类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798 import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public abstract class StandardType &#123; private String key; private String title; public StandardType(String key, String title) &#123; this.title = title; this.key = key; &#125; public String getTitle() &#123; return title; &#125; public static String getTitle(StandardType[] values, String key) &#123; StandardType val = StandardType.getEnum(values, key); if (val == null) &#123; return null; &#125; else &#123; return val.getTitle(); &#125; &#125; public String getKey() &#123; return key; &#125; public static String getKey(StandardType[] values, String title) &#123; for (StandardType val : values) &#123; if (val.getTitle().equals(title)) &#123; return val.getKey(); &#125; &#125; return null; &#125; public static StandardType getEnum(StandardType[] values, String key) &#123; for (StandardType val : values) &#123; if (val.getKey().equals(key)) &#123; return val; &#125; &#125; return null; &#125; public String toString() &#123; return key; &#125; public boolean equals(StandardType type) &#123; if (type == null) &#123; return false; &#125; return this.key.equals(type.getKey()); &#125; /** * get value options based on values * * @param values * @return */ public static List&lt;Map&lt;String, String&gt;&gt; getOpts(StandardType[] values) &#123; List&lt;Map&lt;String, String&gt;&gt; opts = new ArrayList&lt;Map&lt;String, String&gt;&gt;(); Map&lt;String, String&gt; opt = null; for (StandardType val : values) &#123; opt = new HashMap&lt;String, String&gt;(); opt.put(\"key\", val.getKey()); opt.put(\"title\", val.getTitle()); opts.add(opt); &#125; return opts; &#125; /** * get value options based on values(Fuzzy query) * * @param values * @return */ public static List&lt;Map&lt;String, String&gt;&gt; getSimilarOpts(StandardType[] values, String input) &#123; List&lt;Map&lt;String, String&gt;&gt; opts = new ArrayList&lt;Map&lt;String, String&gt;&gt;(); Map&lt;String, String&gt; opt = null; for (StandardType val : values) &#123; if (val.getTitle().contains(input)) &#123; opt = new HashMap&lt;String, String&gt;(); opt.put(\"key\", val.getKey()); opt.put(\"title\", val.getTitle()); opts.add(opt); &#125; &#125; return opts; &#125;&#125; 枚举类： 1234567891011121314/** * 支付方式 */ public static class PayWay extends StandardType &#123; public final static PayWay WeChatPay = new PayWay(\"WeChatPay\", \"微信支付\"); public final static PayWay AliPay = new PayWay(\"AliPay\", \"支付宝支付\"); public final static PayWay UnionPay = new PayWay(\"UnionPay\", \"银联支付\"); public final static PayWay CashPay = new PayWay(\"CashPay\", \"现金支付\"); public final static PayWay[] values = &#123; WeChatPay, AliPay, UnionPay, CashPay &#125;; public PayWay(String key, String title) &#123; super(key, title); &#125; &#125; 使用： 12345678910111213public static void main(String[] args) &#123; PayWay.AliPay.toString();// AliPay // dome1 StandardType patWay = PayWay.getEnum(PayWay.values, \"AliPay\"); patWay.getKey();// AliPay patWay.getTitle();// 支付宝支付 // dome2 PayWay.getKey(PayWay.values, \"支付宝支付\");// AliPay PayWay.getTitle(PayWay.values, \"AliPay\");// 支付宝支付 // dome3 List&lt;Map&lt;String, String&gt;&gt; listMap1 = PayWay.getOpts(PayWay.values);//所有map List&lt;Map&lt;String, String&gt;&gt; listMap2 = PayWay.getSimilarOpts(PayWay.values, \"支\");//一条支付宝的map &#125;","categories":[],"tags":[]},{"title":"java.util.LinkedHashMap Cannot Be Cast To","slug":"java.util.LinkedHashMap cannot be cast to","date":"2017-04-17T06:39:00.000Z","updated":"2018-06-13T15:31:22.668Z","comments":true,"path":"2017/04/17/java.util.LinkedHashMap cannot be cast to/","link":"","permalink":"https://lossingdawn.top/2017/04/17/java.util.LinkedHashMap cannot be cast to/","excerpt":"摘要: Jackson转换泛型List出现错误java.util.LinkedHashMap cannot be cast to com.xxx ObjectMapper mapper = new ObjectMapper(); mapper.readValue(new File(fileAPI.getRo阅读全文","text":"摘要: Jackson转换泛型List出现错误java.util.LinkedHashMap cannot be cast to com.xxx ObjectMapper mapper = new ObjectMapper(); mapper.readValue(new File(fileAPI.getRo阅读全文 Jackson转换泛型List出现错误java.util.LinkedHashMap cannot be cast to com.xxx ObjectMapper mapper = new ObjectMapper(); mapper.readValue(new File(fileAPI.getRoot(), jsonFileName), Map.class); 当使用Jackson解析具体的bean时，应该使用尽量详尽的本来解析，而使用Map.class、List.class解析时，会对具体的bean解析不出 使用new TypeReference&lt;List&gt;(){}，或者具体的Object.class， 注：Object为具体的解析类","categories":[],"tags":[]},{"title":"Bulk更新mongodb的脚本","slug":"bulk更新mongodb的脚本","date":"2017-03-22T05:43:00.000Z","updated":"2018-06-13T15:31:22.668Z","comments":true,"path":"2017/03/22/bulk更新mongodb的脚本/","link":"","permalink":"https://lossingdawn.top/2017/03/22/bulk更新mongodb的脚本/","excerpt":"摘要: bulk批处理mongodb，比普通的js脚本来的更快一些。 官方网址：https://docs.mongodb.com/manual/reference/method/Bulk/ bulk支持的方法： bulk插入示例： bulk更新示例： 打印字符串： 移除： 替换： 插入并更新： 获得历史： 阅读全文","text":"摘要: bulk批处理mongodb，比普通的js脚本来的更快一些。 官方网址：https://docs.mongodb.com/manual/reference/method/Bulk/ bulk支持的方法： bulk插入示例： bulk更新示例： 打印字符串： 移除： 替换： 插入并更新： 获得历史： 阅读全文 bulk批处理mongodb，比普通的js脚本来的更快一些。 官方网址：https://docs.mongodb.com/manual/reference/method/Bulk/ bulk支持的方法： Name Description Bulk.insert() Adds an insert operation to a list of operations. Bulk.find() Specifies the query condition for an update or a remove operation. Bulk.find.removeOne() Adds a single document remove operation to a list of operations. Bulk.find.remove() Adds a multiple document remove operation to a list of operations. Bulk.find.replaceOne() Adds a single document replacement operation to a list of operations. Bulk.find.updateOne() Adds a single document update operation to a list of operations. Bulk.find.update() Adds a multi update operation to a list of operations. Bulk.find.upsert() Specifies upsert: true for an update operation. Bulk.execute() Executes a list of operations in bulk. Bulk.getOperations() Returns an array of write operations executed in the Bulk() operations object. Bulk.tojson() Returns a JSON document that contains the number of operations and batches in the Bulk() operations object. Bulk.toString() Returns the Bulk.tojson() results as a string. bulk插入示例： 12345 var bulk = db.items.initializeUnorderedBulkOp();bulk.insert( &#123; item: \"abc123\", defaultQty: 100, status: \"A\", points: 100 &#125; );bulk.insert( &#123; item: \"ijk123\", defaultQty: 200, status: \"A\", points: 200 &#125; );bulk.insert( &#123; item: \"mop123\", defaultQty: 0, status: \"P\", points: 0 &#125; );bulk.execute(); bulk更新示例： 123456789101112131415161718192021222324252627 /** * 批量更新数据库对象 * 1. 按条件批量更新 * 2. 无条件批量更新 *//** 1. 按条件批量更新 **/// step 1: get key-valuevar idArray = [];var valueArray = [];var idx = -1;db.conch_ChargeSchedule.find(&#123;'predictChargeValue':&#123;$exists:false&#125;&#125;).forEach(function(obj)&#123; idx++; idArray[idx]=obj._id; valueArray[idx]=obj.planValue;&#125;);// step 2: updatevar bulk = db.conch_ChargeSchedule.initializeUnorderedBulkOp();for(var i=0; i&lt;idArray.length; i++)&#123; bulk.find( &#123; _id: idArray[i] &#125; ).update(&#123; $set: &#123; predictChargeValue: valueArray[i] &#125; &#125;);&#125;bulk.execute();/** 2. 无条件批量更新 **/var bulk = db.conch_ChargeSchedule.initializeUnorderedBulkOp();bulk.find(&#123;&#125;).update(&#123; $set: &#123; isPlanValueUpdatable: true, isStatusUpdatable:true, isStartDateUpdatable:true &#125; &#125;);bulk.execute(); 123 var bulk = db.items.initializeUnorderedBulkOp();bulk.find( &#123; status: \"D\" &#125; ).updateOne( &#123; $set: &#123; status: \"I\", points: \"0\" &#125; &#125; );bulk.execute(); 打印字符串： 12345 var bulk = db.items.initializeOrderedBulkOp();bulk.insert( &#123; item: \"abc123\", status: \"A\", defaultQty: 500, points: 5 &#125; );bulk.insert( &#123; item: \"ijk123\", status: \"A\", defaultQty: 100, points: 10 &#125; );bulk.find( &#123; status: \"D\" &#125; ).removeOne();bulk.toString(); 移除： 123 var bulk = db.items.initializeUnorderedBulkOp();bulk.find( &#123; status: \"D\" &#125; ).remove();bulk.execute(); 替换： 123 var bulk = db.items.initializeUnorderedBulkOp();bulk.find( &#123; item: \"abc123\" &#125; ).replaceOne( &#123; item: \"abc123\", status: \"P\", points: 100 &#125; );bulk.execute(); 插入并更新： 123456789 var bulk = db.items.initializeUnorderedBulkOp();bulk.find( &#123; status: \"P\", item: null &#125; ).upsert().updateOne( &#123; $setOnInsert: &#123; defaultQty: 0, inStock: true &#125;, $currentDate: &#123; lastModified: true &#125;, $set: &#123; points: \"0\" &#125; &#125;);bulk.execute(); 获得历史： 12345678 var bulk = db.items.initializeUnorderedBulkOp();for (var i = 1; i &lt;= 1500; i++) &#123; bulk.insert( &#123; x: i &#125; );&#125;bulk.execute();bulk.getOperations();// 获得操作历史 普通的js脚本更新mongodb库，为单线程阻塞方式，有数据大小限制，数据大了容易断掉。bulk的则不会出现这种状况，效率max","categories":[],"tags":[]},{"title":"Html提示框插件","slug":"html提示框插件","date":"2016-06-16T01:33:00.000Z","updated":"2018-06-13T15:31:22.668Z","comments":true,"path":"2016/06/16/html提示框插件/","link":"","permalink":"https://lossingdawn.top/2016/06/16/html提示框插件/","excerpt":"摘要: 最近工作需要，用到各式各样的提示框，寻找了很久，发现一个的第三方的插件很好用，各种样式、接口良好、允许自定义。 官网：http://layer.layui.com/ 使用需要先引入jq1.8以上：阅读全文","text":"摘要: 最近工作需要，用到各式各样的提示框，寻找了很久，发现一个的第三方的插件很好用，各种样式、接口良好、允许自定义。 官网：http://layer.layui.com/ 使用需要先引入jq1.8以上：阅读全文 最近工作需要，用到各式各样的提示框，寻找了很久，发现一个的第三方的插件很好用，各种样式、接口良好、允许自定义。 官网：http://layer.layui.com/ 使用需要先引入jq1.8以上： 12 &lt;script src=\"http://libs.baidu.com/jquery/1.9.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;script src=\"layer/layer.js\"&gt;&lt;/script&gt;","categories":[],"tags":[]},{"title":"ListView在ScrollView中不显示全部的问题","slug":"ListView在ScrollView中不显示全部的问题","date":"2015-09-22T02:27:00.000Z","updated":"2018-06-13T15:31:21.408Z","comments":true,"path":"2015/09/22/ListView在ScrollView中不显示全部的问题/","link":"","permalink":"https://lossingdawn.top/2015/09/22/ListView在ScrollView中不显示全部的问题/","excerpt":"摘要: 在实际应用中，我们可能会遇到把ListView放到ScrollView中的情况，在这种情况下，ListView的滑动属性与ScrollView的滑动出现冲突，从而ListView只显示一项。这里提供一种解决方案，就是设置ListView中每个Item的高度显示之，使他失去滑动的属性，从而适应Sc…阅读全文","text":"摘要: 在实际应用中，我们可能会遇到把ListView放到ScrollView中的情况，在这种情况下，ListView的滑动属性与ScrollView的滑动出现冲突，从而ListView只显示一项。这里提供一种解决方案，就是设置ListView中每个Item的高度显示之，使他失去滑动的属性，从而适应Sc…阅读全文 在实际应用中，我们可能会遇到把ListView放到ScrollView中的情况，在这种情况下，ListView的滑动属性与ScrollView的滑动出现冲突，从而ListView只显示一项。这里提供一种解决方案，就是设置ListView中每个Item的高度显示之，使他失去滑动的属性，从而适应ScrollView的滑动。只需在填充数据之后设置即可： 1234567891011121314151617181920212223/** * 通过设置它的高度，让它“放弃”自身滚动属性，而放置到ScrollView中使用的。 * * @param lv */ private void setListViewHeight(ListView lv) &#123; ListAdapter la = lv.getAdapter(); if (null == la) &#123; return; &#125; // calculate height of all items. int h = 0; final int cnt = la.getCount(); for (int i = 0; i &lt; cnt; i++) &#123; View item = la.getView(i, null, lv); item.measure(0, 0); h += item.getMeasuredHeight(); &#125; // reset ListView height ViewGroup.LayoutParams lp = lv.getLayoutParams(); lp.height = h + (lv.getDividerHeight() * (cnt - 1)); lv.setLayoutParams(lp); &#125;","categories":[],"tags":[]},{"title":"安卓图片加载框架--Universal-Image-Loader","slug":"安卓图片加载框架--Universal-Image-Loader","date":"2015-09-18T09:05:00.000Z","updated":"2018-06-13T15:31:22.667Z","comments":true,"path":"2015/09/18/安卓图片加载框架--Universal-Image-Loader/","link":"","permalink":"https://lossingdawn.top/2015/09/18/安卓图片加载框架--Universal-Image-Loader/","excerpt":"摘要: 今天来介绍图片加载的框架Android-Universal-Image-Loader GITHUB上的下载路径为：https://github.com/nostra13/Android-Universal-Image-Loader 也可以自行百度下载。 首先来封装的一个类CacheTool…阅读全文","text":"摘要: 今天来介绍图片加载的框架Android-Universal-Image-Loader GITHUB上的下载路径为：https://github.com/nostra13/Android-Universal-Image-Loader 也可以自行百度下载。 首先来封装的一个类CacheTool…阅读全文 今天来介绍图片加载的框架Android-Universal-Image-Loader GITHUB上的下载路径为：https://github.com/nostra13/Android-Universal-Image-Loader 也可以自行百度下载。 首先来封装的一个类CacheTool ，由于其他加载图片的方法有点繁琐，所以这里仅封装了一个简单实用的加载方法： 1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125 import android.content.Context;import android.graphics.Bitmap;import android.graphics.Bitmap.CompressFormat;import android.net.Uri;import android.os.Environment;import android.widget.ImageView;import java.io.File;import com.ncct.app.R;import com.nostra13.universalimageloader.cache.disc.impl.UnlimitedDiscCache;import com.nostra13.universalimageloader.cache.disc.naming.Md5FileNameGenerator;import com.nostra13.universalimageloader.cache.memory.impl.UsingFreqLimitedMemoryCache;import com.nostra13.universalimageloader.core.DisplayImageOptions;import com.nostra13.universalimageloader.core.ImageLoader;import com.nostra13.universalimageloader.core.ImageLoaderConfiguration;import com.nostra13.universalimageloader.core.assist.ImageLoadingListener;import com.nostra13.universalimageloader.core.assist.QueueProcessingType;import com.nostra13.universalimageloader.core.download.BaseImageDownloader;/** * 图片加载框架 * * @author jiang * */public class CacheTool &#123; private static File cacheDir = Environment.getDataDirectory(); private static DisplayImageOptions options = new DisplayImageOptions.Builder().showStubImage(R.drawable.loading_img) .showImageForEmptyUri(R.drawable.loading_error).showImageOnFail(R.drawable.loading_error) .cacheInMemory(true).cacheOnDisc(true).bitmapConfig(Bitmap.Config.RGB_565).build(); private static ImageLoaderConfiguration config; public static void Init(Context context) &#123; config = new ImageLoaderConfiguration.Builder(context).memoryCacheExtraOptions(480, 800) // max // width, // max // height，即保存的每个缓存文件的最大长宽 .discCacheExtraOptions(480, 800, CompressFormat.JPEG, 75, null) // Can // slow // ImageLoader, // use // it // carefully // (Better // don't // use // it)/设置缓存的详细信息，最好不要设置这个 .threadPoolSize(3)// 线程池内加载的数量 .threadPriority(Thread.NORM_PRIORITY - 2).denyCacheImageMultipleSizesInMemory() .memoryCache(new UsingFreqLimitedMemoryCache(2 * 1024 * 1024)) // You // can // pass // your // own // memory // cache // implementation/你可以通过自己的内存缓存实现 .memoryCacheSize(2 * 1024 * 1024).discCacheSize(50 * 1024 * 1024) .discCacheFileNameGenerator(new Md5FileNameGenerator())// 将保存的时候的URI名称用MD5 // 加密 .tasksProcessingOrder(QueueProcessingType.LIFO).discCacheFileCount(100) // 缓存的文件数量 // .discCache(new UnlimitedDiscCache(cacheDir))// 自定义缓存路径 .defaultDisplayImageOptions(DisplayImageOptions.createSimple()) .imageDownloader(new BaseImageDownloader(context, 5 * 1000, 30 * 1000)) // connectTimeout // (5 // s), // readTimeout // (30 // s)超时时间 .writeDebugLogs() // Remove for release app .build();// 开始构建 // Initialize ImageLoader with configuration. ImageLoader.getInstance().init(config); &#125; /** * 加载图片并监听回调结果 * * @param iv * @param url * @param mImageLoadingListener */ public static void displayImg(ImageView iv, String url, ImageLoadingListener mImageLoadingListener) &#123; ImageLoader.getInstance().displayImage(url, iv, options, mImageLoadingListener); &#125; /** * 加载图片 * * @param iv * @param url */ public static void displayImg(ImageView iv, String url) &#123; ImageLoader.getInstance().displayImage(url, iv, options); &#125; /** * 清除内存 */ public static void clearMemoryCache() &#123; ImageLoader.getInstance().clearMemoryCache(); &#125; /** * 清除缓存 */ public static void clearDiskCache() &#123; ImageLoader.getInstance().clearDiscCache(); &#125; /** * 得到某个图片的缓存路径 * * @param imageUrl * @return */ public static String getImagePath(String imageUrl) &#123; return ImageLoader.getInstance().getDiscCache().get(imageUrl).getPath(); &#125;&#125; 封装好了，里面都有详细的介绍，这里介绍下上面的中的ImageLoadingListener 接口回调，按ctrl + 鼠标左键可以进入jar包里的java文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 /******************************************************************************* * Copyright 2011-2013 Sergey Tarasevich * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. *******************************************************************************/package com.nostra13.universalimageloader.core.assist;import android.graphics.Bitmap;import android.view.View;/** * Listener for image loading process.&lt;br /&gt; * You can use &#123;@link SimpleImageLoadingListener&#125; for implementing only needed methods. * * @author Sergey Tarasevich (nostra13[at]gmail[dot]com) * @see SimpleImageLoadingListener * @see FailReason * @since 1.0.0 */public interface ImageLoadingListener &#123; /** * Is called when image loading task was started * * @param imageUri Loading image URI * @param view View for image */ void onLoadingStarted(String imageUri, View view); /** * Is called when an error was occurred during image loading * * @param imageUri Loading image URI * @param view View for image. Can be &lt;b&gt;null&lt;/b&gt;. * @param failReason &#123;@linkplain FailReason The reason&#125; why image loading was failed */ void onLoadingFailed(String imageUri, View view, FailReason failReason); /** * Is called when image is loaded successfully (and displayed in View if one was specified) * * @param imageUri Loaded image URI * @param view View for image. Can be &lt;b&gt;null&lt;/b&gt;. * @param loadedImage Bitmap of loaded and decoded image */ void onLoadingComplete(String imageUri, View view, Bitmap loadedImage); /** * Is called when image loading task was cancelled because View for image was reused in newer task * * @param imageUri Loading image URI * @param view View for image. Can be &lt;b&gt;null&lt;/b&gt;. */ void onLoadingCancelled(String imageUri, View view);&#125; 从以上代码中我们可以了解到接口中我们可以监听到开始、失败、完成、取消的动作。 现在开始使用吧： 12345678910private ImageView My_Head; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.personcenter); My_Head = (ImageView) findViewById(R.id.My_Head); String Url = \"http://pic.nipic.com/2007-11-09/200711912453162_2.jpg\"; CacheTool.displayImg(My_Head , Url ); &#125; Mark一下，暂存一个直接通过URL获取bitmap的函数，未作内存处理。 1234567891011121314151617/** * 获取指定路径的图片 * * @param urlpath * @return * @throws Exception */ public Bitmap getImage(String urlpath) throws Exception &#123; URL url = new URL(urlpath); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(\"GET\"); conn.setConnectTimeout(5000); Bitmap bitmap = null; InputStream inputStream = conn.getInputStream(); bitmap = BitmapFactory.decodeStream(inputStream); return bitmap; &#125;","categories":[],"tags":[]},{"title":"移动应用图片的福音--七牛云存储","slug":"移动应用图片的福音--七牛云存储","date":"2015-09-18T08:35:00.000Z","updated":"2018-06-13T15:31:21.408Z","comments":true,"path":"2015/09/18/移动应用图片的福音--七牛云存储/","link":"","permalink":"https://lossingdawn.top/2015/09/18/移动应用图片的福音--七牛云存储/","excerpt":"摘要: 本篇来介绍移动应用图片存储的第三方，官方网址：http://www.qiniu.com/ 首先，在七牛上要注册开发者账号，需要认证身份证信息。认证完之后，我们来开始进行安卓端的开发。一、准备信息 进行图片的上传与下载，我们需要准备几个信息，首先是空间名，然后是域名，再者是密钥对。如下图：二、…阅读全文","text":"摘要: 本篇来介绍移动应用图片存储的第三方，官方网址：http://www.qiniu.com/ 首先，在七牛上要注册开发者账号，需要认证身份证信息。认证完之后，我们来开始进行安卓端的开发。一、准备信息 进行图片的上传与下载，我们需要准备几个信息，首先是空间名，然后是域名，再者是密钥对。如下图：二、…阅读全文 本篇来介绍移动应用图片存储的第三方，官方网址：http://www.qiniu.com/ 首先，在七牛上要注册开发者账号，需要认证身份证信息。认证完之后，我们来开始进行安卓端的开发。 一、准备信息 进行图片的上传与下载，我们需要准备几个信息，首先是空间名，然后是域名，再者是密钥对。如下图： 二、安卓端图片上传 首先我们需要导入JAR包，网址：http://developer.qiniu.com/docs/v6/sdk/android-sdk.html 现在来编写上传相关的程序： 123456789101112131415161718192021private volatile boolean isCancelled = false;// 取消标志 static String AccessKey =七牛上的公钥; static String SecretKey =七牛上的私钥; UploadManager uploadManager; /** *uploadManager有两种初始化方法，一种是默认配置，一种的自动逸配置 */ // 默认配置 uploadManager=new UploadManager(); //自定义配置 Configuration config= new Configuration.Builder().chunkSize(256 * 1024) // 分片上传时，每片的大小。 // 默认 // 256K .putThreshhold(512 * 1024) // 启用分片上传阀值。默认 512K .connectTimeout(10) // 链接超时。默认 10秒 .responseTimeout(60) // 服务器响应超时。默认 60秒 // .recorder(recorder) // recorder 分片上传时，已上传片记录器。默认 null // .recorder(recorder, keyGen) // keyGen // 分片上传时，生成标识符，用于片记录器区分是那个文件的上传记录 .build(); // 重用 uploadManager。一般地，只需要创建一个 uploadManager 对象 uploadManager = new UploadManager(config); 初始化配置搞定了，下面来进行上传操作： 1234567891011121314151617181920212223 String _uploadToken = getUploadToken(scope); uploadManager.put(SAVE_FILE_DIRECTORY, // 本地上传路径、文件、字符串 key, // 网站上的名字 _uploadToken, // 验证信息 new UpCompletionHandler() &#123; @Override public void complete(String key, ResponseInfo info, JSONObject response) &#123; Log.e(\"qiniu\", info.toString()); Log.i(\"是否成功\", String.valueOf(info.isOK())); &#125; &#125;, new UploadOptions(null, // 自定义变量，key必须以 x: 开始。 \"webp\", // 指定文件的mimeType。 false, // 是否验证上传文件。 new UpProgressHandler() &#123; // 上传进度回调。 public void progress(String key, double percent) &#123; Log.i(\"qiniu\", key + \": \" + percent); &#125; &#125;, new UpCancellationSignal() &#123; // 取消上传，当isCancelled()返回true时，不再执行更多上传。 public boolean isCancelled() &#123; return isCancelled; &#125; &#125;)); 在上传的操作中唯一需要我们头疼的就是_uploadToken，下面来介绍如何生成一个_uploadToken令牌信息： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public String getUploadToken(String scope) &#123; // 构造上传策略 JSONObject json = new JSONObject(); long dataline = System.currentTimeMillis() / 1000 + 3600; String uploadToken = null; try &#123; json.put(\"deadline\", dataline);// 有效时间为一个小时 json.put(\"scope\", scope);// 上传空间 String encodedPutPolicy = UrlSafeBase64.encodeToString(json.toString().getBytes()); byte[] sign = HmacSHA1Encrypt(encodedPutPolicy, SecretKey); String encodedSign = UrlSafeBase64.encodeToString(sign); uploadToken = AccessKey + ':' + encodedSign + ':' + encodedPutPolicy;// 登录信息token=公钥：加密的json信息：原始json信息 &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return uploadToken; &#125; /////////////// ************************************///////////////////////// /** * 使用 HMAC-SHA1 签名方法对对encryptText进行签名 * * @param encryptText * 被签名的字符串 * @param encryptKey * 密钥 * @return * @throws Exception */ private static final String MAC_NAME = \"HmacSHA1\"; private static final String ENCODING = \"UTF-8\"; private byte[] HmacSHA1Encrypt(String encryptText, String encryptKey) throws Exception &#123; byte[] data = encryptKey.getBytes(ENCODING); // 根据给定的字节数组构造一个密钥,第二参数指定一个密钥算法的名称 SecretKey secretKey = new SecretKeySpec(data, MAC_NAME); // 生成一个指定 Mac 算法 的 Mac 对象 Mac mac = Mac.getInstance(MAC_NAME); // 用给定密钥初始化 Mac 对象 mac.init(secretKey); byte[] text = encryptText.getBytes(ENCODING); // 完成 Mac 操作 return mac.doFinal(text); &#125; 好了现在我们就可以成功上传了。 三、编写其他操作 1、取消操作 123456/** * 点击取消按钮，让 UpCancellationSignal#isCancelled() 方法返回 true ，以停止上传 */ public void cancell() &#123; isCancelled = true; &#125; 2、删除操作 1234567891011121314151617181920212223242526272829303132333435363738/** * 删除指定空间、名称的资源 * * @param bucket 空间名 * @param fileName 文件名 * @return */ public boolean deleteFile(String bucket, String fileName) &#123; try &#123; String entryUrl = bucket + \":\" + fileName; String encodedEntryURI = UrlSafeBase64.encodeToString(entryUrl.getBytes()); String host = \"http://rs.qiniu.com\"; String path = \"/delete/\" + encodedEntryURI; String url = host + path; byte[] sign = HmacSHA1Encrypt(path + \"\\n\", SecretKey); String encodedSign = UrlSafeBase64.encodeToString(sign); String authorization = AccessKey + ':' + encodedSign; HttpClient httpClient = new DefaultHttpClient(); HttpPost mothod = new HttpPost(url); mothod.setHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); mothod.setHeader(\"Authorization\", \"QBox \" + authorization); // 连接超时时间 httpClient.getParams().setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 20000); // 读取超时时间 httpClient.getParams().setParameter(CoreConnectionPNames.SO_TIMEOUT, 20000); HttpResponse response = httpClient.execute(mothod); StatusLine statusLine = response.getStatusLine(); int statusCode = statusLine.getStatusCode(); if (statusCode == HttpStatus.SC_OK) &#123; Log.e(\"删除结果\", \"successful\"); return true; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; Log.e(\"删除结果\", \"false\"); return false; &#125; 好了，暂时就先到这里，虽然进行了一些封装，但是对自己的封装不很满意所以暂时不发了，以后封装完善了再发吧，这些已经足够新手理解了。下篇介绍获取网络图片并显示。主要用到目前最好的图片加载框架ImageLoad。","categories":[],"tags":[]},{"title":"（转）Android自定义控件","slug":"（转）android自定义控件","date":"2015-08-10T06:31:00.000Z","updated":"2018-06-13T15:31:21.408Z","comments":true,"path":"2015/08/10/（转）android自定义控件/","link":"","permalink":"https://lossingdawn.top/2015/08/10/（转）android自定义控件/","excerpt":"摘要: 原帖地址：http://my.oschina.net/wangjunhe/blog/99764创建新的控件：作为一个有创意的开发者，你经常会遇到安卓原生控件无法满足你的需求。为了优化你的界面和工作流程，安卓允许你去继承已经存在的控件或者实现你自己的控件。那么最好的方式去创建一个新的控件是什么？ 这主…阅读全文","text":"摘要: 原帖地址：http://my.oschina.net/wangjunhe/blog/99764创建新的控件：作为一个有创意的开发者，你经常会遇到安卓原生控件无法满足你的需求。为了优化你的界面和工作流程，安卓允许你去继承已经存在的控件或者实现你自己的控件。那么最好的方式去创建一个新的控件是什么？ 这主…阅读全文 原帖地址：http://my.oschina.net/wangjunhe/blog/99764 创建新的控件： 作为一个有创意的开发者，你经常会遇到安卓原生控件无法满足你的需求。 为了优化你的界面和工作流程，安卓允许你去继承已经存在的控件或者实现你自己的控件。 那么最好的方式去创建一个新的控件是什么？ 这主要取决你想要完成什么。 1.有些基本功能原生控件都能提供，所以这个时候你只需要继承并对控件进行扩展。通过重写它的事件，onDraw,但是始终都保持都父类方法的调用。 2.组合控件 就是通过合并几个控件的功能来生成一个控件。 3.完完整整创建一个新的控件。 1.修改存在的控件 例子： 123456789101112131415161718192021222324252627282930313233 public class MyTextView extends TextView &#123; public MyTextView(Context context, AttributeSet ats, int defStyle) &#123; super(context, ats, defStyle); &#125; public MyTextView(Context context) &#123; super(context); &#125; public MyTextView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public void onDraw(Canvas canvas) &#123; // 在画布上画文本之下的内容 // 保证默认的文本渲染 super.onDraw(canvas); // 在画布上画文本之上的内容 &#125; @Override public boolean onKeyDown(int keyCode, KeyEvent keyEvent) &#123; // 写自己的控制 // 保持父类默认的控制 return super.onKeyDown(keyCode, keyEvent); &#125;&#125; 2.组合控件 1.最简单的方式，是定义了XML布局文件，然后用include实现重用。（。。。这也算啊。。。） 2.去合并一个控件 通常你自定义的控件需要继承一个ViewGroup（通常就是Layout），就像： 123456789 public class MyCompoundView extends LinearLayout &#123; public MyCompoundView(Context context) &#123; super(context); &#125; public MyCompoundView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125;&#125; 就像activity，比较好的设计一个混合的控件UI布局是使用一个外部的layout资源。 这里我们模拟定义一个： 1234567891011121314151617&lt;?xml version=”1.0” encoding=”utf-8”?&gt; &lt;LinearLayout xmlns:android=”http://schemas.android.com/apk/res/android” android:orientation=”vertical” android:layout_width=”match_parent” android:layout_height=”wrap_content”&gt; &lt;EditText android:id=”@+id/editText” android:layout_width=”match_parent” android:layout_height=”wrap_content” /&gt; &lt;Button android:id=”@+id/clearButton” android:layout_width=”match_parent” android:layout_height=”wrap_content” android:text=”Clear” /&gt; &lt;/LinearLayout&gt; ** 然后在构造函数初始化的时候：** 123456789101112131415161718192021222324 public class ClearableEditText extends LinearLayout &#123; EditText editText; Button clearButton; public ClearableEditText(Context context) &#123; super(context); // Inflate the view from the layout resource. String infService = Context.LAYOUT_INFLATER_SERVICE; LayoutInflater li; li = (LayoutInflater) getContext().getSystemService(infService); /*这句很关键，解析反射资源文件，然后将布局附加到当前的控件，也就是this*/ li.inflate(R.layout.clearable_edit_text, this, true); /* 因为反射成功后的布局已经附加上了，那么直接可以findViewById*/ editText = (EditText) findViewById(R.id.editText); clearButton = (Button) findViewById(R.id.clearButton); // 下面自定义的方法就是为控件注册监听，不解释了 hookupButton(); &#125;&#125; 使用：在activity_main.xml &lt;com.example.customview.MyCompoundView android:layout_width=“match_parent” android:layout_height=“wrap_content” /&gt; 3. 完完全全自定义控件 通常是继承View或者SurfaceView ，View类提供一个Canvas（画布）和一系列的画的方法，还有Paint（画笔）。使用它们去创建一个自定义的UI。你可以重写事件，包括屏幕接触或者按键按下等等，用来提供与用户交互。 1.如果你不需要快速重画和3D图像的效果，那么让View作为父类提供一个轻量级的解决方案。 2.如若不然，就需要使用SurfaceView作为父类，这样你就可以提供一个后台线程去画和使用OPENGL去实现你的图像。这个就相对重量级了，如果你的视图需要经常更新，然后由需要显示比较复杂的图像信息（尤其是在游戏和3D可视化），SurfaceView将是更好的选择。 在这里我们讨论前者，后者后期再讨论。 一般你需要重写2个方法： 1.onMeasure 什么是onMeasure? 下面转载一段文章： View在屏幕上显示出来要先经过measure（计算）和layout（布局）. 1、什么时候调用onMeasure方法？ 当控件的父元素正要放置该控件时调用.父元素会问子控件一个问题，“你想要用多大地方啊？”，然后传入两个参数——widthMeasureSpec和heightMeasureSpec. 这两个参数指明控件可获得的空间以及关于这个空间描述的元数据. 更好的方法是你传递View的高度和宽度到setMeasuredDimension方法里,这样可以直接告诉父控件，需要多大地方放置子控件. widthMeasureSpec和heightMeasureSpec这2个参数都是整形是出于效率的考虑，所以经常要做的就是对其解码=&gt; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); 依据specMode的值，（MeasureSpec有3种模式分别是UNSPECIFIED, EXACTLY和AT_MOST） 如果是AT_MOST，specSize 代表的是最大可获得的空间； 如果是EXACTLY，specSize 代表的是精确的尺寸； 如果是UNSPECIFIED，对于控件尺寸来说，没有任何参考意义。 2、那么这些模式和我们平时设置的layout参数fill_parent, wrap_content有什么关系呢？ 经过代码测试就知道，当我们设置width或height为fill_parent时，容器在布局时调用子 view的measure方法传入的模式是EXACTLY，因为子view会占据剩余容器的空间，所以它大小是确定的。 而当设置为 wrap_content时，容器传进去的是AT_MOST, 表示子view的大小最多是多少，这样子view会根据这个上限来设置自己的尺寸。当子view的大小设置为精确值时，容器传入的是EXACTLY, 而MeasureSpec的UNSPECIFIED模式表示你没有指定大小。 View的onMeasure方法默认行为是当模式为UNSPECIFIED时，设置尺寸为mMinWidth(通常为0)或者背景drawable的最小尺寸，当模式为EXACTLY或者AT_MOST时，尺寸设置为传入的MeasureSpec的大小。 有个观念需要纠正的是，fill_parent应该是子view会占据剩下容器的空间，而不会覆盖前面已布局好的其他view空间，当然后面布局子 view就没有空间给分配了，所以fill_parent属性对布局顺序很重要。以前所想的是把所有容器的空间都占满了，难怪google在2.2版本里 把fill_parent的名字改为match_parent. 在两种情况下，你必须绝对的处理这些限制。在一些情况下，它可能会返回超出这些限制的尺寸，在这种情况下，你可以让父元素选择如何对待超出的View，使用裁剪还是滚动等技术。 接下来的框架代码给出了处理View测量的典型实现： 12345678910111213141516171819202122232425262728293031@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int measuredHeight = measureHeight(heightMeasureSpec); int measuredWidth = measureWidth(widthMeasureSpec); setMeasuredDimension(measuredHeight, measuredWidth); // 记住这句可不能省。 &#125; private int measureHeight(int measureSpec) &#123; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); // Default size if no limits are specified. int result = 500; if (specMode == MeasureSpec.AT_MOST) &#123; // Calculate the ideal size of your // control within this maximum size. // If your control fills the available // space return the outer bound. result = specSize; &#125; else if (specMode == MeasureSpec.EXACTLY) &#123; // If your control can fit within these bounds return that value. result = specSize; &#125; return result; &#125; private int measureWidth(int measureSpec) &#123; // 代码基本类似measureHeight &#125; 总结： 通过 ** int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec);** 这2个值，然后计算自己想要占有的宽和高。 2.onDraw 这个不解释了。（后期会细说canvas和paint）","categories":[],"tags":[]},{"title":"Android值类型转换","slug":"android值类型转换","date":"2015-06-04T08:58:00.000Z","updated":"2018-06-13T15:31:22.668Z","comments":true,"path":"2015/06/04/android值类型转换/","link":"","permalink":"https://lossingdawn.top/2015/06/04/android值类型转换/","excerpt":"摘要: 各种数字类型转换成字符串型：Strings=String.valueOf(value);//其中value为任意一种数字类型。字符串型转换成各种数字类型：Strings=“169”;byteb=Byte.parseByte(s);shortt=Short.parseShort(s);inti=Int…阅读全文","text":"摘要: 各种数字类型转换成字符串型：Strings=String.valueOf(value);//其中value为任意一种数字类型。字符串型转换成各种数字类型：Strings=“169”;byteb=Byte.parseByte(s);shortt=Short.parseShort(s);inti=Int…阅读全文 各种数字类型转换成字符串型： String s = String.valueOf( value); // 其中 value 为任意一种数字类型。 字符串型转换成各种数字类型： String s = “169”; byte b = Byte.parseByte( s ); short t = Short.parseShort( s ); int i = Integer.parseInt( s ); long l = Long.parseLong( s ); Float f = Float.parseFloat( s ); Double d = Double.parseDouble( s );","categories":[],"tags":[]},{"title":"【Android UI】顶部or底部菜单的循环滑动效果一","slug":"【Android UI】顶部or底部菜单的循环滑动效果一","date":"2015-04-29T23:45:00.000Z","updated":"2018-06-13T15:31:22.668Z","comments":true,"path":"2015/04/30/【Android UI】顶部or底部菜单的循环滑动效果一/","link":"","permalink":"https://lossingdawn.top/2015/04/30/【Android UI】顶部or底部菜单的循环滑动效果一/","excerpt":"摘要: 实现了分页的滑动效果，做的demo流畅运行注：貌似支持的样式（控件）有一定的限制，我试过短信的listview页面，暂无法实现滑动效果java文件:MainActivity.java、Activity1.java、Activity2.java、Activity3.java、Activity4.jav…阅读全文","text":"摘要: 实现了分页的滑动效果，做的demo流畅运行注：貌似支持的样式（控件）有一定的限制，我试过短信的listview页面，暂无法实现滑动效果java文件:MainActivity.java、Activity1.java、Activity2.java、Activity3.java、Activity4.jav…阅读全文 实现了分页的滑动效果，做的demo流畅运行 注：貌似支持的样式（控件）有一定的限制，我试过短信的listview页面，暂无法实现滑动效果 java文件:MainActivity.java、Activity1.java、Activity2.java、Activity3.java、Activity4.java MainActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181 package com.example.tabhostmove;import android.app.Activity;import android.app.TabActivity;import android.content.Intent;import android.os.Bundle;import android.util.Log;import android.view.GestureDetector;import android.view.Menu;import android.view.MenuItem;import android.view.MotionEvent;import android.widget.TabHost;import android.widget.TabHost.TabSpec;public class MainActivity extends TabActivity &#123; private TabHost tabHost; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); init(); &#125; private void init() &#123; // TODO Auto-generated method stub tabHost = getTabHost(); // 页面1 TabSpec spec1 = tabHost.newTabSpec(\"1\"); spec1.setIndicator(\"1\", getResources().getDrawable(R.drawable.ic_launcher)); Intent intent1 = new Intent(this, Activity1.class); spec1.setContent(intent1); // 页面2 TabSpec spec2 = tabHost.newTabSpec(\"2\"); spec2.setIndicator(\"2\", getResources().getDrawable(R.drawable.ic_launcher)); Intent intent2 = new Intent(this, Activity2.class); spec2.setContent(intent2); // 页面3 TabSpec spec3 = tabHost.newTabSpec(\"3\"); spec3.setIndicator(\"3\", getResources().getDrawable(R.drawable.ic_launcher)); Intent intent3 = new Intent(this, Activity3.class); spec3.setContent(intent3); // 页面4 TabSpec spec4 = tabHost.newTabSpec(\"4\"); spec4.setIndicator(\"4\", getResources().getDrawable(R.drawable.ic_launcher)); Intent intent4 = new Intent(this, Activity4.class); spec4.setContent(intent4); tabHost.addTab(spec1); tabHost.addTab(spec2); tabHost.addTab(spec3); tabHost.addTab(spec4); &#125; private GestureDetector detector = new GestureDetector(new GestureDetector.SimpleOnGestureListener() &#123; @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123; if ((e2.getRawX() - e1.getRawX()) &gt; 80) &#123; showNext(); return true; &#125; if ((e1.getRawX() - e2.getRawX()) &gt; 80) &#123; showPre(); return true; &#125; return super.onFling(e1, e2, velocityX, velocityY); &#125; &#125;); @Override public boolean onTouchEvent(MotionEvent event) &#123; detector.onTouchEvent(event); return super.onTouchEvent(event); &#125; /** * 当前页面索引 */ int i = 0; /** * 显示下一个页面 */ protected void showNext() &#123; // 三元表达式控制3个页面的循环. //tabHost.setCurrentTab(i = i == 3 ? i = 0 : ++i); //Log.i(\"kennet\", i + \"\"); //四个页面的下一个循环 switch(i) &#123; case 0: i++; tabHost.setCurrentTab(i); break; case 1: i++; tabHost.setCurrentTab(i); break; case 2: i++; tabHost.setCurrentTab(i); break; case 3: i=0; tabHost.setCurrentTab(i); break; &#125; &#125; /** * 显示前一个页面 */ protected void showPre() &#123; // 三元表达式控制3个页面的循环. //tabHost.setCurrentTab(i = i == 0 ? i = 3 : --i); //四个页面的上一个循环 switch(i) &#123; case 0: i=3; tabHost.setCurrentTab(i); break; case 1: i--; tabHost.setCurrentTab(i); break; case 2: i--; tabHost.setCurrentTab(i); break; case 3: i--; tabHost.setCurrentTab(i); break; &#125; &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.main, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); if (id == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(item); &#125;&#125; xml布局文件：activity_main.xml、activit1.xml、activit2.xml、activit3.xml、activit4.xml activity_main.xml 12345678910111213141516171819202122232425 &lt;TabHost xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@android:id/tabhost\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;LinearLayout android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:orientation=\"vertical\" &gt; &lt;TabWidget android:id=\"@android:id/tabs\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" /&gt; &lt;FrameLayout android:id=\"@android:id/tabcontent\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" &gt; &lt;/FrameLayout&gt; &lt;/LinearLayout&gt;&lt;/TabHost&gt; 注：activity1、2、3、4是测试的页面，随便建几个即可，别忘了在AndroidManifest.xml里注册页面的活动 实现效果：","categories":[],"tags":[]},{"title":"【Android UI】侧滑栏的使用（HorizontalScrollView控件的使用）","slug":"【Android UI】侧滑栏的使用（HorizontalScrollView控件的使用）","date":"2015-04-29T08:12:00.000Z","updated":"2018-06-13T15:31:22.668Z","comments":true,"path":"2015/04/29/【Android UI】侧滑栏的使用（HorizontalScrollView控件的使用）/","link":"","permalink":"https://lossingdawn.top/2015/04/29/【Android UI】侧滑栏的使用（HorizontalScrollView控件的使用）/","excerpt":"摘要: 主要的用到的控件：HorizontalScrollView主要的功能：把几张图片解析成一张图片，在一个容器中呈现。布局文件xmlside_bar_scollview.xml//显示view的容器 home.xml//显示的主页面 m…阅读全文","text":"摘要: 主要的用到的控件：HorizontalScrollView主要的功能：把几张图片解析成一张图片，在一个容器中呈现。布局文件xmlside_bar_scollview.xml//显示view的容器 home.xml//显示的主页面 m…阅读全文 主要的用到的控件：HorizontalScrollView 主要的功能：把几张图片解析成一张图片，在一个容器中呈现。 布局文件xml side_bar_scollview.xml//显示view的容器 123456789101112131415161718192021 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;HorizontalScrollView android:id=\"@+id/MyScrollView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;LinearLayout android:id=\"@+id/ll_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizontal\" &gt; &lt;/LinearLayout&gt; &lt;/HorizontalScrollView&gt;&lt;/LinearLayout&gt; home.xml//显示的主页面 1234567891011121314 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:background=\"@drawable/home_bg\"&gt; &lt;TextView android:id=\"@+id/textView1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"主页\" /&gt;&lt;/LinearLayout&gt; menu.xml//显示的菜单页面 12345678910111213 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@drawable/menu_bg\"&gt; &lt;TextView android:id=\"@+id/textView1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"菜单\" /&gt;&lt;/FrameLayout&gt; MainActivity.java//主活动 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 package com.example.side_bar_scrollview;import android.annotation.SuppressLint;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.view.ViewTreeObserver.OnGlobalLayoutListener;import android.widget.HorizontalScrollView;import android.widget.LinearLayout;public class MainActivity extends Activity &#123; private HorizontalScrollView scrollview; private LinearLayout view_layout; private int width; private int height; private View home_view; private View menu_view; private float rate=0.4f; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //关联界面ID setContentView(R.layout.side_bar_scollview); //关联控件ID scrollview=(HorizontalScrollView) findViewById(R.id.MyScrollView); view_layout=(LinearLayout) findViewById(R.id.ll_layout); //监听布局 MyLayoutListener(); //隐藏滚动条 scrollview.setHorizontalScrollBarEnabled(false); &#125; /** * 监听布局的变化 * 1.getViewTreeObserver --- view事件的观察者 * 2.addOnGlobalLayoutListener * 当在一个视图树中全局布局发生改变或者视图树中的某个视图的可视状态发生改变时， * 所要调用的回调函数的接口类 * */ private void MyLayoutListener()&#123; scrollview.getViewTreeObserver().addOnGlobalLayoutListener( new OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; // TODO Auto-generated method stub //移除之前已经注册的全局布局的回调函数，使图片不会循环连在一起 view_layout.getViewTreeObserver() .removeOnGlobalLayoutListener(this); //获取最后一次调用measure()测量得到的scrollview的宽和高 height = scrollview.getMeasuredHeight(); width = scrollview.getMeasuredWidth(); //解析主页和菜单的布局 home_view=getLayoutInflater().inflate(R.layout.home, null); menu_view=getLayoutInflater().inflate(R.layout.menu, null); //添加view到view_layout view_layout.addView(menu_view, (int)(width*rate), height); view_layout.addView(home_view, width, height); &#125; &#125;); &#125;&#125; 效果图：","categories":[],"tags":[]},{"title":"Android问题解决","slug":"Android问题解决","date":"2015-04-26T11:26:00.000Z","updated":"2018-06-13T15:31:21.407Z","comments":true,"path":"2015/04/26/Android问题解决/","link":"","permalink":"https://lossingdawn.top/2015/04/26/Android问题解决/","excerpt":"摘要: 1、clean之后R文件消失 clean之后R文件消失是因为布局的XML文件存在错误，无法编译你的资源文件，所以无法自动生成R文件，在Problem、LogCat等界面查看错误的原因，把错误改正即可； 此外还有可能是引用问题，查看开头的import是否错误的引用了android的组件，把他删掉，…阅读全文","text":"摘要: 1、clean之后R文件消失 clean之后R文件消失是因为布局的XML文件存在错误，无法编译你的资源文件，所以无法自动生成R文件，在Problem、LogCat等界面查看错误的原因，把错误改正即可； 此外还有可能是引用问题，查看开头的import是否错误的引用了android的组件，把他删掉，…阅读全文 1、clean之后R文件消失 clean之后R文件消失是因为布局的XML文件存在错误，无法编译你的资源文件，所以无法自动生成R文件，在Problem、LogCat等界面查看错误的原因，把错误改正即可； 此外还有可能是引用问题，查看开头的import是否错误的引用了android的组件，把他删掉，重新引用具体包的路径。","categories":[],"tags":[]},{"title":"Uses-Permission权限列表","slug":"uses-permission权限列表","date":"2015-04-08T03:55:00.000Z","updated":"2018-06-13T15:31:21.408Z","comments":true,"path":"2015/04/08/uses-permission权限列表/","link":"","permalink":"https://lossingdawn.top/2015/04/08/uses-permission权限列表/","excerpt":"摘要: android.permission.ACCESS_CHECKIN_PROPERTIES允许读写访问”properties”表在checkin数据库中，改值可以修改上传android.permission.ACCESS_COARSE_LOCATION允许一个程序访问CellID或WiFi来获取粗略的…阅读全文","text":"摘要: android.permission.ACCESS_CHECKIN_PROPERTIES允许读写访问”properties”表在checkin数据库中，改值可以修改上传android.permission.ACCESS_COARSE_LOCATION允许一个程序访问CellID或WiFi来获取粗略的…阅读全文 android.permission.ACCESS_CHECKIN_PROPERTIES 允许读写访问”properties”表在checkin数据库中，改值可以修改上传 android.permission.ACCESS_COARSE_LOCATION 允许一个程序访问CellID或WiFi来获取粗略的位置 android.permission.ACCESS_FINE_LOCATION 允许一个程序访问精良位置(如GPS) android.permission.ACCESS_LOCATION_EXTRA_COMMANDS 允许应用程序访问额外的位置提供命令 android.permission.ACCESS_MOCK_LOCATION 允许程序创建模拟位置用于测试 android.permission.ACCESS_NETWORK_STATE 允许程序访问有关的网络信息 android.permission.ACCESS_SURFACE_FLINGER 允许程序使用SurfaceFlinger底层特性 android.permission.ACCESS_WIFI_STATE 允许程序访问Wi-Fi网络状态信息 android.permission.ACCOUNT_MANAGER 允许一个应用程序启动账户认证，该权限只能系统去设置 android.permission.AUTHENTICATE_ACCOUNTS 允许应用程序的验证账户扮演一个账户管理者 android.permission.BATTERY_STATS 允许程序更新手机电池统计信 android.permission.BIND_APPWIDGET 许应用告诉AppWidget哪个应用能够访问该AppWidget的数据 android.permission.BIND_DEVICE_ADMIN 必须通过关机接收者的请求，来确保只有系统能够与之交互 android.permission.BIND_INPUT_METHOD 必须通过InputMethodService的请求，来确保只有系统能够与之绑定 android.permission.BIND_WALLPAPER 必须通过WallpaperService的请求，来确保只有系统能够与之绑定 android.permission.BLUETOOTH 允许程序连接到已配对的蓝牙设备 android.permission.BLUETOOTH_ADMIN 允许程序发现和配对蓝牙设备 android.permission.BRICK 请求能够禁用设备(非常危险) android.permission.BROADCAST_PACKAGE_REMOVED 允许应用发出一个程序包被移除的广播消息 android.permission.BROADCAST_SMS 允许应用发出一个收到短信的消息 android.permission.BROADCAST_STICKY 允许应用发出一个与intent相连的消息 android.permission.BROADCAST_WAP_PUSH 允许应用发出一个收到WAP PUSH的广播消息 android.permission.CALL_PHONE 允许一个程序初始化一个电话拨号，不需通过拨号用户界面需要用户确认 android.permission.CALL_PRIVILEGED 允许一个程序拨打任何号码，包含紧急号码无需通过拨号用户界面需要用户确认 android.permission.CAMERA 请求访问使用照相设备 android.permission.CHANGE_COMPONENT_ENABLED_STATE 允许一个程序是否改变一个组件或其他的启用或禁用 android.permission.CHANGE_CONFIGURATION 允许一个程序修改当前设置，如本地化 android.permission.CHANGE_NETWORK_STATE 允许程序改变网络连接状态 android.permission.CHANGE_WIFI_STATE 允许程序改变Wi-Fi连接状态 android.permission.CLEAR_APP_CACHE 允许一个程序在设备中清除所有安装的程序的缓存 android.permission.CLEAR_APP_USER_DATA 允许一个程序清除用户数据 android.permission.CONTROL_LOCATION_UPDATES 允许启用禁止位置更新提示从无线模块 android.permission.DELETE_CACHE_FILES 允许程序删除缓存文件 android.permission.DELETE_PACKAGES 允许一个程序删除包 android.permission.DEVICE_POWER 允许访问底层电源管理 android.permission.DIAGNOSTIC 允许程序RW诊断资源 android.permission.DISABLE_KEYGUARD 允许程序禁用键盘锁 android.permission.DUMP 允许程序返回状态抓取信息从系统服务 android.permission.EXPAND_STATUS_BAR 允许一个程序扩展收缩在状态栏,android开发网提示应该是一个类似Windows Mobile中的托盘程序 android.permission.FACTORY_TEST 作为一个工厂测试程序，运行在root用户 android.permission.FLASHLIGHT 允许访问闪光灯,其中HTC Dream不包含闪光灯 android.permission.FORCE_BACK 允许应用强制执行返回操作而不论是不是最终的activity android.permission.GET_ACCOUNTS 允许访问在Accounts Service中的一个帐户列表 android.permission.GET_PACKAGE_SIZE 允许一个程序获取任何package占用空间容量 android.permission.GET_TASKS 允许一个程序获取信息有关当前或最近运行的任务，一个缩略的任务状态，是否活动等等 android.permission.GLOBAL_SEARCH 可以被内容提供者用来允许使用全程搜索他们的数据 android.permission.HARDWARE_TEST 允许访问硬件 android.permission.INJECT_EVENTS 允许一个程序截获用户事件如按键、触摸、轨迹球等等到一个时间流 android.permission.INSTALL_PACKAGES 允许一个程序安装packages android.permission.INTERNAL_SYSTEM_WINDOW 允许打开窗口使用系统用户界面 android.permission.INTERNET 允许程序打开网络sockets android.permission.KILL_BACKGROUND_PROCESSES 允许应用去呼叫killBackgroundProcesses方法 android.permission.MANAGE_ACCOUNTS 允许程序去管理账户列表(在账户管理者中) android.permission.MANAGE_APP_TOKENS 允许程序管理(创建、催后、 z- order默认向z轴推移)程序引用在窗口管理器中 android.permission.MASTER_CLEAR 目前还没有明确的解释 android.permission.MODIFY_AUDIO_SETTINGS 允许程序修改全局音频设置 android.permission.MODIFY_PHONE_STATE 允许修改话机状态，如电源，人机接口等 android.permission.MODIFY_FORMAT_FILESYSTEMS 允许格式化可移除的存储仓库的文件系统 android.permission.MOUNT_UNMOUNT_FILESYSTEMS 允许挂载和反挂载文件系统可移动存储 android.permission.PERSISTENT_ACTIVITY 允许一个程序设置他的activities显示 android.permission.PROCESS_OUTGOING_CALLS 允许程序监视、修改有关播出电话 android.permission.READ_CALENDAR 允许程序读取用户日历数据 android.permission.READ_CONTACTS 允许程序读取用户联系人数据 android.permission.READ_FRAME_BUFFER 允许程序屏幕波或和更多常规的访问帧缓冲数据 android.permission.READ_HISTORY_BOOKMARKS 允许应用去读取(非写)用户浏览历史和书签 android.permission.READ_INPUT_STATE 允许程序返回当前按键状态 android.permission.READ_LOGS 允许程序读取底层系统日志文件 android.permission.READ_OWNER_DATA 允许程序读取所有者数据 android.permission.READ_PHONE_STATE 允许读取电话的状态 android.permission.READ_SMS 允许程序读取短信息(Allows an application to read SMS messages.) android.permission.READ_SYNC_SETTINGS 允许程序读取同步设置 android.permission.READ_SYNC_STATS 允许程序读取同步状态 android.permission.REBOOT 请求能够重新启动设备 android.permission.RECEIVE_BOOT_COMPLETED 允许一个程序接收到 ACTION_BOOT_COMPLETED广播在系统完成启动 android.permission.RECEIVE_MMS 允许一个程序监控将收到MMS彩信,记录或处理 android.permission.RECEIVE_SMS 允许程序监控一个将收到短信息，记录或处理 android.permission.RECEIVE_WAP_PUSH 允许程序监控将收到WAP PUSH信息 android.permission.RECORD_AUDIO 允许程序录制音频 android.permission.REORDER_TASKS 允许程序改变Z轴排列任务 android.permission.RESTART_PACKAGES 允许程序重新启动其他程序(此值已废弃使用) android.permission.SEND_SMS 允许程序发送SMS短信 android.permission.SET_ACTIVITY_WATCHER 允许程序监控或控制activities已经启动全局系统中 android.permission.SET_ALWAYS_FINISH 允许程序控制是否活动间接完成在处于后台时 android.permission.SET_ANIMATION_SCALE 修改全局信息比例 android.permission.SET_DEBUG_APP 配置一个程序用于调试 android.permission.SET_ORIENTATION 允许底层访问设置屏幕方向和实际旋转 android.permission.SET_PREFERRED_APPLICATIONS 允许一个程序修改列表参数PackageManager.addPackageToPreferred()和PackageManager.removePackageFromPreferred()方法 android.permission.SET_PROCESS_LIMIT 允许设置最大的运行进程数量 android.permission.SET_TIME 允许应用设置系统时间 android.permission.SET_TIME_ZONE 允许程序设置系统时区时间 android.permission.SET_WALLPAPER 允许程序设置壁纸 android.permission.SET_WALLPAPER_HINTS 允许程序设置壁纸hits android.permission.SIGNAL_PERSISTENT_PROCESSES 允许程序请求发送信号到所有显示的进程中 android.permission.STATUS_BAR 允许程序打开、关闭或禁用状态栏及图标 android.permission.SUBSCRIBED_FEEDS_READ 允许一个程序访问订阅RSS Feed内容提供 android.permission.SUBSCRIBED_FEEDS_WRITE 系统暂时保留改设置, android.permission.SYSTEM_ALERT_WINDOW 允许一个程序打开窗口使用 TYPE_SYSTEM_ALERT，显示在其他所有程序的顶层 android.permission.UPDATE_DEVICE_STATS 允许应用更新设备资料信息 android.permission.USE_CREDENTIALS 允许应用从管理器得到授权请求 android.permission.VIBRATE 允许访问振动设备 android.permission.WAKE_LOCK 允许使用PowerManager的 WakeLocks保持进程在休眠时从屏幕消失 android.permission.WRITE_APN_SETTINGS 允许程序写入API设置 android.permission.WRITE_CALENDAR 允许一个程序写入但不读取用户日历数据 android.permission.WRITE_CONTACTS 允许程序写入但不读取用户联系人数据 android.permission.WRITE_EXTERNAL_STORAGE 允许应用写（非读）用户的外部存储器 android.permission.WRITE_GSERVICES 允许程序修改Google服务地图 android.permission.WRITE_HISTORY_BOOKMARKS 允许应用写（非读）用户的浏览器历史和书签 android.permission.WRITE_OWNER_DATA 允许一个程序写入但不读取所有者数据 android.permission.WRITE_SECURE_SETTINGS 允许应用写或读当前系统设置 android.permission.WRITE_SETTINGS 允许程序读取或写入系统设置 android.permission.WRITE_SMS 允许程序写短信 android.permission.WRITE_SYNC_SETTINGS 允许程序写入同步设置","categories":[],"tags":[]},{"title":"delegate委托的例子，实现对Form中控件的更新","slug":"delegate委托的例子，实现对Form中控件的更新","date":"2014-12-05T07:44:00.000Z","updated":"2018-06-13T15:31:22.668Z","comments":true,"path":"2014/12/05/delegate委托的例子，实现对Form中控件的更新/","link":"","permalink":"https://lossingdawn.top/2014/12/05/delegate委托的例子，实现对Form中控件的更新/","excerpt":"摘要: using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;u…阅读全文","text":"摘要: using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;u…阅读全文 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading;using System.Threading.Tasks;using System.Windows.Forms;namespace Invoketest&#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); &#125; public void UpdateForm(string param1, string parm2) &#123; this.textBox1.Text = param1 + parm2; &#125; public delegate void UpdateForm_dl(string str1, string str2); private void Calldelegate() &#123; /*在Windows窗体应用程序中使用this.Invoke 在WPF应用程序中使用this.Dispatcher.Invoke*/ this.BeginInvoke(new UpdateForm_dl(UpdateForm), new object[] &#123; \"我是文本框\", \"haha\" &#125;); //this.Dispatcher.BeginInvoke(new UpdateForm_dl(UpdateForm), new object[] &#123; \"我是文本框\", \"haha\" &#125;); &#125; public void DoWork() &#123; Calldelegate(); &#125; private void Form1_Load(object sender, EventArgs e) &#123; &#125; private void button1_Click(object sender, EventArgs e) &#123; Thread thread = new Thread(new ThreadStart(DoWork)); thread.Start(); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"C#中用WMI实现对驱动的查询","slug":"C#中用WMI实现对驱动的查询","date":"2014-11-26T08:00:00.000Z","updated":"2018-06-13T15:31:21.408Z","comments":true,"path":"2014/11/26/C#中用WMI实现对驱动的查询/","link":"","permalink":"https://lossingdawn.top/2014/11/26/C#中用WMI实现对驱动的查询/","excerpt":"摘要: using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Manage…阅读全文","text":"摘要: using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Manage…阅读全文 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194 using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Management;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace WMI_驱动&#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); &#125; private void button1_Click(object sender, EventArgs e) &#123; listView1.Items.Clear(); //SelectQuery selectQuery = new SelectQuery(\"select * from win32_logicaldisk\");//硬盘盘符 SelectQuery selectQuery = new SelectQuery(\"select * from Win32_DiskDrive\");//硬盘序列号 ManagementObjectSearcher search = new ManagementObjectSearcher(selectQuery); foreach (ManagementObject Driver in search.Get()) &#123; ListViewItem lvi = new ListViewItem(new string[] &#123; Driver[\"Name\"].ToString(), Driver[\"Description\"].ToString() &#125;, -1); listView1.Items.Add(lvi); &#125; &#125; private void button2_Click(object sender, EventArgs e) &#123; listView1.Items.Clear(); SelectQuery selectQuery = new SelectQuery(\"select * from Win32_SystemDriver\");//驱动程序 ManagementObjectSearcher search = new ManagementObjectSearcher(selectQuery); foreach (ManagementObject Driver in search.Get()) &#123; ListViewItem lvi = new ListViewItem(new string[] &#123; Driver[\"Name\"].ToString(), Driver[\"Description\"].ToString() &#125;, -1); listView1.Items.Add(lvi); &#125; &#125; private void button3_Click(object sender, EventArgs e) &#123; listView1.Items.Clear(); SelectQuery selectQuery = new SelectQuery(\"select * from Win32_USBController\");//USB控制器 ManagementObjectSearcher search = new ManagementObjectSearcher(selectQuery); foreach (ManagementObject Driver in search.Get()) &#123; ListViewItem lvi = new ListViewItem(new string[] &#123; Driver[\"Name\"].ToString(), Driver[\"Description\"].ToString() &#125;, -1); //ListViewItem lvi = new ListViewItem(new string[] &#123; Driver[\"Name\"].ToString(),\"\" &#125;,-1); listView1.Items.Add(lvi); &#125; SelectQuery selectQuery2 = new SelectQuery(\"select * from Win32_USBHub\");//USB集线器 ManagementObjectSearcher search2 = new ManagementObjectSearcher(selectQuery2); foreach (ManagementObject Driver in search2.Get()) &#123; ListViewItem lvi = new ListViewItem(new string[] &#123; Driver[\"Name\"].ToString(), Driver[\"Description\"].ToString() &#125;, -1); //ListViewItem lvi = new ListViewItem(new string[] &#123; Driver[\"Name\"].ToString(),\"\" &#125;,-1); listView1.Items.Add(lvi); &#125; &#125; private void Form1_Load(object sender, EventArgs e) &#123; listView1.Columns.Clear();//清空列记录 ColumnHeader cZh = new ColumnHeader();//创建一个列 cZh.Text = \"名称\";//列名 cZh.Width = 300; ColumnHeader cCh = new ColumnHeader(); cCh.Text = \"描述\"; cCh.Width = 600; listView1.Columns.AddRange(new ColumnHeader[] &#123; cZh, cCh &#125;);//将这两列加入listView1 listView1.View = View.Details;//列的显示模式 &#125; private void button4_Click(object sender, EventArgs e) &#123; listView1.Items.Clear(); SelectQuery selectQuery = new SelectQuery(\"select * from Win32_Printer \");//打印机 ManagementObjectSearcher search = new ManagementObjectSearcher(selectQuery); foreach (ManagementObject Driver in search.Get()) &#123; ListViewItem lvi = new ListViewItem(new string[] &#123; Driver[\"Name\"].ToString(),\"\" &#125;, -1); listView1.Items.Add(lvi); &#125; &#125; private void button5_Click(object sender, EventArgs e) &#123; listView1.Items.Clear(); SelectQuery selectQuery = new SelectQuery(\"select * from Win32_PrinterConfiguration \");//打印机设置 ManagementObjectSearcher search = new ManagementObjectSearcher(selectQuery); foreach (ManagementObject Driver in search.Get()) &#123; ListViewItem lvi = new ListViewItem(new string[] &#123; Driver[\"Name\"].ToString(), \"\" &#125;, -1); listView1.Items.Add(lvi); &#125; &#125; private void button6_Click(object sender, EventArgs e) &#123; listView1.Items.Clear(); SelectQuery selectQuery = new SelectQuery(\"select * from Win32_PrintJob \");//打印机任务 ManagementObjectSearcher search = new ManagementObjectSearcher(selectQuery); foreach (ManagementObject Driver in search.Get()) &#123; ListViewItem lvi = new ListViewItem(new string[] &#123; Driver[\"Name\"].ToString(), \"\" &#125;, -1); listView1.Items.Add(lvi); &#125; &#125; private void button7_Click(object sender, EventArgs e) &#123; listView1.Items.Clear(); SelectQuery selectQuery = new SelectQuery(\"select * from Win32_TCPIPPrinterPort \");//打印机端口 ManagementObjectSearcher search = new ManagementObjectSearcher(selectQuery); foreach (ManagementObject Driver in search.Get()) &#123; ListViewItem lvi = new ListViewItem(new string[] &#123; Driver[\"Name\"].ToString(), \"\" &#125;, -1); listView1.Items.Add(lvi); &#125; &#125; private void button8_Click(object sender, EventArgs e) &#123; listView1.Items.Clear(); SelectQuery selectQuery = new SelectQuery(\"select * from Win32_PointingDevice \");//点输入设备，鼠标 ManagementObjectSearcher search = new ManagementObjectSearcher(selectQuery); foreach (ManagementObject Driver in search.Get()) &#123; ListViewItem lvi = new ListViewItem(new string[] &#123; Driver[\"Name\"].ToString(), Driver[\"Description\"].ToString() &#125;, -1); listView1.Items.Add(lvi); &#125; &#125; private void button9_Click(object sender, EventArgs e) &#123; listView1.Items.Clear(); SelectQuery selectQuery = new SelectQuery(\"select * from Win32_Keyboard\");//键盘 ManagementObjectSearcher search = new ManagementObjectSearcher(selectQuery); foreach (ManagementObject Driver in search.Get()) &#123; ListViewItem lvi = new ListViewItem(new string[] &#123; Driver[\"Name\"].ToString(), Driver[\"Description\"].ToString() &#125;, -1); listView1.Items.Add(lvi); &#125; &#125; private void button10_Click(object sender, EventArgs e) &#123; listView1.Items.Clear(); SelectQuery selectQuery = new SelectQuery(\"select * from Win32_Printer \");//打印机 ManagementObjectSearcher search = new ManagementObjectSearcher(selectQuery); foreach (ManagementObject Driver in search.Get()) &#123; ListViewItem lvi = new ListViewItem(new string[] &#123; Driver[\"Name\"].ToString(), \"\" &#125;, -1); listView1.Items.Add(lvi); &#125; &#125; &#125; &#125; 仅仅实现了查询的功能，后续有待加入与设备管理器类似的管理功能！","categories":[],"tags":[]},{"title":"C#窗体实现打开关闭VM虚拟机","slug":"C#窗体实现打开关闭VM虚拟机","date":"2014-11-08T11:59:00.000Z","updated":"2018-06-13T15:31:21.408Z","comments":true,"path":"2014/11/08/C#窗体实现打开关闭VM虚拟机/","link":"","permalink":"https://lossingdawn.top/2014/11/08/C#窗体实现打开关闭VM虚拟机/","excerpt":"摘要: vixclass.cs//定义开机、关机等函数using System;using System.Collections.Generic;using System.Linq;using System.Runtime.InteropServices;using System.Text;using Sy…阅读全文","text":"摘要: vixclass.cs//定义开机、关机等函数using System;using System.Collections.Generic;using System.Linq;using System.Runtime.InteropServices;using System.Text;using Sy…阅读全文 vixclass.cs//定义开机、关机等函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139 using System;using System.Collections.Generic;using System.Linq;using System.Runtime.InteropServices;using System.Text;using System.Threading.Tasks;using VixCOM;namespace dome&#123; class vixclass &#123; public VixCOM.IVixLib IvixLib; public ulong m_vixError; public VixCOM.IHost m_hostHandle; public VixCOM.IVM m_vmHandle;// public VixCOM.IJob jobHandle; public vixclass() &#123; IvixLib = new VixCOM.VixLibClass(); m_vixError=0; m_hostHandle = null; m_vmHandle = null; //jobHandle = null; &#125; public ulong GetError() &#123; return m_vixError; &#125; /// &lt;summary&gt; /// 创建链接 /// &lt;/summary&gt; public bool Connect(string _hostname,string _username, string _password) &#123; int hostType = VixCOM.Constants.VIX_SERVICEPROVIDER_VMWARE_WORKSTATION; int vixVersion = VixCOM.Constants.VIX_API_VERSION; vixVersion = -1; int[] propertyIds = new int[1] &#123; VixCOM.Constants.VIX_PROPERTY_JOB_RESULT_HANDLE &#125;; object results = new object(); IJob jobHandle = IvixLib.Connect(vixVersion, hostType, _hostname, 0, _username, _password, 0, null, null); //jobHandle = IvixLib.Connect(vixVersion, hostType, hostname, 0, user, password, 0, null, null); m_vixError = jobHandle.Wait(propertyIds, ref results); if (m_vixError == VixCOM.Constants.VIX_OK) &#123; object[] objectArray = (object[])results; m_hostHandle = (VixCOM.IHost)objectArray[0]; return true; &#125; return false; &#125; /// &lt;summary&gt; ///打开vmxPath的虚拟机 /// &lt;/summary&gt; public bool OpenVm(string vmxPath) &#123; IJob jobHandle = m_hostHandle.OpenVM(vmxPath, null); int[] propertyIds = new int[1] &#123; VixCOM.Constants.VIX_PROPERTY_JOB_RESULT_HANDLE &#125;; object results = new object(); m_vixError = jobHandle.Wait(propertyIds, ref results); if (m_vixError == VixCOM.Constants.VIX_OK) &#123; object[] objectArray = (object[])results; m_vmHandle = (VixCOM.IVM)objectArray[0]; return true; &#125; return false; &#125; /// &lt;summary&gt; /// 启动虚拟机 /// &lt;/summary&gt; public bool PowerOn() &#123; IJob jobHandle = m_vmHandle.PowerOn(VixCOM.Constants.VIX_VMPOWEROP_LAUNCH_GUI, null, null); m_vixError = jobHandle.WaitWithoutResults(); if (m_vixError == VixCOM.Constants.VIX_OK) &#123; // jobHandle = m_vmHandle.WaitForToolsInGuest(300, null); m_vixError = jobHandle.WaitWithoutResults(); &#125; return (m_vixError == VixCOM.Constants.VIX_OK); &#125; /// &lt;summary&gt; /// 关闭虚拟机 /// &lt;/summary&gt; public bool PowerOff() &#123; IJob jobHandle = m_vmHandle.PowerOff(VixCOM.Constants.VIX_VMPOWEROP_NORMAL, null); m_vixError = jobHandle.WaitWithoutResults(); return (m_vixError == VixCOM.Constants.VIX_OK); &#125; /// &lt;summary&gt; /// 重启虚拟机 /// &lt;/summary&gt; public bool Restart() &#123; IJob jobHandle = m_vmHandle.Reset(VixCOM.Constants.VIX_VMPOWEROP_NORMAL, null); m_vixError = jobHandle.WaitWithoutResults(); return (m_vixError == VixCOM.Constants.VIX_OK); &#125; &#125;&#125; Form1.cs//主窗体， textbox1//记录选择的虚拟机的路径 btnselect//选择路径 btnstart//打开虚拟机 btnclose//关闭虚拟机 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace dome&#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); &#125; private void btnselect_Click(object sender, EventArgs e) &#123; OpenFileDialog loSaveFile = new OpenFileDialog(); loSaveFile.Filter = \".vmx文件(*.vmx)|*.vmx\"; if (loSaveFile.ShowDialog() == DialogResult.OK) &#123; this.textBox1.Text = loSaveFile.FileName; &#125; &#125; private void btnstart_Click(object sender, EventArgs e) &#123; try &#123; vixclass vix = new vixclass(); string vmxpath = textBox1.Text; vix.Connect(null, \"Administrator\", null); vix.OpenVm(@vmxpath); vix.PowerOn(); &#125; catch(Exception ex) &#123; MessageBox.Show(ex.ToString()); &#125; &#125; private void btnclose_Click(object sender, EventArgs e) &#123; try &#123; vixclass vix = new vixclass(); string vmxpath = textBox1.Text; vix.Connect(null , \"Administrator\", null); vix.OpenVm(@vmxpath); vix.PowerOff(); &#125; catch (Exception ex) &#123; MessageBox.Show(ex.ToString()); &#125; &#125; private void Form1_Load(object sender, EventArgs e) &#123; &#125; &#125;&#125; 注：添加引用：VixCOM.DLL","categories":[],"tags":[]},{"title":"C#控制台打开VM虚拟机","slug":"C#控制台打开VM虚拟机","date":"2014-11-05T12:40:00.000Z","updated":"2018-06-13T15:31:22.668Z","comments":true,"path":"2014/11/05/C#控制台打开VM虚拟机/","link":"","permalink":"https://lossingdawn.top/2014/11/05/C#控制台打开VM虚拟机/","excerpt":"摘要: 添加引用-&gt;VixCOM.dll (在vix文件夹下)VixWrapper.csusing System;using System.Collections.Generic;using System.Linq;using System.Runtime.InteropServices;using Sys…阅读全文","text":"摘要: 添加引用-&gt;VixCOM.dll (在vix文件夹下)VixWrapper.csusing System;using System.Collections.Generic;using System.Linq;using System.Runtime.InteropServices;using Sys…阅读全文 添加引用-&gt;VixCOM.dll (在vix文件夹下) VixWrapper.cs 1using System; using System.Collections.Generic; using System.Linq; using System.Runtime.InteropServices; using System.Text; using VixCOM; namespace VMHelper &#123; class VixWrapper &#123; VixCOM.IVixLib vixLib = null; ulong m_vixError; VixCOM.IHost m_hostHandle = null; VixCOM.IVM m_vmHandle = null; public ulong GetError() &#123; return m_vixError; &#125; public VixWrapper() &#123; try &#123; vixLib = new VixCOM.VixLibClass(); &#125; catch (COMException comExc) &#123; System.Diagnostics.Trace.WriteLine(comExc.Message + \"\\n\"); throw; &#125; &#125; /// &lt;summary&gt; /// Creates a host handle /// &lt;/summary&gt; /// &lt;returns&gt;true if succeeded, otherwise false&lt;/returns&gt; public bool Connect(string hostName, string userName, string password) &#123; int hostType = string.IsNullOrEmpty(hostName) ? VixCOM.Constants.VIX_SERVICEPROVIDER_VMWARE_WORKSTATION : VixCOM.Constants.VIX_SERVICEPROVIDER_VMWARE_SERVER; int vixVersion = VixCOM.Constants.VIX_API_VERSION; vixVersion = -1; VixCOM.IJob jobHandle = vixLib.Connect(vixVersion, hostType, null, 0, userName, password, 0, null, null); int[] propertyIds = new int[1] &#123; VixCOM.Constants.VIX_PROPERTY_JOB_RESULT_HANDLE &#125;; object results = new object(); m_vixError = jobHandle.Wait(propertyIds, ref results); if (m_vixError == VixCOM.Constants.VIX_OK) &#123; object[] objectArray = (object[])results; m_hostHandle = (VixCOM.IHost)objectArray[0]; return true; &#125; return false; &#125; /// &lt;summary&gt; /// Opens the virtual machine specified in vmxFilePath /// &lt;/summary&gt; /// &lt;param name=”vmxFilePath”&gt;The virtual machine vmx file to open&lt;/param&gt; /// &lt;returns&gt;true if succeeded, otherwise false&lt;/returns&gt; public bool OpenVm(string vmxFilePath) &#123; IJob jobHandle = m_hostHandle.OpenVM(vmxFilePath, null); int[] propertyIds = new int[1] &#123; VixCOM.Constants.VIX_PROPERTY_JOB_RESULT_HANDLE &#125;; object results = new object(); m_vixError = jobHandle.Wait(propertyIds, ref results); if (m_vixError == VixCOM.Constants.VIX_OK) &#123; object[] objectArray = (object[])results; m_vmHandle = (VixCOM.IVM)objectArray[0]; return true; &#125; return false; &#125; /// &lt;summary&gt; /// Power on the virtual machine /// &lt;/summary&gt; /// &lt;returns&gt;true if succeeded, otherwise false&lt;/returns&gt; public bool PowerOn() &#123; IJob jobHandle = m_vmHandle.PowerOn(VixCOM.Constants.VIX_VMPOWEROP_LAUNCH_GUI, null, null); m_vixError = jobHandle.WaitWithoutResults(); if (m_vixError == VixCOM.Constants.VIX_OK) &#123; jobHandle = m_vmHandle.WaitForToolsInGuest(300, null); m_vixError = jobHandle.WaitWithoutResults(); &#125; return (m_vixError == VixCOM.Constants.VIX_OK); &#125; /// &lt;summary&gt; /// Starts a snapshot of a virtual machine /// &lt;/summary&gt; /// &lt;param name=”snapshot_name”&gt;The name of the snapshot to start&lt;/param&gt; /// &lt;returns&gt;true if succeeded, otherwise false&lt;/returns&gt; public bool RevertToLastSnapshot() &#123; ISnapshot snapshot = null; m_vixError = m_vmHandle.GetRootSnapshot(0, out snapshot); if (m_vixError == VixCOM.Constants.VIX_OK) &#123; IJob jobHandle = m_vmHandle.RevertToSnapshot(snapshot, 0, null, null); m_vixError = jobHandle.WaitWithoutResults(); &#125; return (m_vixError == VixCOM.Constants.VIX_OK); &#125; /// &lt;summary&gt; /// Login to the virtual machine /// &lt;/summary&gt; /// &lt;returns&gt;true if succeeded, otherwise false&lt;/returns&gt; public bool LogIn(string username, string password) &#123; IJob jobHandle = m_vmHandle.LoginInGuest(username, password, 0, null); m_vixError = jobHandle.WaitWithoutResults(); return (m_vixError == VixCOM.Constants.VIX_OK); &#125; /// &lt;summary&gt; /// Creates the directory in the Virtual Machine /// &lt;/summary&gt; /// &lt;param name=”pathName”&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public bool CreateDirectoryInVm(string pathName) &#123; IJob jobHandle = m_vmHandle.CreateDirectoryInGuest(pathName, null, null); m_vixError = jobHandle.WaitWithoutResults(); return (m_vixError == VixCOM.Constants.VIX_OK); &#125; /// &lt;summary&gt; /// Copies a file from the host machine to the virtual machine /// &lt;/summary&gt; /// &lt;param name=”sourceFile”&gt;The source file on the host machine&lt;/param&gt; /// &lt;param name=”destinationFile”&gt;The destination on the VM&lt;/param&gt; /// &lt;returns&gt;true if succeeded, otherwise false&lt;/returns&gt; public bool CopyFileToVm(string sourceFile, string destinationFile) &#123; // // Copy files from host to guest // IJob jobHandle = m_vmHandle.CopyFileFromHostToGuest(sourceFile, destinationFile, 0, null, null); m_vixError = jobHandle.WaitWithoutResults(); return (m_vixError == VixCOM.Constants.VIX_OK); &#125; /// &lt;summary&gt; /// Copies a file from the virtual machine to the host machine /// &lt;/summary&gt; /// &lt;param name=”sourceFile”&gt;The source file on the virtual machine&lt;/param&gt; /// &lt;param name=”destinationFile”&gt;The destination on the host machine&lt;/param&gt; /// &lt;returns&gt;true if succeeded, otherwise false&lt;/returns&gt; public bool CopyFileFromVm(string sourceFile, string destinationFile) &#123; // // Copy files from host to guest // IJob jobHandle = m_vmHandle.CopyFileFromGuestToHost(sourceFile, destinationFile, 0, null, null); m_vixError = jobHandle.WaitWithoutResults(); return (m_vixError == VixCOM.Constants.VIX_OK); &#125; /// &lt;summary&gt; /// Runs a program on the virtual machine /// &lt;/summary&gt; /// &lt;param name=”exePath”&gt;The path of the program on the virtual machine&lt;/param&gt; /// &lt;param name=”parameters”&gt;The parameters to pass to the executable&lt;/param&gt; /// &lt;param name=”resultCode”&gt;The result code returned from the program that ran on the VM&lt;/param&gt; /// &lt;returns&gt;true if succeeded, otherwise false&lt;/returns&gt; public bool RunProgram(string exePath, string parameters, out int resultCode) &#123; resultCode = -1; IJob jobHandle = m_vmHandle.RunProgramInGuest(exePath, parameters, VixCOM.Constants.VIX_RUNPROGRAM_ACTIVATE_WINDOW, null, null); // clientData int[] propertyIds = new int[1] &#123; VixCOM.Constants.VIX_PROPERTY_JOB_RESULT_GUEST_PROGRAM_EXIT_CODE &#125;; object results = new object(); m_vixError = jobHandle.Wait(propertyIds, ref results); if (m_vixError == VixCOM.Constants.VIX_OK) &#123; object[] objectArray = (object[])results; resultCode = (int)objectArray[0]; return true; &#125; return false; &#125; /// &lt;summary&gt; /// Power off the virtual machine /// &lt;/summary&gt; /// &lt;returns&gt;true if succeeded, otherwise false&lt;/returns&gt; public bool PowerOff() &#123; IJob jobHandle = m_vmHandle.PowerOff(VixCOM.Constants.VIX_VMPOWEROP_NORMAL, null); m_vixError = jobHandle.WaitWithoutResults(); return (m_vixError == VixCOM.Constants.VIX_OK); &#125; /// &lt;summary&gt; /// Restart the virtual machine /// &lt;/summary&gt; /// &lt;returns&gt;true if succeeded, otherwise false&lt;/returns&gt; public bool Restart() &#123; IJob jobHandle = m_vmHandle.Reset(VixCOM.Constants.VIX_VMPOWEROP_NORMAL, null); m_vixError = jobHandle.WaitWithoutResults(); return (m_vixError == VixCOM.Constants.VIX_OK); &#125; &#125; &#125; Program.cs 123456789101112131415161718192021222324252627282930313233343536 using System;using System.Collections.Generic;using System.Linq;using System.Runtime.InteropServices;using System.Text;using VMHelper;namespace VixWrapperTest&#123; class Program &#123; static void Main(string[] args) &#123; try &#123; //VixWrapper.VixWrapper vix = new VixWrapper.VixWrapper(); VixWrapper wrapper = new VixWrapper(); wrapper.Connect(null, \"Administrator\", null); wrapper.OpenVm(@\"E:\\win xp\\Windows XP Professional.vmx\");//安装好的虚拟机.vmx的实际路径 wrapper.PowerOn(); wrapper.PowerOff(); &#125; catch (Exception e) &#123; Console.WriteLine(e.ToString()); &#125; &#125; &#125;&#125; 本程序实现了通过VS控制台打开vm虚拟机的功能，有兴趣的可以去调用剩下的函数，做个时延函数，然后完成其他任务。","categories":[],"tags":[]},{"title":"C# U盘扫描","slug":"C# U盘扫描","date":"2014-10-27T06:59:00.000Z","updated":"2018-06-13T15:31:22.667Z","comments":true,"path":"2014/10/27/C# U盘扫描/","link":"","permalink":"https://lossingdawn.top/2014/10/27/C# U盘扫描/","excerpt":"摘要: 无意中看到的一个例程，保留一份。以供后用。using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Tex…阅读全文","text":"摘要: 无意中看到的一个例程，保留一份。以供后用。using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Tex…阅读全文 无意中看到的一个例程，保留一份。 以供后用。 using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Text; using System.IO; using System.Windows.Forms; using System.Runtime.InteropServices; namespace USB { public partial class USB : Form { public USB() { InitializeComponent(); } public const int WM_DEVICECHANGE = 0x219; public const int DBT_DEVICEARRIVAL = 0x8000; public const int DBT_CONFIGCHANGECANCELED = 0x0019; public const int DBT_CONFIGCHANGED = 0x0018; public const int DBT_CUSTOMEVENT = 0x8006; public const int DBT_DEVICEQUERYREMOVE = 0x8001; public const int DBT_DEVICEQUERYREMOVEFAILED = 0x8002; public const int DBT_DEVICEREMOVECOMPLETE = 0x8004; public const int DBT_DEVICEREMOVEPENDING = 0x8003; public const int DBT_DEVICETYPESPECIFIC = 0x8005; public const int DBT_DEVNODES_CHANGED = 0x0007; public const int DBT_QUERYCHANGECONFIG = 0x0017; public const int DBT_USERDEFINED = 0xFFFF; // 逻辑卷标 public const int DBT_DEVTYP_VOLUME = 0x00000002; // private LockScreen Ls = new LockScreen(); public string ID = “”; public string Value; public string[] item; [StructLayout(LayoutKind.Sequential)] public struct DEV_BROADCAST_VOLUME { public int dbcv_size; public int dbcv_devicetype; public int dbcv_reserved; public int dbcv_unitmask; } protected override void WndProc(ref Message m) { try { if (m.Msg == WM_DEVICECHANGE) { switch (m.WParam.ToInt32()) { case WM_DEVICECHANGE: break; case DBT_DEVICEARRIVAL://U盘有插入 this.timer1.Enabled = true; DriveInfo[] s = DriveInfo.GetDrives(); foreach (DriveInfo DriveI in s) { if (DriveI.DriveType == DriveType.Removable) { // Ls.Show(); // this.Hide(); // MessageBox.Show(“sss”); break; } int devType = Marshal.ReadInt32(m.LParam, 4); if (devType == DBT_DEVTYP_VOLUME) { DEV_BROADCAST_VOLUME vol; vol = (DEV_BROADCAST_VOLUME)Marshal.PtrToStructure(m.LParam, typeof(DEV_BROADCAST_VOLUME)); ID = vol.dbcv_unitmask.ToString(“x”); this.Text = IO(ID); this.Tag = IO(ID); //if (item.Length ==0||IO(ID)!=this.Tag.ToString ()) //{ //} } this.label1.Text = this.Text; } break; case DBT_CONFIGCHANGECANCELED: break; case DBT_CONFIGCHANGED: break; case DBT_CUSTOMEVENT: break; case DBT_DEVICEQUERYREMOVE: break; case DBT_DEVICEQUERYREMOVEFAILED: break; case DBT_DEVICEREMOVECOMPLETE: //U盘卸载 DriveInfo[] I = DriveInfo.GetDrives(); foreach (DriveInfo DrInfo in I) { int devType = Marshal.ReadInt32(m.LParam, 4); if (devType == DBT_DEVTYP_VOLUME) { DEV_BROADCAST_VOLUME vol; vol = (DEV_BROADCAST_VOLUME)Marshal.PtrToStructure(m.LParam, typeof(DEV_BROADCAST_VOLUME)); ID = vol.dbcv_unitmask.ToString(“x”); this.Text = IO(ID) + “盘退出！\\n”; } this.label1.Text += this.Text; // MessageBox.Show(“U盘已经卸载”, “信息提示”, MessageBoxButtons.OK, MessageBoxIcon.Information); } break; case DBT_DEVICEREMOVEPENDING: break; case DBT_DEVICETYPESPECIFIC: break; case DBT_DEVNODES_CHANGED: break; case DBT_QUERYCHANGECONFIG: break; case DBT_USERDEFINED: break; default: break; } } } catch (Exception ex) { throw new Exception(ex.Message); } base.WndProc(ref m); } private void USB_Load(object sender, EventArgs e) { } public string IO(string ff) { switch (ff) { case “1”: Value = “A:”; break; case “2”: Value = “B:”; break; case “4”: Value = “C:”; break; case “8”: Value = “D:”; break; case “10”: Value = “E:”; break; case “20”: Value = “F:”; break; case “40”: Value = “G:”; break; case “80”: Value = “H:”; break; case “100”: Value = “I:”; break; case “200”: Value = “J:”; break; case “400”: Value = “K:”; break; case “800”: Value = “L:”; break; case “1000”: Value = “M:”; break; case “2000”: Value = “N:”; break; case “4000”: Value = “O:”; break; case “8000”: Value = “P:”; break; case “10000”: Value = “Q:”; break; case “20000”: Value = “R:”; break; case “40000”: Value = “S:”; break; case “80000”: Value = “T:”; break; case “100000”: Value = “U:”; break; case “200000”: Value = “V:”; break; case “400000”: Value = “W:”; break; case “800000”: Value = “X:”; break; case “1000000”: Value = “Y:”; break; case “2000000”: Value = “Z:”; break; default: break; } return Value; } private void timer1_Tick(object sender, EventArgs e) { // this.Text = ID; } } }","categories":[],"tags":[]}]}