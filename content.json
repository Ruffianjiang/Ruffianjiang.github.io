{"meta":{"title":"Hexo","subtitle":null,"description":"start from zero","author":"Ruffianjiang","url":"https://lossingdawn.top","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-06-16T15:15:00.029Z","updated":"2018-06-16T15:15:00.029Z","comments":false,"path":"/404.html","permalink":"https://lossingdawn.top//404.html","excerpt":"","text":""},{"title":"关于","date":"2019-04-14T04:47:39.514Z","updated":"2019-04-14T04:47:39.514Z","comments":true,"path":"about/index.html","permalink":"https://lossingdawn.top/about/index.html","excerpt":"","text":"个人详细介绍 邮箱jiangyj0516@outlook.com 博客园http://www.cnblogs.com/lossingdawn/ githubhttps://github.com/Ruffianjiang giteehttps://gitee.com/ruffianjiang/ 联系方式QQ: 759372350wechat: jiangyjcslg"},{"title":"书单","date":"2018-06-16T15:15:18.405Z","updated":"2018-06-04T11:30:58.847Z","comments":false,"path":"books/index.html","permalink":"https://lossingdawn.top/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-05-30T15:48:37.000Z","updated":"2018-06-16T15:26:33.373Z","comments":false,"path":"categories/index.html","permalink":"https://lossingdawn.top/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-16T16:46:48.901Z","updated":"2018-06-04T11:30:58.848Z","comments":true,"path":"links/index.html","permalink":"https://lossingdawn.top/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-08-11T08:11:59.710Z","updated":"2018-06-04T11:30:58.849Z","comments":false,"path":"repository/index.html","permalink":"https://lossingdawn.top/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-06-16T15:14:12.409Z","updated":"2018-06-04T11:30:58.850Z","comments":false,"path":"tags/index.html","permalink":"https://lossingdawn.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Restful Api设计","slug":"300-restful-api设计","date":"2019-07-26T13:44:00.000Z","updated":"2019-07-27T17:10:52.503Z","comments":true,"path":"p/zh-CN/12305.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/12305.html","excerpt":"","text":"","categories":[{"name":"restful","slug":"restful","permalink":"https://lossingdawn.top/categories/restful/"}],"tags":[{"name":"restful","slug":"restful","permalink":"https://lossingdawn.top/tags/restful/"}]},{"title":"Java 8 终于支持 Docker！","slug":"90-Java-8-终于支持-Docker！","date":"2019-07-22T02:09:00.000Z","updated":"2019-07-27T17:05:34.765Z","comments":true,"path":"p/zh-CN/42520.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/42520.html","excerpt":"","text":"Java 8曾经与Docker无法很好地兼容性，现在问题已消失。请注意：我在本文中使用采用GNU GPL v2许可证的OpenJDK官方docker映像。在Oracle Java SE中，这里描述的docker支持功能在更新191中引入。Oracle在2019年4月更改了Java 8更新的许可证，自Java SE 8 Update 211以来商业使用不再免费。你是否遇到过在docker中运行的基于JVM的应用程序出现“随机”故障？或者也许是一些奇怪的死机？两者都可能是Java 8（仍广泛使用的）中糟糕的docker支持引起的。Docker使用控制组（cgroups）来限制资源。在容器中运行应用程序时限制内存和CPU绝对是个好主意――它可以阻止应用程序占用整个可用内存及/或CPU，这会导致在同一个系统上运行的其他容器毫无反应。限制资源可提高应用程序的可靠性和稳定性。它还允许为硬件容量作好规划。在Kubernetes或DC/OS之类的编排系统上运行容器时尤为重要。问题JVM可以“看到”系统上的整个内存和可用的所有CPU核心，并确保与资源一致。它默认情况下将最大堆大小（heap size）设置为系统内存的1/4，并将某些线程池大小（比如针对GC）设置为物理核心数量。不妨举例说明。我们将运行一个简单的应用程序，它消耗尽可能多的内存（可在该网站上找到）：我们在拥有64GB内存的系统上运行，所以不妨检查默认的最大堆大小：如上所述，它是物理内存的1/4即16GB。如果我们使用docker cgroups限制内存，会发生什么？不妨检查一下：JVM进程被杀死了。由于它是一个子进程――容器本身幸存下来，但通常当java是容器（PID 1）内的唯一进程时，容器会崩溃。不妨深入看看系统日志：像这样的故障调试起来可能很难――应用程序日志中没有任何内容。在AWS ECS之类的托管系统上尤其困难重重。CPU怎么样？不妨再次检查，运行一个显示可用处理器数量的小程序：不妨在一个cpu编号设置为1的docker容器中运行它：不好，这个系统上的确有12个CPU。因此，即使可用处理器的数量限制为1，JVM也会尝试使用12――比如说，GC线程数量由该公式设置：在拥有N个硬件线程（N大于8）的机器上，并行收集器使用N的固定分数作为垃圾收集器线程的数量。如果N的值很大，该分数约5/8。如果N的值低于8，使用的数字是N。在我们的情况下：解决方案OK，我们现在意识到了这个问题。有解决方案吗？幸运的是，有！新的Java版本（10及以上版本）已经内置了docker支持功能。但有时升级不是办法，比如说如果应用程序与新JVM不兼容就不行。好消息：Docker支持还被向后移植到Java 8。不妨检查标记为8u212的最新openjdk映像。我们将内存限制为1G，并使用1个CPU：docker run -ti --cpus 1 -m 1G openjdk：8u212-jdk。内存：它是256M，正好是已分配内存的1/4。CPU：正如我们想要的那样。此外，还有几个新的设置：它们允许微调堆大小――这些设置的含义在StackOverflow的这个优秀答案中已得到了解释。请注意：他们设置的是百分比，而不是固定值。正因为如此，改变Docker内存设置不会破坏任何东西。如果由于某种原因不想要看到新的JVM行为，可以使用-XX：-UseContainerSupport来关闭。总结为基于JVM的应用程序设置正确的堆大小极其重要。如果使用最新的Java 8版本，你可以依赖安全（但非常保守）的默认设置。不需要在docker入口点中使用任何变通办法，也不需要再将Xmx设置为固定值。使用JVM愉快！","categories":[{"name":"java","slug":"java","permalink":"https://lossingdawn.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://lossingdawn.top/tags/java/"},{"name":"docker","slug":"docker","permalink":"https://lossingdawn.top/tags/docker/"}]},{"title":"微服务高可用方案","slug":"200-微服务高可用方案","date":"2019-07-22T00:09:00.000Z","updated":"2019-07-27T16:43:59.612Z","comments":true,"path":"p/zh-CN/39944.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/39944.html","excerpt":"","text":"微服务高可用方案 一、微服务的高可用在注册中心、配置中心高可用方案之前，了解一下注册中心的工作原理，下面分为两个部分来解释，一是注册中心和各个微服务的注册表的获取与同步，二是注册中心如何去维护注册表。 1.1、注册表的获取与同步Eureka Server和Eureka Client之间的关系，通过注册表来维护，而注册表的通过Eureka Server集中化管理，每个Client在本地进行注册表的缓存，通过周期性的任务拉取最新的注册表信息。简单的示例图如下。根据上图所展示的流程，可以了解到注册中心与微服务之间的基本联系的流程：1．服务A启动时，向Eureka Server注册自己的相关信息2．当服务B向Eureka Server拉取最新的注册表时，就可以拿到服务A的一台机器注册信息3．服务A的另外两台机器再去注册，服务B 30s后再次去拉取时，就会得到服务A的三台机器的注册信息4．服务A、每30s向Eureka Server发送一次心跳信息，表明自己的注册信息还是有效的以上是注册中心与微服务之间交互的大体流程，在具体的实践中，Eureka Server会提供多级缓存，其中的注册表的信息的获取与同步，又会有细微的差别。1．Eureka Server的注册表直接基于纯内存，即在内存里维护了一个数据结构。2．各个服务的注册、服务下线、服务故障，全部会在内存里维护和更新这个注册表。3．各个服务每隔30秒拉取注册表的时候，Eureka Server就是直接提供内存里存储的有变化的注册表数据给他们就可以了。4．同样，每隔30秒发起心跳时，也是在这个纯内存的Map数据结构里更新心跳时间。Eureka Server的注册表是纯内存处理的，因此处理速度会很快，同时提供 readWriteCacheMap 和 readOnlyCacheMap 做缓存，保障了频繁读写不会冲突。示意图如下。上图介绍了Eureka Server多级缓存的工作原理：1．当第一台服务A注册时，它的注册信息会更新到内存的注册表中，如果 readWriteCacheMap 中有相应的信息，则过期掉，如果没有则不做操作2．当服务B去拉取注册表信息时，先找 readOnlyCacheMap ，没有再找 readWriteCacheMap ，再没有就去内存的注册表查找注册信息，查到就更新到 readWriteCacheMap 中，返回给服务B，服务B的注册表中，就会有一台服务A的机器注册信息3．readOnlyCacheMap 和 readWriteCacheMap 之间的同步是有一个后台的定时任务，每隔30s去同步一次，缓存同步任务4．第二台服务A注册时，更新内存的注册表，同时把 readWriteCacheMap 过期掉5．在缓存同步任务执行之前服务B去拉取注册表时，都是从 readOnlyCacheMap 中拿到数据，新的注册表的信息，不会被服务B拿到6．30s后，缓存同步任务会同步 readWriteCacheMap 和 readOnlyCacheMap 中的数据，把readOnlyCacheMap 中的注册表过期掉，这时服务B就会找 readWriteCacheMap 拿数据，readWriteCacheMap 从内存中拿到数据后缓存，返回给服务B，服务B的注册表中，就会有两台服务A的机器注册信息7．在下一个30s，缓存同步任务把 readWriteCacheMap 同步到 readOnlyCacheMap 之前， readOnlyCacheMap 没有第二台服务A的注册缓存，因此都是从 readWriteCacheMap 中取到最新数据注：readOnlyCacheMap 缓存更新的定时器时间间隔，默认为30秒readWriteCacheMap 缓存过期时间，默认为 180 秒由以上流程说明可知，Eureka Server采取了多级缓存策略，同时最新的注册表生效有30s的时延。多级缓存机制的优点是什么：1．尽可能保证了内存注册表数据不会出现频繁的读写冲突问题。2．并且进一步保证对Eureka Server的大量请求，都是快速从纯内存走，性能极高。 1.2、注册中心维护微服务的注册表Eureka Client与注册表相关的行为如下所示：1．服务注册(Registry)——初始化时执行一次，向服务端注册自己服务实例节点信息包括ip、端口、实例名等，基于POST请求。2．服务续约(renew)——默认每隔30s向服务端PUT一次，保证当前服务节点状态信息实时更新，不被服务端失效剔除。3．更新已经注册服务列表(fetchRegistry)——默认每隔30s从服务端GET一次增量版本信息，然后和本地比较并合并，保证本地能获取到其他节点最新注册信息。4．服务下线(cancel)——在服务shutdown的时候，需要及时通知服务端把自己剔除，以避免客户端调用已经下线的服务。Eureka Client是通过Jersey Client基于Http协议与Eureka Server交互来注册服务、续约服务、取消服务、服务查询等。同时，Server端还会维护一份服务实例清单，并每隔90s对未续约的实例进行失效剔除。Eureka Server有一个自我保护机制，当网络发生故障时，客户端与服务端不通，这是需要启动Eureka Server的自我保护机制，这样不会剔除服务，当网络恢复时，退出自我保护。自我保护有两个参数，最后一分钟收到的心跳数（Renews (last min)）、期望收到的心跳数（Renews threshold），当Renews threshold &gt; Renews (last min) 时，进入自我保护模式。Renews (last min) = 实例数 * 2 #实例数算上Eureka Server自注册服务Renews threshold = Renews (last min) * 0.85 # 0.85可配置下图的注册中有10个实例：推荐多个Eureka Server部署时，开启自我保护1eureka.client.register-with-eureka = true 1.3、分布式注册中心了解了注册中心的工作原理，下面开始研究分布式服务，多注册中心、多服务实例的情况。当微服务仅向一台注册中心注册时，当这个注册中心发生故障时，新服务无法继续注册上去，旧服务的注册信息，缓存在其他注册中心和客户端中，依旧可以使用，当重启之后，无法向注册中心注册，也是无法使用的。因此构建高可用的注册中心时，需要交叉注册，每个注册中心既当服务端，又当客户端，向其他注册中心注册自己，同时微服务需要向每个注册中心进行注册，由注册中心自己过滤互备，防止单个注册中心故障而导致只往它上面注册微服务重启后不可用。示意图如下所示。目前注册中心与配置中心集中在一起，可拆可不拆，对整体影响不大，拆分是为了注册中心和配置中心相互间不影响。gitlab部署在某一台机器上，所有config共用，由于gitlab的原因，导致config的分布式存在单点故障的隐患。每个config分别用独立的gitlab，又给运维带来极大的不便。后期采用apollo，用数据库存储配置，利用数据库的分布式优势替代gitlab，来解决单点故障的问题。 1.4、注册中心压测根据压测调研，8核4G的Eureka Server在处理1000个服务实例时，没有任何压力，在默认情况下，可以处理7000个实例，超出的会超时报错，在修改tomcat的配置之后，最多可以承载8000实例，此时CPU基本满载。升级注意事项：1、Eureka Server之间相互注册，Eureka Client需要在每个Server上都注册一边2、Eureka Server开启自我保护3、Eureka Client的实例数不超过1000个 参考：[1] https://www.jianshu.com/p/ae4f0c8b8135[2] https://www.cnblogs.com/xishuai/p/spring-cloud-eureka-safe.html[3] http://springcloud.cn/view/31","categories":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://lossingdawn.top/categories/spring-cloud/"}],"tags":[{"name":"java","slug":"java","permalink":"https://lossingdawn.top/tags/java/"},{"name":"spring cloud","slug":"spring-cloud","permalink":"https://lossingdawn.top/tags/spring-cloud/"}]},{"title":"Eureka注册中心账户登陆","slug":"200-eureka注册中心账户登陆","date":"2019-06-15T14:09:00.000Z","updated":"2019-07-27T17:04:24.340Z","comments":true,"path":"p/zh-CN/34700.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/34700.html","excerpt":"","text":"","categories":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://lossingdawn.top/categories/spring-cloud/"}],"tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://lossingdawn.top/tags/spring-cloud/"},{"name":"eureka","slug":"eureka","permalink":"https://lossingdawn.top/tags/eureka/"}]},{"title":"CentOS 7.3 安装Python3","slug":"20-CentOS-7-3-安装python3","date":"2019-05-21T06:19:00.000Z","updated":"2019-07-27T17:04:00.667Z","comments":true,"path":"p/zh-CN/12168.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/12168.html","excerpt":"","text":"1、排查CentOS 7.3 默认安装的是python2，使用命令 python -V 可以看到 python 的版本1Python 2.7.5然后使用命令 which python 查看一下Python可执行文件的位置可见执行文件在 /usr/bin/ 目录下，切换到该目录下执行 ll python/* 命令查看 可见 python 和 python2 都指向了 python2.7，因此执行 python 程序可用 python 和 python2。我们在 yum 仓库搜索 python 相关的包，发现没有 python3 相关的12yum search pythonyum search python3因此，我们使用编译的形式安装 python3，并使用软链在 /usr/bin/ 下建立 python3 。 2、安装没有 python 的可用 yum install python 来安装安装相关依赖1yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make下载 python3 的包，在任意目录。没有wget的，yum安装一下，再下载1wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz解压1tar -xvJf Python-3.6.2.tar.xz切换进入1cd Python-3.6.2编译安装12./configure prefix=/usr/local/python3make &amp;&amp; make install安装完毕，/usr/local/ 目录下就会有 python3了因此我们可以添加软链到执行目录下/usr/bin1ln -s /usr/local/python3/bin/python3 /usr/bin/python3查看 python 的版本123python -Vpython2 -Vpython3 -V需要 python 即是 python3 的，可以参考最后的参考链接。建软链不同，和需要修改 yum 的配置（不建议去修改 python 的默认版本，建议用 python3 来代替，因为有些软件默认是 python2 的，可能会引起意外的事故）参考：https://www.cnblogs.com/JahanGu/p/7452527.html","categories":[{"name":"linux","slug":"linux","permalink":"https://lossingdawn.top/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lossingdawn.top/tags/linux/"}]},{"title":"找到Linux中当前java的安装位置","slug":"20-找到linux中当前java的安装位置","date":"2019-05-13T05:49:00.000Z","updated":"2019-07-27T17:07:13.680Z","comments":true,"path":"p/zh-CN/58622.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/58622.html","excerpt":"","text":"先看java -version123$java version \"1.8.0_111\"Java(TM) SE Runtime Environment (build 1.8.0_111-b14)Java HotSpot(TM) 64-Bit Server VM (build 25.111-b14, mixed mode)然后：1echo $JAVA_HOME不一定有，如果没有，那就要找一下 先12$which java/usr/bin/java再找到/usr/bin/java的超链接位置发现还是超链接12$ls -lrt /usr/bin/javalrwxrwxrwx 1 root root 22 Jul 27 11:43 /usr/bin/java -&gt; /etc/alternatives/java再来一次，发现最终位置12$ls -lrt /etc/alternatives/javalrwxrwxrwx 1 root root 35 Jul 27 11:43 /etc/alternatives/java -&gt; /usr/java/jdk1.8.0_111/jre/bin/java最后的这个jdk位置就是目前用的java的jdk位置1/usr/java/jdk1.8.0_111/（这个是我的，你用你自己的）在.bashrc里面加上一句export JAVA_HOME=你的java安装路径","categories":[{"name":"linux","slug":"linux","permalink":"https://lossingdawn.top/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lossingdawn.top/tags/linux/"}]},{"title":"Poi解析excel文件报错","slug":"80-poi解析excel文件报错","date":"2019-04-03T08:05:00.000Z","updated":"2019-07-27T17:06:10.071Z","comments":true,"path":"p/zh-CN/63371.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/63371.html","excerpt":"","text":"getFileMagic() only operates on streams which support mark(int)使用 bis 解决12BufferedInputStream bis = new BufferedInputStream(new FileInputStream(new File(path))); XSSFWorkbook xssfWorkbook = new XSSFWorkbook(bis);找不到类，一般是版本问题，可以把版本调整一致，3.15java.lang.reflect.InvocationTargetExceptionorg.apache.poi.POIXMLException: java.lang.reflect.InvocationTargetExceptionJava.lang.NoClassDefFoundError :org/openxmlformats/schemas/spreadsheetml/x2006/main/ctextensionlistpom配置，版本保持一致，3.151234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.15&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-scratchpad&lt;/artifactId&gt; &lt;version&gt;3.15&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.15&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml-schemas&lt;/artifactId&gt; &lt;version&gt;3.15&lt;/version&gt; &lt;/dependency&gt;","categories":[{"name":"java","slug":"java","permalink":"https://lossingdawn.top/categories/java/"}],"tags":[{"name":"java, poi","slug":"java-poi","permalink":"https://lossingdawn.top/tags/java-poi/"}]},{"title":"理解 Spring 定时任务的 fixedRate 和 fixedDelay 的区别","slug":"100-理解-Spring-定时任务的-fixedRate-和-fixedDelay-的区别","date":"2019-01-24T05:32:00.000Z","updated":"2019-07-27T17:07:19.909Z","comments":true,"path":"p/zh-CN/50457.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/50457.html","excerpt":"","text":"用过 Spring 的 @EnableScheduling 的都知道，有三种方式，即 @Scheduled 注解的 fixedRate(fixedRateString), fixedDelay(fixedDelayString), 以及 cron这里讨论 fixedRate 和 fixedDelay 参数fixedRate 是有一个时刻表的概念，在任务启动时，T1、T2、T3就已经排好了执行的时刻，比如1分、2分、3分，当T1的执行时间大于1分钟时，就会造成T2晚点，当T1执行完时T2立即执行，fixedDelay 比较简单，表示上个任务结束，到下个任务开始的时间间隔。无论任务执行花费多少时间，两个任务间的间隔始终是一致的。","categories":[{"name":"java","slug":"java","permalink":"https://lossingdawn.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://lossingdawn.top/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://lossingdawn.top/tags/spring/"},{"name":"Scheduled","slug":"Scheduled","permalink":"https://lossingdawn.top/tags/Scheduled/"}]},{"title":"Java面试题库(长期)","slug":"50-java面试题库-长期","date":"2018-11-30T01:37:00.000Z","updated":"2019-07-27T17:05:50.383Z","comments":true,"path":"p/zh-CN/12531.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/12531.html","excerpt":"","text":"本文内容来自互联网各种面试实例，以及自己的面试经历，主要是中级开发的面试题初中级java面试主要分为几个部分：0、序1、java基础2、 java多线程3、 jvm知识4、 spring等框架知识5、 常用实践，如session同步6、 其他知识，例如tomcat7、 笔试算法 序言首先，外貌要干净整洁，这个是必须的。其次守时，既不能晚点也不能早到，最好在约定时间的前十分钟面试主要分为几个部分，首先是java基础，这类占比较少；其次是对java及spring框架的的深入理解，如多线程，ioc，apo，spring bean的生命周期，这类占比较重；再往后就是常用的工具的理解，如jvm的常用配置，年轻代老年代，gc，tomcat等容器怎么处理请求，这类问题占比适中；最后就是一些广度的问题(实际的经验)，对自己项目的理解，用到了那些工具，遇到了哪些问题,解决的方法最后，一定要做一些面试的准备，刷面试题、练习面试，建议至少提前一个月做准备，机会是留给有准备的人的 1、java基础1.1、List、Set、Map的异同List(列表)List的元素以线性方式存储，可以存放重复对象，List主要有以下两个实现类：ArrayList长度可变的数组，可以对元素进行随机的访问，向ArrayList中插入与删除元素的速度慢。 JDK8 中ArrayList扩容的实现是通过grow()方法里使用语句newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)（即1.5倍扩容）计算容量，然后调用Arrays.copyof()方法进行对原数组进行复制。LinkedList采用链表数据结构，插入和删除速度快，但访问速度慢。Set(集合)Set中的对象不按特定(HashCode)的方式排序，并且没有重复对象，Set主要有以下两个实现类：HashSet： HashSet按照哈希算法来存取集合中的对象，存取速度比较快。当HashSet中的元素个数超过数组大小/*loadFactor（默认值为0.75）时，就会进行近似两倍扩容（newCapacity = (oldCapacity &lt;&lt; 1) + 1）。TreeSet：TreeSet实现了SortedSet接口，能够对集合中的对象进行排序。Map(映射)Map是一种把键对象和值对象映射的集合，它的每一个元素都包含一个键对象和值对象。 Map主要有以下两个实现类：HashMap：HashMap基于散列表实现，其插入和查询&lt;K,V&gt;的开销是固定的，可以通过构造器设置容量和负载因子来调整容器的性能。LinkedHashMap：类似于HashMap，但是迭代遍历它时，取得&lt;K,V&gt;的顺序是其插入次序，或者是最近最少使用(LRU)的次序。TreeMap：TreeMap基于红黑树实现。查看&lt;K,V&gt;时，它们会被排序。TreeMap是唯一的带有subMap()方法的Map，subMap()可以返回一个子树。比较 List Set Map 继承接口 Collection Collection 常见实现类 AbstractList(其常用子类有ArrayList、LinkedList、Vector) AbstractSet(其常用子类有HashSet、LinkedHashSet、TreeSet) HashMap、HashTable 常见方法 add( )、remove( )、clear( )、get( )、contains( )、size( ) add( )、remove( )、clear( )、contains( )、size( ) put( )、get()、remove( )、clear( )、containsKey( )、containsValue( )、keySet( )、values( )、size( ) 元素 可重复 不可重复(用equals()判断) 不可重复 顺序 有序 无序(实际上由HashCode决定) 线程安全 Vector线程安全 Hashtable线程安全1.2、String、StringBuffer、StringBuilder的使用1.3、HashMap、TreeMap、LinkedHashMap的特点1.4、HashMap内部结构、算法底层实现：HashMap底层整体结构是一个数组，数组中的每个元素又是一个链表。每次添加一个对象（put）时会产生一个链表对象（Object类型），Map中的每个Entry就是数组中的一个元素（Map.Entry就是一个&lt;Key,Value&gt;），它具有由当前元素指向下一个元素的引用，这就构成了链表。存储原理：当向HsahMap中添加元素的时候，先根据HashCode重新计算Key的Hash值，得到数组下标，如果数组该位置已经存在其他元素，那么这个位置的元素将会以链表的形式存放，新加入的放在链头，最先加入的放在链尾，如果数组该位置元素不存在，那么就直接将该元素放到此数组中的该位置。去重原理：不同的Key算到数组下标相同的几率很小，新建一个&lt;K,V&gt;放入到HashMap的时候，首先会计算Key的数组下标，如果数组该位置已经存在其他元素，则比较两个Key，若相同则覆盖写入，若不同则形成链表。读取原理：从HashMap中读取（get）元素时，首先计算Key的HashCode，找到数组下标，然后在对应位置的链表中找到需要的元素。扩容机制：当HashMap中的元素个数超过数组大小/*loadFactor（默认值为0.75）时，就会进行2倍扩容（oldThr &lt;&lt; 1）。1.5、concurrent包下面有那几大类atomiclocksExecutorQueueDueueConcurrentXXScheduledCallableFuture 2、java多线程2.1、lock和synchronizedsynchronized是java中的一个关键字，也就是说是Java语言内置的特性。那么为什么会出现Lock呢？在上面一篇文章中，我们了解到如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；2）线程执行发生异常，此时JVM会让线程自动释放锁。那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。再举个例子：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。但是采用synchronized关键字来实现同步的话，就会导致一个问题：如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。总结一下，也就是说Lock提供了比synchronized更多的功能。但是要注意以下几点：1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。Lock是一个接口，而synchronized是关键字。synchronized会自动释放锁，而Lock必须手动释放锁。Lock可以让等待锁的线程响应中断，而synchronized不会，线程会一直等待下去。通过Lock可以知道线程有没有拿到锁，而synchronized不能。Lock能提高多个线程读操作的效率。synchronized能锁住类、方法和代码块，而Lock是块范围内的第一大不足：由于我们没办法设置synchronized关键字在获取锁的时候等待时间，所以synchronized可能会导致线程为了加锁而无限期地处于阻塞状态。第二大不足：使用synchronized关键字等同于使用了互斥锁，即其他线程都无法获得锁对象的访问权。这种策略对于读多写少的应用而言是很不利的，因为即使多个读者看似可以并发运行，但他们实际上还是串行的，并将最终导致并发性能的下降。虽然synchronized已经作为一个关键字被固化在Java语言中了，但它只提供了一种相当保守的线程安全策略，且该策略开放给程序员的控制能力极弱。2.2、单机上一个线程池正在处理服务，如果忽然断电了怎么办（正在处理和阻塞队列里的请求怎么处理）？2.3、为什么要使用线程池？在Java中，如果每当一个请求到达就创建一个新线程，开销是相当大的。在实际使用中，每个请求创建新线程的服务器在创建和销毁线程上花费的时间和消耗的系统资源，甚至可能要比花在处理实际的用户请求的时间和资源要多得多。除了创建和销毁线程的开销之外，活动的线程也需要消耗系统资源。如果在一个JVM里创建太多的线程，可能会导致系统由于过度消耗内存或“切换过度”而导致系统资源不足。为了防止资源不足，服务器应用程序需要一些办法来限制任何给定时刻处理的请求数目，尽可能减少创建和销毁线程的次数，特别是一些资源耗费比较大的线程的创建和销毁，尽量利用已有对象来进行服务，这就是“池化资源”技术产生的原因。2.4、线程池有什么作用？线程池主要用来解决线程生命周期开销问题和资源不足问题。通过对多个任务重用线程，线程创建的开销就被分摊到了多个任务上了，而且由于在请求到达时线程已经存在，所以消除了线程创建所带来的延迟。这样，就可以立即为请求服务，使应用程序响应更快。另外，通过适当地调整线程池中的线程数目可以防止出现资源不足的情况。1234567891.使用new Thread()创建线程的弊端： 每次通过new Thread()创建对象性能不佳。 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。 缺乏更多功能，如定时执行、定期执行、线程中断。 2.使用Java线程池的好处：重用存在的线程，减少对象创建、消亡的开销，提升性能。 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。 提供定时执行、定期执行、单线程、并发数控制等功能。2.5、说说几种常见的线程池及使用场景。场景：单个任务处理时间短将需处理的任务数量大2.6、线程池都有哪几种工作队列？ArrayBlockingQueue 数组型阻塞队列LinkedBlockingQueue 链表型阻塞队列DelayQueue 延时队列SynchronousQueue 同步队列PriorityBlockingQueue 优先阻塞队列2.7、怎么理解无界队列和有界队列？有界队列：1.初始的poolSize &lt; corePoolSize，提交的runnable任务，会直接做为new一个Thread的参数，立马执行 。2.当提交的任务数超过了corePoolSize，会将当前的runable提交到一个block queue中,。3.有界队列满了之后，如果poolSize &lt; maximumPoolsize时，会尝试new 一个Thread的进行救急处理，立马执行对应的runnable任务。4.如果3中也无法处理了，就会走到第四步执行reject操作。与有界队列相比，除非系统资源耗尽，否则无界的任务队列不存在任务入队失败的情况。当有新的任务到来，系统的线程数小于corePoolSize时，则新建线程执行任务。当达到corePoolSize后，就不会继续增加，若后续仍有新的任务加入，而没有空闲的线程资源，则任务直接进入队列等待。若任务创建和处理的速度差异很大，无界队列会保持快速增长，直到耗尽系统内存。2.8、线程池中的几种重要的参数及流程说明中止：Abort策略，默认策略，新任务提交时直接抛出未检查的异常RejectedExecutionException，该异常可由调用者捕获。抛弃：Discard策略，新提交的任务被抛弃。抛弃最旧的：DiscardOldest策略，队列的是“队头”的任务，然后尝试提交新的任务。（不适合工作队列为优先队列场景）调用者运行： CallerRuns策略，为调节机制，既不抛弃任务也不抛出异常，而是将某些任务回退到调用者。不会在线程池的线程中执行新的任务，而是在调用exector的线程中运行新的任务。2.9、线程池中的几种重要的参数及流程说明123456789public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; ... &#125;corePoolSize池中所保存的线程数，包括空闲线程。需要注意的是在初创建线程池时线程不会立即启动，直到有任务提交才开始启动线程并逐渐时线程数目达到corePoolSize。若想一开始就创建所有核心线程需调用prestartAllCoreThreads方法。maximumPoolSize-池中允许的最大线程数。需要注意的是当核心线程满且阻塞队列也满时才会判断当前线程数是否小于最大线程数，并决定是否创建新线程。keepAliveTime当线程数大于核心时，多于的空闲线程最多存活时间unitkeepAliveTime 参数的时间单位。workQueue当线程数目超过核心线程数时用于保存任务的队列。主要有3种类型的BlockingQueue可供选择：无界队列，有界队列和同步移交。将在下文中详细阐述。从参数中可以看到，此队列仅保存实现Runnable接口的任务。threadFactory执行程序创建新线程时使用的工厂。handler阻塞队列已满且线程数达到最大值时所采取的饱和策略。java默认提供了4种饱和策略的实现方式：中止、抛弃、抛弃最旧的、调用者运行。将在下文中详细阐述。2.10、线程和cpu核心数的关系线程数=Ncpu / (1-阻塞系数)IO密集型，阻塞系数接近于1计算密集型，阻塞系数接近于0 3、jvm知识3.1、happened-before原则1.程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作2.监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁3.volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读4.传递性：如果A happens-before B，且B happens-before C，那么A happens-before C5.start规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作6.join规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回3.2、类的加载https://blog.csdn.net/wen7280/article/details/53856790类装载的条件：Java虚拟机不会无条件的装载Class类型。Java虚拟机规定：一个类或者接口在初次使用时，必须进行初始化。这里的使用指的是主动使用，主动使用有以下几种情况：当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化方式。当调用类的静态方法时，即当使用了字节码invokestatic指令当使用类或者接口的静态字段时（final常量除外，此种情况只会加载类而不会进行初始化），即使用getstatic或者putstatic指令（可以使用jclasslib软件查看生成的字节码文件）当使用java.lang.reflect包中的方法反射类的方法时当初始化子类时，必须先初始化父类作为启动虚拟机、含有main方法的那个类除了以上情况属于主动使用外，其他情况均属于被动使用，被动使用不会引起类的初始化，只是加载了类却没有初始化。 4、spring等框架知识4.1、spring mvc处理请求SpringMVC核心处理流程：1、DispatcherServlet前端控制器接收发过来的请求，交给HandlerMapping处理器映射器2、HandlerMapping处理器映射器，根据请求路径找到相应的HandlerAdapter处理器适配器（处理器适配器就是那些拦截器或Controller）3、HandlerAdapter处理器适配器，处理一些功能请求，返回一个ModelAndView对象（包括模型数据、逻辑视图名）4、ViewResolver视图解析器，先根据ModelAndView中设置的View解析具体视图5、然后再将Model模型中的数据渲染到View上4.2、Springbootapplication注解的原理http://majunwei.com/view/201708231840127244.html 5、常用实践,session同步5.1、session同步使用redis作为session持久化存储。首先用户连接进来，把session放在本地一份，redis一份，在本地有记录的情况下使用本地缓存(设置极小的时间过期，如2s)。当用户再次连接进来，在本地记录过期，或者本地没有session的情况下，使用redis的记录，5.2、redis的简单介绍5.3、缓存的使用 6、其他知识,如tomcat6.1、tomcat如何处理请求Tomcat的两个核心组件：Connector 和 Container1.Connector组件Connector组件将在某个指定的端口上侦听客户请求，接收浏览器发过来的tcp连接请求，创建一个Request和一个Response对象分别用于和其你去端交换数据，然后会产生一个线程来处理这个请求并把产生的Request和Response对象传给Engine，从Engine中获得响应并返回给客户端。Tomcat有两个经典的Connector，一个直接侦听来自浏览器的HTTP请求，另外一个侦听来自其他的WebServer的请求。Cotote HTTP/1.1 Connector在端口8080处侦听来自客户浏览器的HTTP请求，Coyote JK2 Connector在端口8009处侦听其他WebServer的Servlet/JSP请求。 Connector 最重要的功能就是接收连接请求然后分配线程让 Container来处理这个请求，所以这必然是多线程的，多线程的处理是 Connector 设计的核心2.Container组件Container组件的体系结构如下：ContainerContainer是容器的父接口，该容器的设计用的是典型的责任链的设计模式，它由四个自容器组件构成，分别是Engine、Host、Context、Wrapper。这四个组件是负责关系，存在包含关系。通常一个Servlet class对应一个Wrapper，如果有多个Servlet则定义多个Wrapper，如果有多个Wrapper就要定义一个更高的Container，如Context。 Context定义在父容器 Host 中，其中Host 不是必须的，但是要运行 war 程序，就必须要 Host，因为 war 中必有 web.xml 文件，这个文件的解析就需要 Host 了，如果要有多个 Host 就要定义一个 top 容器 Engine 了。而 Engine 没有父容器了，一个 Engine 代表一个完整的 Servlet 引擎。EngineEngine 容器比较简单，它只定义了一些基本的关联关系 Host 容器HostHost 是 Engine 的字容器，一个 Host 在 Engine 中代表一个虚拟主机，这个虚拟主机的作用就是运行多个应用，它负责安装和展开这些应用，并且标识这个应用以便能够区分它们。它的子容器通常是 Context，它除了关联子容器外，还有就是保存一个主机应该有的信息。ContextContext 代表 Servlet 的 Context，它具备了 Servlet 运行的基本环境，理论上只要有 Context 就能运行 Servlet 了。简单的 Tomcat 可以没有 Engine 和 Host。Context 最重要的功能就是管理它里面的 Servlet 实例，Servlet 实例在 Context 中是以 Wrapper 出现的，还有一点就是 Context 如何才能找到正确的 Servlet 来执行它呢？ Tomcat5 以前是通过一个 Mapper 类来管理的，Tomcat5 以后这个功能被移到了 request 中，在前面的时序图中就可以发现获取子容器都是通过 request 来分配的WrapperWrapper 代表一个 Servlet，它负责管理一个 Servlet，包括的 Servlet 的装载、初始化、执行以及资源回收。Wrapper 是最底层的容器，它没有子容器了，所以调用它的 addChild 将会报错。 Wrapper 的实现类是 StandardWrapper，StandardWrapper 还实现了拥有一个 Servlet 初始化信息的 ServletConfig，由此看出 StandardWrapper 将直接和 Servlet 的各种信息打交道。说明：除了上述组件外，Tomcat中还有其他重要的组件，如安全组件security、logger日志组件、session、mbeans、naming等其他组件。这些组件共同为Connector和Container提供必要的服务。完整请求过程如下：1.用户在浏览器中输入网址localhost:8080/test/index.jsp，请求被发送到本机端口8080，被在那里监听的Coyote HTTP/1.1 Connector获得；2.Connector把该请求交给它所在的Service的Engine（Container）来处理，并等待Engine的回应；3.Engine获得请求localhost/test/index.jsp，匹配所有的虚拟主机Host；4.Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机），名为localhost的Host获得请求/test/index.jsp，匹配它所拥有的所有Context。Host匹配到路径为/test的Context（如果匹配不到就把该请求交给路径名为“ ”的Context去处理）；5.path=“/test”的Context获得请求/index.jsp，在它的mapping table中寻找出对应的Servlet。Context匹配到URL Pattern为/*.jsp的Servlet，对应于JspServlet类；6.构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet()或doPost(),执行业务逻辑、数据存储等；7.Context把执行完之后的HttpServletResponse对象返回给Host；8.Host把HttpServletResponse对象返回给Engine；9.Engine把HttpServletResponse对象返回Connector；10.Connector把HttpServletResponse对象返回给客户Browser。 7、笔试算法7.1、7.2、7.3、7.4、让您做一个电商平台，您如何设置一个在买家下订单后的”第60秒“发短信通知卖家发货，您需要考虑的是 像淘宝一样的大并发量的订单。1、具有排序功能的队列2、Redis+定时器3、队列，死信参考地址：https://mp.weixin.qq.com/s/Dzv-i8n7waJVac-N7MJCvA","categories":[{"name":"面试","slug":"面试","permalink":"https://lossingdawn.top/categories/面试/"}],"tags":[{"name":"java, 面试","slug":"java-面试","permalink":"https://lossingdawn.top/tags/java-面试/"}]},{"title":"RSA Premaster Secret Error 错误解决","slug":"80-RSA-premaster-secret-error-错误解决","date":"2018-09-13T06:57:00.000Z","updated":"2019-07-27T17:06:17.493Z","comments":true,"path":"p/zh-CN/18860.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/18860.html","excerpt":"","text":"报错信息如下：Caused by: com.microsoft.sqlserver.jdbc.SQLServerException: 驱动程序无法使用安全套接字层(SSL)加密与 SQL Server 建立安全连接。错误: RSA premaster secret error。java连接sqlserver报RSA私钥错误，在网上查询了一番基本是这两个解决方案1、调整jdk的引用2、把sunjce_provider.jar放到\\jre\\lib\\ext下我的问题是由于jdk的问题，gradle编译自动吧jdk换成了JavaSE，换成本地的JDK1.8，问题解决问题原因由于gradle插件编译的问题，自动调整为java SE版本，导致引用问题，maven编译后虽然也是java SE版本，但是没有问题还是要少用gradle参考：https://blog.csdn.net/huang9012/article/details/6629775https://social.msdn.microsoft.com/Forums/sqlserver/zh-CN/031c5b4c-0871-4f12-a163-ce547035740c/error-connecting-to-mssql-via-jdbc-through-a-window-service?forum=sqldataaccess","categories":[{"name":"java","slug":"java","permalink":"https://lossingdawn.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://lossingdawn.top/tags/java/"}]},{"title":"我的众安面试经历（题库）","slug":"50-我的众安面试经历（题库）","date":"2018-09-01T03:02:00.000Z","updated":"2019-07-27T17:07:10.014Z","comments":true,"path":"p/zh-CN/35012.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/35012.html","excerpt":"","text":"面试众安在线背景：两年java，面中级开发首先，是两道编程题，笔试1、斐波那契数列，f(n)=f(n-1)+f(n-2)，n足够大，获取f(n)的值~2、一个足够大的数组，有10E+个数字，怎么快速找到前10大的数字，时间复杂度是多少~接着，面试官开始提问了最近，华住数据泄漏事件知道吧~有一篇分析贴看了吧，假如你拿到了这些数据，你会从哪些方面去分析，拿到这些数据你会做什么，你有什么措施来防止这次的事件~加密算法，对称与非对称，~对于多线程的理解，多线程有什么优势~单核cpu如何执行多线程~多线程后台任务怎么保证任务完成了~执行时间长于执行周期的问题，例如每一秒执行一次，执行一次需要三秒~一个线程占用多少资源~支付过程加密用哪种~TCP/UDP的区别~spring的设计模式~IOC、AOP的理解~多进程与多线程的区别~tomcat处理请求，对于线程进程的关系~tomcat处理请求的生命周期~讲一讲你们微服务是怎么搭建的，是按什么划分的，中间有经历什么~暂时就想起来这么多，后面有回忆起立的再补充最后，对面试官有什么要问的？微服务架构：hsf框架，加少量的dubbo和spring could考核的标准：业务完成情况、难易度，价值观，对新人的帮助，组内的沟通情况等等","categories":[{"name":"面试","slug":"面试","permalink":"https://lossingdawn.top/categories/面试/"}],"tags":[{"name":"java","slug":"java","permalink":"https://lossingdawn.top/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://lossingdawn.top/tags/面试/"}]},{"title":"图片转字符图片（三）","slug":"150-图片转字符图片（三）","date":"2018-08-20T17:11:00.000Z","updated":"2019-08-26T13:17:32.036Z","comments":true,"path":"p/zh-CN/48068.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/48068.html","excerpt":"","text":"序言这个是从抖音上学来的，一开始刷抖音，遇到不少字符串跳舞的视频，因此来实践一下 主要分为三个部分静态图片转静态图片gif转gif视频转视频 视频转视频主要用到了FFmpeg这个工具，利用命令对视频文件进行操作。首先根据自己调的参数进行图片的截取（本文的是1秒10帧的参数），图片转换，然后分离音频，最后字符图片和音频合成目标视频。FFmpeg的代码库：https://github.com/FFmpeg/FFmpegFFmpeg下载地址：https://ffmpeg.org/download.html 效果如下没做细致的调整，视频的转换可以调调参数测试代码12345678@Testpublic static void videoTest() &#123; String srcVideoPath = \"F:/123/123.mp4\"; String tarImagePath = \"F:/123/mp/\"; String tarAudioPath = \"F:/123/mp/audio.aac\"; String tarVideoPath = \"F:/123/1234.mp4\"; VideoUtil.readVideo(srcVideoPath,tarImagePath,tarAudioPath,tarVideoPath);&#125; 代码如下主要用到的几个命令，其他按帧截图命令参考文末链接4：123456// 截图ffmpeg -ss 10 -i input.flv -y -f image2 -vframes 100 -s 352x240 b-%03d.jpg// 分离音频ffmpeg -i 3.mp4 -vn -y -acodec copy 3.aac// 合成视频ffmpeg -threads2 -y -r 10 -i /tmpdir/image%04d.jpg -i audio.mp3 -absf aac_adtstoasc output.mp4环境：JDK 1.8123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196// ffmpeg -ss 10 -i input.flv -y -f image2 -vframes 100 -s 352x240 b-%03d.jpg /** * ffmpeg 截图，并指定图片的大小 * * @param srcVideoPath * @param tarImagePath * 截取后图片路径 * @param width * 截图的宽 * @param hight * 截图的高 * @param offsetValue * 表示相对于文件开始处的时间偏移值 可以是分秒 * @param vframes * 表示截图的桢数 * * @return */ public static boolean processFfmpegImage(String srcVideoPath, String tarImagePath, int width, int hight, float offsetValue, float vframes) &#123; if (!checkfile(srcVideoPath)) &#123; System.out.println(\"【\" + srcVideoPath + \"】 不存在 !\"); // logger.error(\"【\" + srcVideoPath + \"】 不存在 !\"); return false; &#125; List&lt;String&gt; commend = new java.util.ArrayList&lt;String&gt;(); commend.add(ffmpegPath); commend.add(\"-i\"); commend.add(srcVideoPath); commend.add(\"-y\"); commend.add(\"-f\"); commend.add(\"image2\"); commend.add(\"-ss\"); commend.add(offsetValue + \"\"); // 在视频的某个插入时间截图，例子为5秒后 // commend.add(\"-vframes\"); commend.add(\"-t\");// 添加参数＂-t＂，该参数指定持续时间 commend.add(vframes + \"\"); // 截图的桢数,添加持续时间为1毫秒 commend.add(\"-s\"); commend.add(width + \"x\" + hight); // 截图的的大小 commend.add(tarImagePath); try &#123; ProcessBuilder builder = new ProcessBuilder(); builder.command(commend); builder.redirectErrorStream(true); // builder.redirectOutput(new File(\"F:/123/log/log.log\")); Process process = builder.start(); doWaitFor(process); process.destroy(); if (!checkfile(tarImagePath)) &#123; System.out.println(tarImagePath + \" is not exit! processFfmpegImage 转换不成功 !\"); // logger.info(tarImagePath + \" is not exit! processFfmpegImage // 转换不成功 !\"); return false; &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println(\"【\" + srcVideoPath + \"】 processFfmpegImage 转换不成功 !\"); // logger.error(\"【\" + srcVideoPath + \"】 processFfmpegImage 转换不成功 // !\"); return false; &#125; &#125; public static boolean processFfmpegAudio(String srcVideoPath, String tarAudioPath) &#123; if (!checkfile(srcVideoPath)) &#123; System.out.println(\"【\" + srcVideoPath + \"】 不存在 !\"); // logger.error(\"【\" + srcVideoPath + \"】 不存在 !\"); return false; &#125; // https://blog.csdn.net/xiaocao9903/article/details/53420519 // ffmpeg -i 3.mp4 -vn -y -acodec copy 3.aac // ffmpeg -i 3.mp4 -vn -y -acodec copy 3.m4a List&lt;String&gt; commend = new java.util.ArrayList&lt;String&gt;(); commend.add(ffmpegPath); commend.add(\"-i\"); commend.add(srcVideoPath); commend.add(\"-vn\"); commend.add(\"-y\"); commend.add(\"-acodec\"); commend.add(\"copy\"); // 在视频的某个插入时间截图，例子为5秒后 commend.add(tarAudioPath); try &#123; ProcessBuilder builder = new ProcessBuilder(); builder.command(commend); builder.redirectErrorStream(true); Process process = builder.start(); doWaitFor(process); process.destroy(); if (!checkfile(tarAudioPath)) &#123; System.out.println(tarAudioPath + \" is not exit! processFfmpegAudio 转换不成功 !\"); return false; &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println(\"【\" + srcVideoPath + \"】 processFfmpegAudio 转换不成功 !\"); return false; &#125; &#125; /** * ffmpeg 合成视频 * * @param srcVideoPath * @param tarImagePath * 截取后图片路径 * @param width * 截图的宽 * @param hight * 截图的高 * @param offsetValue * 表示相对于文件开始处的时间偏移值 可以是分秒 * @param vframes * 表示截图的桢数 * * @return */ public static boolean processFfmpegVideo(String imagePath, String audioPath, String tarVideoPath, int step) &#123; // https://blog.csdn.net/wangshuainan/article/details/77914508?fps=1&amp;locationNum=4 // 带音频 // ffmpeg -threads2 -y -r 10 -i /tmpdir/image%04d.jpg -i audio.mp3 -absf // aac_adtstoasc output.mp4 List&lt;String&gt; commend = new java.util.ArrayList&lt;String&gt;(); commend.add(ffmpegPath); commend.add(\"-threads\"); commend.add(\"2\"); commend.add(\"-y\"); commend.add(\"-r\"); commend.add(step + \"\"); commend.add(\"-i\"); commend.add(imagePath); // 图片 commend.add(\"-i\"); commend.add(audioPath); commend.add(\"-absf\");// commend.add(\"aac_adtstoasc\"); // commend.add(tarVideoPath); try &#123; ProcessBuilder builder = new ProcessBuilder(); builder.command(commend); builder.redirectErrorStream(true); builder.redirectOutput(new File(\"F:/123/log/log.log\")); Process process = builder.start(); doWaitFor(process); process.destroy(); if (!checkfile(tarVideoPath)) &#123; System.out.println(tarVideoPath + \" is not exit! processFfmpegVideo 转换不成功 !\"); return false; &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println(\"【\" + tarVideoPath + \"】 processFfmpegVideo 转换不成功 !\"); return false; &#125; &#125;源码地址：https://github.com/Ruffianjiang/java4fun/tree/master/img2text参考：https://blog.csdn.net/i_likechard/article/details/79032931https://blog.csdn.net/xiaocao9903/article/details/53420519https://blog.csdn.net/wangshuainan/article/details/77914508?fps=1&amp;locationNum=4https://blog.csdn.net/yourijing/article/details/50786758","categories":[{"name":"java","slug":"java","permalink":"https://lossingdawn.top/categories/java/"},{"name":"fun","slug":"java/fun","permalink":"https://lossingdawn.top/categories/java/fun/"}],"tags":[{"name":"java","slug":"java","permalink":"https://lossingdawn.top/tags/java/"},{"name":"fun","slug":"fun","permalink":"https://lossingdawn.top/tags/fun/"}]},{"title":"图片转字符图片（二）","slug":"150-图片转字符图片（二）","date":"2018-08-20T16:23:00.000Z","updated":"2019-08-26T13:14:45.749Z","comments":true,"path":"p/zh-CN/10184.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/10184.html","excerpt":"","text":"序言这个是从抖音上学来的，一开始刷抖音，遇到不少字符串跳舞的视频，因此来实践一下 主要分为三个部分静态图片转静态图片gif 转 gif视频转视频 gif 转 gif原理和静态图片的转换类似，这个需要每一帧的去转换。一开始的思路是把gif的每一帧转为图片，然后对图片进行转换，最后合成 gif 。研究了 img4java，效果如下所示：测试代码：123456789@Testpublic static void gifTest() &#123; String srcFile = \"F:/123/123.gif\"; String targetFile = \"F:/123/123_04.gif\"; String base = \"01\"; // 替换的字符串 // String base = \"@#&amp;$%*o!;.\";// 字符串由复杂到简单 int threshold = 3;// 阈值 GifUtil.toTextGif(srcFile, targetFile, base, threshold);&#125; 参考：https://blog.csdn.net/DamonRush/article/details/51746995、https://blog.csdn.net/weiwangchao_/article/details/46520571，还有一些其他的工具（用了私有api，不推荐）http://zhaorui1125.iteye.com/blog/2116816，最后发现他们截出来的每一张图要么发红，要么模糊，只好放弃了。最后发现不需要把每一帧都保存下来，临时存一下就好，具体代码如下： 环境：JDK 1.8 完整代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.image.BufferedImage;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import com.dawn.img2text.external.AnimatedGifEncoder;import com.dawn.img2text.external.GifDecoder;/** * @ClassName: GifUtil * @Description: TODO * @author jiang * @date 2018年8月14日 下午9:47:29 * */public class GifUtil &#123; static Logger logger = LoggerFactory.getLogger(GifUtil.class); public static boolean toTextGif(final String srcFile, final String targetFile, final String base, int threshold) &#123; long startTime = System.currentTimeMillis(); try &#123; GifDecoder gd = new GifDecoder(); // 要处理的图片 int status = gd.read(new FileInputStream(new File(srcFile))); if (status != GifDecoder.STATUS_OK) &#123; return false; &#125; // AnimatedGifEncoder ge = new AnimatedGifEncoder(); // 这里是关键，设置要替换成透明的颜色 ge.setTransparent(Color.WHITE); // ge.start(new FileOutputStream(new File(targetFile))); ge.setRepeat(0); for (int i = 0; i &lt; gd.getFrameCount(); i++) &#123; // 取得gif的每一帧 BufferedImage frame = gd.getFrame(i); // 你可以对每一帧做点什么，比如缩放什么的，这里就什么都不做了 int[] rgb = new int[3]; int width = frame.getWidth(); int height = frame.getHeight(); int minx = frame.getMinX(); int miny = frame.getMinY(); int delay = gd.getDelay(i); BufferedImage tag = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR); Graphics g = tag.getGraphics(); g.setFont(new Font(\"微软雅黑\", Font.PLAIN, 2));// 设置字体 g.setColor(Color.BLACK);// 设置颜色 for (int x = minx; x &lt; width; x += 1) &#123; for (int y = miny; y &lt; height; y += 1) &#123; int pixel = frame.getRGB(x, y); // 下面三行代码将一个数字转换为RGB数字 rgb[0] = (pixel &amp; 0xff0000) &gt;&gt; 16;// red rgb[1] = (pixel &amp; 0xff00) &gt;&gt; 8;// green rgb[2] = (pixel &amp; 0xff);// blue final float gray = 0.299F * rgb[0] + 0.578F * rgb[1] + 0.114F * rgb[2]; // index [0,base.length()),index越小颜色越深 final int index = Math.round(gray * (base.length() + 1) / 255); if (index &lt;= base.length() % threshold) &#123; g.drawString(String.valueOf(base.charAt(index % base.length())), x, y);// 文字的编写及位置 &#125; /*- if (rgb[0] + rgb[1] + rgb[2] &lt;= 300) &#123; g.drawString(String.valueOf(base.charAt(index % base.length())), x, y);// 文字的编写及位置 &#125;*/ &#125; &#125; ge.setDelay(delay); ge.addFrame(tag); &#125; // 输出图片 ge.finish(); logger.debug(\"&#123;&#125; toTextGif cost time： &#123;&#125;s\", srcFile, System.currentTimeMillis() - startTime); &#125; catch (Exception e) &#123; logger.error(\"err\", e); return false; &#125; return true; &#125;&#125;原理和静态图转字符图片是一致，不再累述。源码地址：https://github.com/Ruffianjiang/java4fun/tree/master/img2text","categories":[{"name":"java","slug":"java","permalink":"https://lossingdawn.top/categories/java/"},{"name":"fun","slug":"java/fun","permalink":"https://lossingdawn.top/categories/java/fun/"}],"tags":[{"name":"java","slug":"java","permalink":"https://lossingdawn.top/tags/java/"},{"name":"fun","slug":"fun","permalink":"https://lossingdawn.top/tags/fun/"}]},{"title":"图片转字符图片（一）","slug":"150-图片转字符图片（一）","date":"2018-08-20T16:02:00.000Z","updated":"2019-08-26T13:12:25.756Z","comments":true,"path":"p/zh-CN/10183.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/10183.html","excerpt":"","text":"序言这个是从抖音上学来的，一开始刷抖音，遇到不少字符串跳舞的视频，因此来实践一下 主要分为三个部分静态图片转静态图片gif转gif视频转视频 静态图片转静态图片其实原理很简单，读取图片的像素，新建一张大小一样的图片，根据原图像素的灰度，决定是不是要显示出来，并在新图相应的位置添加字符，这样就完成了先来看下效果图，如下 代码实现借助前辈写的工具，主要包含一下四个类：AnimatedGifEncoderGifDecoderLZWEncoderNeuQuant源地址:https://github.com/rtyley/animated-gif-lib-for-javaps: 网上各种版本的太多，不清楚这个是不是原作者，github上搜GifDecoder 环境：JDK 1.8注：Java原生代码实现使用jdk内部的GIFImageReader、GIFImageWriter等类，maven在编译的时候会提示这是sun公司的私有API，在1.7、1.8版的JDK中已经删除，所以是有风险的。在此使用ImageIO这个类来进行图片的操作。测试代码：123456789@Testpublic static void imgTest() String inputFile = \"F:/123/head.png\"; String outputFile = \"F:/123/head_copy.png\"; // String base = \"01\"; // 替换的字符串 String base = \"@#&amp;$%*o!;.\";// 字符串由复杂到简单 int threshold = 8;// 阈值 ImgUtil.toTextImg(inputFile, outputFile, base, threshold);&#125;具体参数调整如下图所示：调整字符大小，颜色调整字符间距调整字符的区域 （index数值越小，灰度越大）完整代码如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.image.BufferedImage;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import javax.imageio.ImageIO;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * @ClassName: ImgUtil * @Description: TODO * @author jiang * @date 2018年8月14日 下午10:15:56 * */public class ImgUtil &#123; static Logger logger = LoggerFactory.getLogger(ImgUtil.class); public static boolean toTextImg(String inputFile, String outputFile, final String base, int threshold) &#123;// String blackFile = \"F:/123/head_black.png\"; BufferedImage src = null; BufferedImage tag = null; boolean res = false; try &#123; src = ImageIO.read(new FileInputStream(inputFile)); int[] rgb = new int[3]; int width = src.getWidth(); int height = src.getHeight(); int minx = src.getMinX(); int miny = src.getMinY(); // 黑白化/*- src = new ColorConvertOp(ColorSpace.getInstance(ColorSpace.CS_GRAY), null).filter(src, null); res = ImageIO.write(src, blackFile.substring(blackFile.lastIndexOf(\".\") + 1), new File(blackFile)); src = ImageIO.read(new FileInputStream(blackFile));*/ tag = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR); Graphics g = tag.getGraphics(); g.setFont(new Font(\"微软雅黑\", Font.PLAIN, 10));// 设置字体 g.setColor(Color.BLUE);// 设置颜色 for (int x = minx; x &lt; width; x += 6) &#123; for (int y = miny; y &lt; height; y += 6) &#123; int pixel = src.getRGB(x, y); // 下面三行代码将一个数字转换为RGB数字 rgb[0] = (pixel &amp; 0xff0000) &gt;&gt; 16;// red rgb[1] = (pixel &amp; 0xff00) &gt;&gt; 8;// green rgb[2] = (pixel &amp; 0xff);// blue final float gray = 0.299f * rgb[0] + 0.578f * rgb[1] + 0.114f * rgb[2]; final int index = Math.round(gray * (base.length() + 1) / 255);// logger.debug(\"&#123;&#125;,&#123;&#125;\",index,base.length() / threshold); if (index &lt;= threshold) &#123; g.drawString(String.valueOf(base.charAt(index % base.length())), x, y);// 文字的编写及位置 &#125; /*- if (rgb[0] + rgb[1] + rgb[2] &lt;= 500) &#123; System.out.println(\"i=\" + i + \",j=\" + j + \":(\" + rgb[0] + \",\" + rgb[1] + \",\" + rgb[2] + \")\"); g.drawString(\"v\", i, j);// 文字的编写及位置 &#125;*/ &#125; &#125; g.dispose(); // 输出图片 res = ImageIO.write(tag, outputFile.substring(outputFile.lastIndexOf(\".\") + 1), new File(outputFile)); logger.debug(\"字符化结果：&#123;&#125;\", res); &#125; catch (IOException e) &#123; logger.error(\"err\", e); return false; &#125; return true; &#125;&#125;代码的思路很简单，src.getRGB(x, y)获取具体像素点的颜色值，共六位，每两位一个颜色值，依次是red、green、blue,类似的使用1(pixel &amp; 0xff0000) &gt;&gt; 16获取第一位的红色等，根据灰度公式1Gray = R/*0.299 + G/*0.587 + B/*0.114计算灰度（百度颜色灰度公式，有很多来计算心理灰度的解决方案），选择合适的灰度替换上合适的字符即可源码地址：https://github.com/Ruffianjiang/java4fun/tree/master/img2text参考：https://blog.csdn.net/chwshuang/article/details/64923345","categories":[{"name":"java","slug":"java","permalink":"https://lossingdawn.top/categories/java/"},{"name":"fun","slug":"java/fun","permalink":"https://lossingdawn.top/categories/java/fun/"}],"tags":[{"name":"java","slug":"java","permalink":"https://lossingdawn.top/tags/java/"},{"name":"fun","slug":"fun","permalink":"https://lossingdawn.top/tags/fun/"}]},{"title":"Github访问不到，登陆不上","slug":"15-github访问不到，登陆不上","date":"2018-06-10T05:50:00.000Z","updated":"2019-07-27T17:04:49.076Z","comments":true,"path":"p/zh-CN/61789.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/61789.html","excerpt":"","text":"为github添加host1C:\\WINDOWS\\System32\\drivers\\etc在host文件添加如下两行12192.30.253.112 github.com151.101.113.194 github.global.SSL.fastly.net再次 ping github.com 解析后的ip就会强制指向host中的ip注1：host文件修改需要权限，建议使用 nodepad++ ，保存后会自动要求管理员权限，再次保存即可注2：关于IP的选择，可以去 站长工具 去查参考：https://blog.csdn.net/wl_521/article/details/80154063","categories":[{"name":"github","slug":"github","permalink":"https://lossingdawn.top/categories/github/"}],"tags":[{"name":"github","slug":"github","permalink":"https://lossingdawn.top/tags/github/"}]},{"title":"Jdk安装错误1316，jdk-10.0.1","slug":"20-jdk安装错误1316，jdk-10-0-1","date":"2018-05-24T16:50:00.000Z","updated":"2019-07-27T17:05:59.486Z","comments":true,"path":"p/zh-CN/49489.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/49489.html","excerpt":"","text":"打开注册表regedit ，定个位到计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\JavaSoft\\把jdk，jre下面的目录删掉。即10.0.1 ，问题解决参考：https://blog.csdn.net/lesorb/article/details/4389626","categories":[{"name":"java","slug":"java","permalink":"https://lossingdawn.top/categories/java/"},{"name":"jdk","slug":"java/jdk","permalink":"https://lossingdawn.top/categories/java/jdk/"}],"tags":[{"name":"java","slug":"java","permalink":"https://lossingdawn.top/tags/java/"},{"name":"jdk","slug":"jdk","permalink":"https://lossingdawn.top/tags/jdk/"}]},{"title":"Windows安装mongodb","slug":"5-windows安装mongodb","date":"2018-05-23T15:44:00.000Z","updated":"2019-07-27T17:06:41.290Z","comments":true,"path":"p/zh-CN/13792.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/13792.html","excerpt":"","text":"一、资源mongo下载地址：https://www.mongodb.com/download-center/#communityromongo下载：https://robomongo.org/如下三个文件，（mongodb-compass可以不用下在，这是管理mongo用的图形化界面，习惯用romongo查询，studio3t可以自己学习使用）安装好以上软件，我本地的mongo安装到了d:tools\\mongo 目录下，新建两个目录用于存储数据和日志d:\\tools\\data\\db 和 d:\\tools\\data\\log 二、初始化工作在命令行使用命令：12345启动脚本D:\\tools\\mongo\\bin\\mongod --dbpath D:\\tools\\data\\db连接脚本D:\\tools\\mongo\\bin\\mongo.exe出现 waiting for connetions on port 27017 ，则表示启动成功，ctrl+c可以关闭使用连接脚本连接数据库（新开一个命令行）启动数据库命令行出现如下连接者的信息，连接成功使用mongodb compass连接romongo连接后面主要使用romongo进行数据的查询，其中三种视图的切换 三、mongo的配置配置 MongoDB 服务创建一个配置文件位于 D:\\tools\\mongo\\mongod.cfg具体内容如下：12345systemLog:destination: filepath: D:\\tools\\data\\log\\mongod.logstorage:dbPath: D:\\tools\\data\\db安装 MongoDB服务1D:\\tools\\mongo\\bin\\mongod.exe --config \"D:\\tools\\mongo\\mongod.cfg\" --install命令行需要管理员权限，没使用管理员权限的出现如下log信息安装完成log信息如下：在服务里可以找到MongoBD的服务启动MongoDB服务1net start MongoDB关闭MongoDB服务1net stop MongoDB移除 MongoDB 服务1C:\\mongodb\\bin\\mongod.exe --remove其他的信息自行摸索吧，现在可以愉快的使用mongo了参考：http://www.runoob.com/mongodb/mongodb-window-install.html","categories":[{"name":"db","slug":"db","permalink":"https://lossingdawn.top/categories/db/"},{"name":"mongo","slug":"db/mongo","permalink":"https://lossingdawn.top/categories/db/mongo/"}],"tags":[{"name":"mongo","slug":"mongo","permalink":"https://lossingdawn.top/tags/mongo/"}]},{"title":"Eclipse中Cannot Nest Src Folder解决方法","slug":"6-Eclipse中Cannot-nest-src-folder解决方法","date":"2018-04-25T01:04:00.000Z","updated":"2019-07-27T17:04:13.047Z","comments":true,"path":"p/zh-CN/61671.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/61671.html","excerpt":"","text":"错误示例：1: Java Model Status [Cannot nest output folder 'xxx/bin/main' inside output folder 'xxx/bin']解决方法：右击项目 -&gt; properties -&gt; java build path -&gt; source一般是上图的红框的问题，这个已经改过的，报错的时候，是一个还未新建的文件夹目录/bin/main，解决方案如下图所示：第一种就是把allow output folders xxx 的勾选去掉第二种不去勾选，把default output folder目录改到bin目录另外一种参考方法：https://blog.csdn.net/sinat_30397435/article/details/78522566","categories":[{"name":"ide","slug":"ide","permalink":"https://lossingdawn.top/categories/ide/"},{"name":"eclipse","slug":"ide/eclipse","permalink":"https://lossingdawn.top/categories/ide/eclipse/"}],"tags":[{"name":"ide","slug":"ide","permalink":"https://lossingdawn.top/tags/ide/"},{"name":"eclipse","slug":"eclipse","permalink":"https://lossingdawn.top/tags/eclipse/"}]},{"title":"restTemplate重定向问题 &Cookie问题","slug":"100-restTemplate重定向问题-cookie问题","date":"2018-04-20T07:44:00.000Z","updated":"2019-07-27T17:06:14.728Z","comments":true,"path":"p/zh-CN/20555.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/20555.html","excerpt":"","text":"最近在做一个转发功能，zuul + ribbon + resttemplate 进行路由、负载、转发的功能基本准备就绪，在微信自动登陆那遇到了一个坑，ribbon 系统用resttemplate 转发A系统的资源，在微信自动登陆的地方，A系统重定向到微信的地址，类似下面的代码1redirect: https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx3290f3d5****&amp;redirect_uri=http://***.com/weixin/wxAuthRedirect?redirectUrl=http%3A%2F%2F192.168.10.116%3A8081%2Finternal%2Fpage%2Fuser%2Flogin_wx&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=state#wechat_redirect结果resttemplate 自动重定向到本地的地址，如下所示：1http://192.168.10.116:**/connect/oauth2/authorize**仔细思考了下，大概就是resttemplate 的重定向问题，查了查资料，找到一个类HttpComponentsClientHttpRequestFactory，RestTemplate初始化提供了这个类的参数12345678910/** * Create a new instance of the &#123;@link RestTemplate&#125; based on the given &#123;@link ClientHttpRequestFactory&#125;. * @param requestFactory HTTP request factory to use * @see org.springframework.http.client.SimpleClientHttpRequestFactory * @see org.springframework.http.client.HttpComponentsClientHttpRequestFactory */ public RestTemplate(ClientHttpRequestFactory requestFactory) &#123; this(); setRequestFactory(requestFactory); &#125;HttpComponentsClientHttpRequestFactory继承自ClientHttpRequestFactory，这个类的子类有HttpComponentsClientHttpRequestFactory和SimpleClientHttpRequestFactory找到SimpleClientHttpRequestFactory，有如下方法：第一种方式：12345678910111213141516171819202122232425262728293031323334/** * Template method for preparing the given &#123;@link HttpURLConnection&#125;. * &lt;p&gt;The default implementation prepares the connection for input and output, and sets the HTTP method. * @param connection the connection to prepare * @param httpMethod the HTTP request method (&#123;@code GET&#125;, &#123;@code POST&#125;, etc.) * @throws IOException in case of I/O errors */ protected void prepareConnection(HttpURLConnection connection, String httpMethod) throws IOException &#123; if (this.connectTimeout &gt;= 0) &#123; connection.setConnectTimeout(this.connectTimeout); &#125; if (this.readTimeout &gt;= 0) &#123; connection.setReadTimeout(this.readTimeout); &#125; connection.setDoInput(true); if (\"GET\".equals(httpMethod)) &#123; connection.setInstanceFollowRedirects(true); &#125; else &#123; connection.setInstanceFollowRedirects(false); &#125; if (\"POST\".equals(httpMethod) || \"PUT\".equals(httpMethod) || \"PATCH\".equals(httpMethod) || \"DELETE\".equals(httpMethod)) &#123; connection.setDoOutput(true); &#125; else &#123; connection.setDoOutput(false); &#125; connection.setRequestMethod(httpMethod); &#125;可以看到setInstanceFollowRedirects，get请求是可以重定向的，其他方法禁止了重定向，于是建个SimpleClientHttpRequestFactory的子类，禁用重定向。于是乎 NoRedirectClientHttpRequestFactory.java123456789101112131415import java.io.IOException;import java.net.HttpURLConnection;import org.springframework.http.client.SimpleClientHttpRequestFactory;public class NoRedirectClientHttpRequestFactory extends SimpleClientHttpRequestFactory &#123; @Override protected void prepareConnection(HttpURLConnection connection, String httpMethod) throws IOException &#123; // TODO Auto-generated method stub super.prepareConnection(connection, httpMethod); // 禁止自动重定向 connection.setFollowRedirects(false); &#125;&#125;12NoRedirectClientHttpRequestFactory httpRequestFactory = new NoRedirectClientHttpRequestFactory();RestTemplate restTemplate = new RestTemplate(httpRequestFactory);接着，似乎更换ClientHttpRequestFactory并不合心意，还是要使用HttpComponentsClientHttpRequestFactory来实现，HttpComponentsClientHttpRequestFactory是可以自定义HttpClient的，于是查到了HttpClient头上，HttpClient是可以设置Redirect的，第二种方式：12345HttpClient httpClient = HttpClientBuilder.create() .setRedirectStrategy(new LaxRedirectStrategy()) .build();httpRequestFactory.setHttpClient(httpClient);RestTemplate restTemplate = new RestTemplate(httpRequestFactory);默认提供了两个类，DefaultRedirectStrategy和LaxRedirectStrategy，LaxRedirectStrategy继承自DefaultRedirectStrategyDefaultRedirectStrategy.java1234567/** * Redirectable methods. */ private static final String[] REDIRECT_METHODS = new String[] &#123; HttpGet.METHOD_NAME, HttpHead.METHOD_NAME &#125;;LaxRedirectStrategy.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* * ==================================================================== * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation. For more * information on the Apache Software Foundation, please see * &lt;http://www.apache.org/&gt;. * */package org.apache.http.impl.client;import org.apache.http.annotation.Contract;import org.apache.http.annotation.ThreadingBehavior;import org.apache.http.client.methods.HttpDelete;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpHead;import org.apache.http.client.methods.HttpPost;/** * Lax &#123;@link org.apache.http.client.RedirectStrategy&#125; implementation * that automatically redirects all HEAD, GET, POST, and DELETE requests. * This strategy relaxes restrictions on automatic redirection of * POST methods imposed by the HTTP specification. * * @since 4.2 */@Contract(threading = ThreadingBehavior.IMMUTABLE)public class LaxRedirectStrategy extends DefaultRedirectStrategy &#123; public static final LaxRedirectStrategy INSTANCE = new LaxRedirectStrategy(); /** * Redirectable methods. */ private static final String[] REDIRECT_METHODS = new String[] &#123; HttpGet.METHOD_NAME, HttpPost.METHOD_NAME, HttpHead.METHOD_NAME, HttpDelete.METHOD_NAME &#125;; @Override protected boolean isRedirectable(final String method) &#123; for (final String m: REDIRECT_METHODS) &#123; if (m.equalsIgnoreCase(method)) &#123; return true; &#125; &#125; return false; &#125;&#125;这就很清晰了，copy一份LaxRedirectStrategy的代码，改写掉REDIRECT_METHODS中的定义方法，如下：1234567891011121314151617181920212223242526272829303132 import org.apache.http.annotation.Contract;import org.apache.http.annotation.ThreadingBehavior;import org.apache.http.impl.client.DefaultRedirectStrategy;/** * * @ClassName: MyRedirectStrategy * @Description: TODO* @author thinklight* @date 2018年4月20日 下午2:47:29 * */@Contract(threading = ThreadingBehavior.IMMUTABLE)public class MyRedirectStrategy extends DefaultRedirectStrategy &#123; public static final MyRedirectStrategy INSTANCE = new MyRedirectStrategy(); /** * Redirectable methods. */ private static final String[] REDIRECT_METHODS = new String[] &#123;&#125;; @Override protected boolean isRedirectable(final String method) &#123; for (final String m: REDIRECT_METHODS) &#123; if (m.equalsIgnoreCase(method)) &#123; return true; &#125; &#125; return false; &#125;&#125;ribbon+微信各种重定向问题，解决了。第三种方式：自己蠢了，今天因为cookie的问题发现了简单的方式1HttpClient httpClient = HttpClientBuilder.create().disableCookieManagement().disableRedirectHandling().build();完整代码如下：12345678910111213141516171819202122@Autowired RestTemplate restTemplate; @Bean @LoadBalanced RestTemplate restTemplate() &#123; HttpComponentsClientHttpRequestFactory httpRequestFactory = new HttpComponentsClientHttpRequestFactory();// NoRedirectClientHttpRequestFactory httpRequestFactory = new NoRedirectClientHttpRequestFactory();// 此类型不能使用httpClient httpRequestFactory.setConnectionRequestTimeout(2000); httpRequestFactory.setConnectTimeout(10000); httpRequestFactory.setReadTimeout(7200000); // HttpClient httpClient = HttpClientBuilder.create() // .setRedirectStrategy(new MyRedirectStrategy()) // .build(); HttpClient httpClient = HttpClientBuilder.create().disableCookieManagement().disableRedirectHandling().build(); httpRequestFactory.setHttpClient(httpClient); RestTemplate restTemplate = new RestTemplate(httpRequestFactory); logger.debug(\"指定字符编码为UTF-8,原编码为ISO-8859-1\"); restTemplate.getMessageConverters().set(1, new StringHttpMessageConverter(StandardCharsets.UTF_8)); logger.debug(\"RestTemple默认能转换为application/json，转换追加text/plain类型\"); restTemplate.getMessageConverters().add(new WxMappingJackson2HttpMessageConverter()); return restTemplate; &#125;重定向参考：https://www.dozer.cc/2014/05/disable-resttemplate-redirect.htmlcookie参考：https://stackoverflow.com/questions/10175649/resttemplate-and-cookiehttps://stackoverflow.com/questions/22853321/resttemplate-client-with-cookies","categories":[{"name":"spring boot","slug":"spring-boot","permalink":"https://lossingdawn.top/categories/spring-boot/"}],"tags":[{"name":"java","slug":"java","permalink":"https://lossingdawn.top/tags/java/"},{"name":"spring boot","slug":"spring-boot","permalink":"https://lossingdawn.top/tags/spring-boot/"},{"name":"restTemplate","slug":"restTemplate","permalink":"https://lossingdawn.top/tags/restTemplate/"}]},{"title":"Java ServletContextListener 实现UDP监听","slug":"80-java-ServletContextListener-实现UDP监听","date":"2018-03-20T07:24:00.000Z","updated":"2019-07-27T17:05:20.356Z","comments":true,"path":"p/zh-CN/10697.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/10697.html","excerpt":"","text":"使用spring boot实现项目启动时的监听，UDPListener1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import java.io.IOException;import java.io.UnsupportedEncodingException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.SocketException;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;import javax.servlet.annotation.WebListener;@WebListenerpublic class UDPListener implements ServletContextListener &#123; public static final int MAX_UDP_DATA_SIZE = 4096; public static final int UDP_PORT = 26666; @Override public void contextInitialized(ServletContextEvent sce) &#123; System.out.println(\"========UDPListener Initialized=========\"); try &#123; // 启动一个线程，监听UDP数据报 new Thread(new UDPProcess(UDP_PORT)).start(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; class UDPProcess implements Runnable &#123; DatagramSocket socket = null; public UDPProcess(final int port) throws SocketException &#123; socket = new DatagramSocket(port); &#125; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(\"=======UDPProcess======\"); while (true) &#123; byte[] buffer = new byte[MAX_UDP_DATA_SIZE]; DatagramPacket packet = new DatagramPacket(buffer, buffer.length); try &#123; socket.receive(packet); new Thread(new Process(packet)).start(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; class Process implements Runnable &#123; public Process(DatagramPacket packet) throws UnsupportedEncodingException &#123; // TODO Auto-generated constructor stub byte[] buffer = packet.getData();// 接收到的UDP信息，然后解码 String srt1 = new String(buffer,\"GBK\").trim(); String srt2 = new String(buffer, \"UTF-8\").trim(); String srt3 = new String(buffer,\"ISO-8859-1\").trim(); System.out.println(\"=======Process srt1 GBK======\" + srt1); System.out.println(\"=======Process srt2 UTF-8======\" + srt2); System.out.println(\"=======Process srt3 ISO-8859-1======\" + srt3); &#125; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(\"====Process run=====\"); &#125; &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; System.out.println(\"========UDPListener Destroyed=========\"); &#125;&#125;DemoApplication12345678@SpringBootApplication@ServletComponentScan public class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125;@ServletComponentScan Servlet扫描，启动时把servlet、filter、listener自动扫描注入 UDP测试客户端（也可以用测试工具发送UDP包测试）：1234567891011121314151617181920212223242526272829303132import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;public class UDPClientTest &#123; public static final String SERVER_HOSTNAME = \"localhost\"; // 服务器端口 public static final int SERVER_PORT = 26666; // 本地发送端口 public static final int LOCAL_PORT = 8888; public static void main(String[] args) &#123; try &#123; // 1，创建udp服务。通过DatagramSocket对象。 DatagramSocket socket = new DatagramSocket(LOCAL_PORT); // 2，确定数据，并封装成数据包。DatagramPacket(byte[] buf, int length, InetAddress // address, int port) byte[] buf = \"你好，世界\".getBytes(); DatagramPacket dp = new DatagramPacket(buf, buf.length, InetAddress.getByName(SERVER_HOSTNAME), SERVER_PORT); // 3，通过socket服务，将已有的数据包发送出去。通过send方法。 socket.send(dp); // 4，关闭资源。 socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;结果：","categories":[{"name":"java","slug":"java","permalink":"https://lossingdawn.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://lossingdawn.top/tags/java/"},{"name":"udp","slug":"udp","permalink":"https://lossingdawn.top/tags/udp/"}]},{"title":"Weex起步","slug":"10-weex起步","date":"2018-03-01T06:56:00.000Z","updated":"2019-07-27T17:06:36.289Z","comments":true,"path":"p/zh-CN/33787.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/33787.html","excerpt":"","text":"weex文档地址：http://weex-project.io/cn/guide/index.htmlweex的文档过于简单，加上js语法 &amp; android &amp; ios本身也有很多的问题，导致新接触weex，几乎步步是坑在此记录一下weex的一些探索 一、初始化按照官方的步骤走，1234567891011#安装node...#安装weex-toolkitnpm install weex-toolkit -g#创建项目weex create awesome-app#开发cd awesome-appnpm installnpm start接着就遇到了语法问题，具体如下所示https://segmentfault.com/q/1010000013417243?_ea=3379756待续。。。","categories":[{"name":"android","slug":"android","permalink":"https://lossingdawn.top/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://lossingdawn.top/tags/android/"}]},{"title":"Mongo去重统计","slug":"5-mongo去重统计","date":"2017-11-10T02:50:00.000Z","updated":"2019-07-27T17:06:07.240Z","comments":true,"path":"p/zh-CN/48103.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/48103.html","excerpt":"","text":"表名：parkUserCostid:patkId:userId:phone:costVal:适合特定条件下，对某些字段进行去重筛选。（比如限定抢购）第一种，使用(first操作符。)first 会把数组的第一个元素取出，作为一个对象。1234567891011121314151617// 第一种（可转java版本）db.getCollection('parkUserCost').aggregate([ &#123;\"$match\" : &#123; \"$and\" : [ // &#123;\"name\" : \"1640\"&#125; // 筛选条件 ] &#125; &#125;, &#123;\"$group\" : &#123; \"_id\" : \"$phone\", \"val\" : &#123;\"$first\" : \"$costVal\" &#125;, &#125;&#125;, &#123;\"$group\" : &#123; \"_id\" : &#123;&#125;, \"totalVal\" :&#123;\"$sum\" : \"$val\"&#125; &#125;&#125;])第二种，使用$slice操作符。从数组的第几个开始，截取几个，保存到数组1234567891011121314151617181920// 第二种db.getCollection('parkUserCost').aggregate([ &#123;\"$match\" : &#123; \"$and\" : [ // &#123;\"name\" : \"1640\"&#125; // 筛选条件 ] &#125; &#125;, &#123;\"$group\" : &#123; \"_id\" : \"$phone\", \"val\" : &#123;\"$push\" : \"$costVal\" &#125;, &#125;&#125;, &#123;\"$project\" : &#123; \"val\" :&#123;\"$sum\" :&#123;\"$slice\" : [\"$val\", 0, 1 ] &#125;&#125; &#125;&#125;, &#123;\"$group\" : &#123; \"_id\" : &#123;&#125;, \"totalVal\" :&#123;\"$sum\" : \"$val\"&#125; &#125;&#125;])第三种，使用$arrayElemAt，返回数组的第几个元素。序号的循环的，最后一个使用-11234567891011121314151617181920// 第三种db.getCollection('parkUserCost').aggregate([ &#123;\"$match\" : &#123; \"$and\" : [ // &#123;\"name\" : \"1640\"&#125; // 筛选条件 ] &#125; &#125;, &#123;\"$group\" : &#123; \"_id\" : \"$phone\", \"val\" : &#123;\"$push\" : \"$costVal\" &#125;, &#125;&#125;, &#123;\"$project\" : &#123; \"val\" : &#123; \"$arrayElemAt\" :[ \"$val\" , 0] &#125; &#125;&#125;, &#123;\"$group\" : &#123; \"_id\" : &#123;&#125;, \"totalVal\" :&#123;\"$sum\" : \"$val\"&#125; &#125;&#125;])若要表中的全部字段，可使用$$ROOT获取12345678910111213db.getCollection('parkUserCost').aggregate([ &#123;\"$match\" : &#123; \"$and\" : [ // &#123;\"name\" : \"1640\"&#125; // 筛选条件 ] &#125; &#125;, &#123;\"$group\" : &#123; \"_id\" : \"$phone\", \"item\": &#123;\"$first\": \"$$ROOT\"&#125;, \"val\" : &#123;\"$first\" : \"$costVal\" &#125;, &#125;&#125;,])http://www.runoob.com/mongodb/mongodb-tutorial.html","categories":[{"name":"db","slug":"db","permalink":"https://lossingdawn.top/categories/db/"},{"name":"mongo","slug":"db/mongo","permalink":"https://lossingdawn.top/categories/db/mongo/"}],"tags":[{"name":"mongo","slug":"mongo","permalink":"https://lossingdawn.top/tags/mongo/"}]},{"title":"Backbone之路由锚点的替换","slug":"10-backbone之路由锚点的替换","date":"2017-09-26T02:10:00.000Z","updated":"2019-07-27T17:03:28.471Z","comments":true,"path":"p/zh-CN/7347.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/7347.html","excerpt":"","text":"1、需求由于项目一开始做的时候不甚完善，所有的网页没有路由功能，导致一些搜索结果在页面跳转之后，没有被记录下来，在页面跳转之后回退，得到的是页面最原始的结果，没有指定的搜索条件。最近项目的在完善这些小的细节，所以在此记录一下。 2、操作由于项目的所有传参都是使用 ‘?’ 来标识的，而Backbone的路由是使用锚点 ‘/#’ 来的，为了兼容以前的做法，不得不去修改Backbone的源码，还好路由部分的源码不多 2.1 修改Backbone的源码，版本1.3.31）修改标识 ‘/#’ -&gt; ‘?’把源代码中的字符串中的’/#‘修改为’?’，把单个的’/#‘修改为’?’123456789101112131415例：var pathStripper = /#.*$/;修改为：var pathStripper = /\\?.*$/;例：this.location.replace(rootPath + '#' + this.getPath());修改为：this.location.replace(rootPath + '?' + this.getPath());注：字符串中的?需要\\来转义，字符不需要2)修改锚点的路由设置1234567891011121314151617181920212223_updateHash: function(location, fragment, replace) &#123;if (replace) &#123;var href = location.href.replace(/(javascript:|\\?).*$/, '');location.replace(href + '?' + fragment);&#125; else &#123;// Some browsers require that `hash` contains a leading #.// location.hash = '?' + fragment;var href = location.href.replace(/(javascript:|\\?).*$/, '');// window.history.pushState(&#123;&#125;, 0, href + '?' + fragment);window.history.replaceState(&#123;&#125;, 0, href + '?' + fragment);&#125;&#125;注：location.hash是原始的修改参数方法，会替换url中’/#'以及后的所有内容window.history.pushState可选目标方法，会增加一次历史记录，刷新页面window.history.replaceState可选目标方法，会替换掉当前的页面记录，不刷新页面（目前选用方案） 2.2 写一个Util写一个工具类用于Router的快速使用，和统一修改123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/*** RouterUtil.js*/var RouterUtil = (function() &#123;// Backbone Router with a custom parameter extractorvar Router = Backbone.Router.extend(&#123;params : \"\",routes : &#123;\"*actions\": \"defaultRoute\" // 匹配 http://example.com/#anything-here&#125;,defaultRoute : function(params) &#123;Router.params = params;&#125;,&#125;);var routerUtil = &#123;web_router : null,init()&#123;// 初始化if(!routerUtil.web_router)&#123;routerUtil.web_router = new Router;Backbone.history.start();&#125;&#125;,getParam(cbFn)&#123;routerUtil.init();// 获取#之后的参数if(cbFn)&#123;cbFn(Router.params);&#125;&#125;,route(returnUrl, cbFn)&#123;// 动态的调整 路由规则 例：topic/:pageno/:pagesizerouterUtil.web_router.route(returnUrl,\"page\", cbFn)&#125;,start()&#123;// 启用路由if(!Backbone.History.started)&#123;Backbone.history.start();&#125;&#125;,stop()&#123;// 关闭路由if(Backbone.History.started)&#123;Backbone.history.stop();&#125;&#125;,navigate(returnUrl)&#123;/*** 重构 ，路由导向*///此处根据自己的需求去构建参数拼接//returnUrl为'?'之后的内容if(returnUrl)&#123;&#125;else&#123;returnUrl = \"searchType=\" + SearchBoxUtil.searchType + \"&amp;\" + SearchBoxUtil.formData;&#125;routerUtil.web_router.navigate(returnUrl, &#123;trigger: true&#125;);&#125;&#125;return routerUtil;&#125;)(); 2.3 使用在js中引用的一些方法123456789101112131415161718192021222324252627282930313233343536373839404142434445// 页面的初始化initPagi : function()&#123;RouterUtil.getParam(function(params)&#123;if(!params)&#123;params = \"\";&#125;//处理参数...&#125;);&#125;,//查询函数queryData : function(returnUrl,isInitSearchBox)&#123;if(!returnUrl)&#123;returnUrl = \"\";&#125;if(isInitSearchBox)&#123;//第一次初始化查询&#125;else&#123;//非第一次初始化查询RouterUtil.navigate(returnUrl);&#125;...&#125;,菜鸟一枚，随便弄弄的一点代码，有更好的方案请赐教","categories":[{"name":"web","slug":"web","permalink":"https://lossingdawn.top/categories/web/"},{"name":"jq","slug":"web/jq","permalink":"https://lossingdawn.top/categories/web/jq/"}],"tags":[{"name":"jq","slug":"jq","permalink":"https://lossingdawn.top/tags/jq/"}]},{"title":"Ctrl Shift O失效","slug":"6-ctrl-shift-o失效","date":"2017-08-25T02:24:00.000Z","updated":"2019-07-27T17:04:06.423Z","comments":true,"path":"p/zh-CN/64985.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/64985.html","excerpt":"","text":"是这样的。preference -&gt; general -&gt; keys ,找到Organize Imports ,然后 在 “WHEN”里面 要选择 Editing JAVA SOURCE。这个是最重要的","categories":[{"name":"ide","slug":"ide","permalink":"https://lossingdawn.top/categories/ide/"},{"name":"eclipse","slug":"ide/eclipse","permalink":"https://lossingdawn.top/categories/ide/eclipse/"}],"tags":[{"name":"ide","slug":"ide","permalink":"https://lossingdawn.top/tags/ide/"},{"name":"eclipse","slug":"eclipse","permalink":"https://lossingdawn.top/tags/eclipse/"}]},{"title":"findBugs英文代号的对照表","slug":"6-findBugs英文代号的对照表","date":"2017-04-28T03:09:00.000Z","updated":"2019-07-27T17:04:42.071Z","comments":true,"path":"p/zh-CN/45196.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/45196.html","excerpt":"","text":"findBugs错误英文翻译123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408rule.findbugs.IMSE_DONT_CATCH_IMSE.name=不良实践 - 捕获可疑IllegalMonitorStateExceptionrule.findbugs.BX_BOXING_IMMEDIATELY_UNBOXED.name=性能 - 基本类型包装之后立刻解包rule.findbugs.IJU_SETUP_NO_SUPER.name=使用错误 - TestCase定义的setUp没有调用super.setUp()rule.findbugs.TQ_ALWAYS_VALUE_USED_WHERE_NEVER_REQUIRED.name=使用错误 - 某个值使用了注解限制类型，但是这个限制永远不会发生rule.findbugs.TLW_TWO_LOCK_WAIT.name=多线程错误 - 等待两个被持有的锁rule.findbugs.RV_01_TO_INT.name=使用错误 - 0至1的随机数被当做整数0rule.findbugs.NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE.name=高危 - 参数必须非null但是标记为可为nullrule.findbugs.RV_ABSOLUTE_VALUE_OF_RANDOM_INT.name=使用错误 - 尝试计算32位随机整数的绝对值rule.findbugs.EC_INCOMPATIBLE_ARRAY_COMPARE.name=使用错误 - 使用equals()比较不兼容的数组rule.findbugs.UL_UNRELEASED_LOCK_EXCEPTION_PATH.name=多线程错误 - 方法没有在所有异常路径释放锁rule.findbugs.SE_NONSTATIC_SERIALVERSIONID.name=不良实践 - serialVersionUID不是static的rule.findbugs.UCF_USELESS_CONTROL_FLOW.name=高危 - 无用控制流rule.findbugs.BC_IMPOSSIBLE_CAST.name=使用错误 - 不可能的转换rule.findbugs.XSS_REQUEST_PARAMETER_TO_SEND_ERROR.name=安全风险 - servlet的反射导致跨站脚本漏洞rule.findbugs.DM_NEW_FOR_GETCLASS.name=性能 - 仅为了获得一个方法就创建了一个对象rule.findbugs.OBL_UNSATISFIED_OBLIGATION.name=试验 - 方法可能在清理流或资源时失败rule.findbugs.UW_UNCOND_WAIT.name=多线程错误 - 无条件等待rule.findbugs.DLS_DEAD_LOCAL_STORE_OF_NULL.name=高危 - 把null设置给不会用到的局部变量rule.findbugs.NM_CLASS_NAMING_CONVENTION.name=类名应该以大写字母开头rule.findbugs.RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN.name=使用错误 - 怀疑对两个布尔值的引用进行比较rule.findbugs.MWN_MISMATCHED_NOTIFY.name=多线程错误- 不匹配的notify()rule.findbugs.NM_VERY_CONFUSING.name=错误 - 非常容易迷惑的方法名rule.findbugs.FI_NULLIFY_SUPER.name=不良实践 - 空Finalizer禁用了超类的finalizerrule.findbugs.MTIA_SUSPECT_STRUTS_INSTANCE_FIELD.name=高危 - 继承了struts Action的类使用了实例变量rule.findbugs.DM_STRING_CTOR.name=性能 - 方法调用了效率很低的new String(String)构造方法rule.findbugs.STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE.name=多线程错误 - 调用静态DateFormatrule.findbugs.NP_NULL_PARAM_DEREF_NONVIRTUAL.name=使用错误 - 非虚拟方法调用向非空参数传入了nullrule.findbugs.FI_EMPTY.name=不良实践 - 应该删除空的finalizerrule.findbugs.CD_CIRCULAR_DEPENDENCY.name=试验 - 类间存在循环引用rule.findbugs.EC_UNRELATED_TYPES.name=使用错误 - 使用equals()比较不同类型rule.findbugs.EI_EXPOSE_STATIC_REP2.name=恶意代码漏洞 - 把可变对象保存到静态字段中可能会暴露内部静态状态rule.findbugs.DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY.name=错误 - 对数组执行toStringrule.findbugs.SIC_INNER_SHOULD_BE_STATIC_ANON.name=性能 - 可以重构成一个静态内部类rule.findbugs.STI_INTERRUPTED_ON_UNKNOWNTHREAD.name=错误 - 在thread实例上调用了静态Thread.interrupted()方法rule.findbugs.CN_IDIOM_NO_SUPER_CALL.name=不良实践 - clone方法没有调用super.clone()rule.findbugs.VA_FORMAT_STRING_BAD_ARGUMENT.name=错误用法 - 格式化字符串占位符与传入的参数不匹配rule.findbugs.EQ_DOESNT_OVERRIDE_EQUALS.name=高危 - 类没有覆盖父类的equals方法rule.findbugs.BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY.name=错误用法 - 集合转换为数组元素时发生的类型转换错误rule.findbugs.SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION.name=不良实践 - 类是可扩展的，但是没有提供无参数的构造方法rule.findbugs.TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_ALWAYS_SINK.name=错误用法 - 数值需要类型标示，但是却标记为未知rule.findbugs.SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS.name=性能 - 可以筹够成一个静态内部类rule.findbugs.EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS.name=不良实践 - equals检测不兼容的参数操作rule.findbugs.RV_RETURN_VALUE_OF_PUTIFABSENT_IGNORED.name=错误用法 - 忽略了putIfAbsent的返回值，传递给putIfAbsent的值被重用rule.findbugs.STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE.name=多线程错误 - 调用静态Calendarrule.findbugs.MS_CANNOT_BE_FINAL.name=恶意代码漏洞 - 字段不是final的，不能防止恶意代码的攻击rule.findbugs.IS_INCONSISTENT_SYNC.name=多线程错误 - 不一致的同步rule.findbugs.SE_NO_SERIALVERSIONID.name=不良实践 - 类是可序列化的，但是没有定义serialVersionUIDrule.findbugs.EI_EXPOSE_REP2.name=恶意代码漏洞 - 可能暴露内部实现，通过与可变对象引用协作rule.findbugs.NM_METHOD_CONSTRUCTOR_CONFUSION.name=错误用法 - 明显的方法/构造方法混淆rule.findbugs.ICAST_INTEGER_MULTIPLY_CAST_TO_LONG.name=高危 - 整形乘法的结果转换为long型rule.findbugs.QF_QUESTIONABLE_FOR_LOOP.name=高危 - for循环中存在复杂，微妙或者错误的自增rule.findbugs.DLS_DEAD_STORE_OF_CLASS_LITERAL.name=错误用法 - 类中保存了无用字符rule.findbugs.NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER.name=不良实践 - 使用了未来java版本中成为关键字的标识rule.findbugs.BC_VACUOUS_INSTANCEOF.name=高危 - instanceof会一直返回truerule.findbugs.INT_VACUOUS_BIT_OPERATION.name=高危 - 在整形上进行位操作时有一些位上出现空洞rule.findbugs.NP_NULL_INSTANCEOF.name=错误用法 - 一个已知的null值被检测它是否是一个类型的实例rule.findbugs.SIC_THREADLOCAL_DEADLY_EMBRACE.name=错误用法 - 非静态内部类和ThreadLocal的致命结合rule.findbugs.EQ_UNUSUAL.name=高危 - 罕见的equals方法rule.findbugs.IJU_NO_TESTS.name=错误用法 - TestCase没有任何测试rule.findbugs.EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC.name=错误用法 - equals方法覆盖了父类的equals可能功能不符rule.findbugs.XFB_XML_FACTORY_BYPASS.name=高危 - 方法直接调用了xml接口的一个具体实现rule.findbugs.SWL_SLEEP_WITH_LOCK_HELD.name=多线程错误 - 方法在获得锁时调用了Thread.sleep()rule.findbugs.CN_IDIOM.name=不良实践 - 类实现了Cloneable ，但是没有定义或使用clone方法rule.findbugs.WA_AWAIT_NOT_IN_LOOP.name=多线程错误 - 未在循环中使用的Condition.await()rule.findbugs.DM_FP_NUMBER_CTOR.name=性能 - 方法调用了低效的浮点书构造方法；应该使用静态的valueOf代替rule.findbugs.SF_SWITCH_NO_DEFAULT.name=Switch语句中没有包含defaultrule.findbugs.NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE.name=高危 - 调用返回返回值可能出现null值rule.findbugs.NP_CLONE_COULD_RETURN_NULL.name=不良实践 - Clone方法可能返回nullrule.findbugs.MS_OOI_PKGPROTECT.name=恶意代码漏洞 - 属性应该从接口中移除并将访问权限设置为包保护rule.findbugs.DM_BOXED_PRIMITIVE_TOSTRING.name=性能 - 方法使用了装箱的基本类型只为了调用toStringrule.findbugs.EQ_ABSTRACT_SELF.name=不良实践 - 抽象类定义了协变的equals方法rule.findbugs.DM_STRING_TOSTRING.name=性能 - 方法调用了String的toString()方法rule.findbugs.SE_METHOD_MUST_BE_PRIVATE.name=错误用法 - 方法必须是private的为了让序列化正常工作rule.findbugs.DL_SYNCHRONIZATION_ON_BOOLEAN.name=多线程错误 - 在Boolean上使用同步可能导致死锁rule.findbugs.UWF_UNWRITTEN_FIELD.name=错误用法 - 未赋值属性rule.findbugs.IS2_INCONSISTENT_SYNC.name=多线程错误 - 不一致的同步rule.findbugs.IM_AVERAGE_COMPUTATION_COULD_OVERFLOW.name=高危 - 计算平均值可能溢出rule.findbugs.BIT_SIGNED_CHECK_HIGH_BIT.name=错误用法 - 检查位运算的符号rule.findbugs.FL_MATH_USING_FLOAT_PRECISION.name=错误用法 - 方法进行数学运算时使用了浮点数的精度rule.findbugs.WS_WRITEOBJECT_SYNC.name=多线程错误 - 类的writeObject()方法是同步的，但是没有做其他事情rule.findbugs.RV_RETURN_VALUE_IGNORED.name=错误用法 - 方法忽略了返回值rule.findbugs.SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE.name=安全风险 - 非常量的字符串传递给方法执行SQL语句rule.findbugs.JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS.name=不良实践 - 不可变的类的属性应该是finalrule.findbugs.AM_CREATES_EMPTY_ZIP_FILE_ENTRY.name=不良实践 - 创建了一个空的zip文件的入口rule.findbugs.DM_NEXTINT_VIA_NEXTDOUBLE.name=性能 - 使用Random的nextInt方法来获得一个随机整数，而不是nextDoublerule.findbugs.UI_INHERITANCE_UNSAFE_GETRESOURCE.name=不良实践 - 如果类被扩展，GetResource的使用可能就是不安全的rule.findbugs.SIO_SUPERFLUOUS_INSTANCEOF.name=错误用法 - 不必要的类型检测使用instanceof操作符rule.findbugs.EQ_OTHER_NO_OBJECT.name=错误用法 - equals()方法定义，但是没有覆盖equals(Object)rule.findbugs.USM_USELESS_ABSTRACT_METHOD.name=试验 - 抽象方法已经在实现的接口中定义了rule.findbugs.MTIA_SUSPECT_SERVLET_INSTANCE_FIELD.name=高危 - 扩展Servlet的类使用了实例变量rule.findbugs.DM_USELESS_THREAD.name=多线程错误 - 使用默认的空run方法创建了一个线程rule.findbugs.ML_SYNC_ON_UPDATED_FIELD.name=多线程错误 - 方法在一个修改了的属性上进行了同步rule.findbugs.CO_SELF_NO_OBJECT.name=不良实践 - 协变的compareTo()定义rule.findbugs.BC_UNCONFIRMED_CAST.name=高危 - 未检查/未证实的类型转换rule.findbugs.FI_FINALIZER_NULLS_FIELDS.name=不良实践 - Finalizer空属性rule.findbugs.BIT_AND.name=错误用法 - 不兼容的位掩码(BIT_AND)rule.findbugs.FE_FLOATING_POINT_EQUALITY.name=高危 - 测试浮点数相等rule.findbugs.TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_NEVER_SINK.name=错误用法 - 值不要求有类型标示，但是标记为未知rule.findbugs.NP_NULL_PARAM_DEREF.name=错误用法 - 方法调用把null传递给一个非null参数rule.findbugs.FB_MISSING_EXPECTED_WARNING.name=试验 - findbugs丢失了期待或需要的警告rule.findbugs.DMI_INVOKING_HASHCODE_ON_ARRAY.name=错误用法 - 在数组上调用了hashCoderule.findbugs.QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT.name=错误用法 - 方法在布尔表达式中分配了boolean文字rule.findbugs.SA_FIELD_SELF_COMPARISON.name=错误用法 - 属性自己与自己进行了比较rule.findbugs.UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR.name=错误用法 - 父类的构造方法调用未初始化属性的方法rule.findbugs.ES_COMPARING_PARAMETER_STRING_WITH_EQ.name=不良实践 - 比较字符串参数使用了 == 或 !=rule.findbugs.INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE.name=错误用法 - 错误比较非负值与负数rule.findbugs.INT_BAD_COMPARISON_WITH_SIGNED_BYTE.name=错误用法 - 错误比较带符号的byterule.findbugs.IO_APPENDING_TO_OBJECT_OUTPUT_STREAM.name=错误用法 - 尝试向一个对象输出流添加信息rule.findbugs.FI_MISSING_SUPER_CALL.name=不良实践 - Finalizer没有调用父类的finalizerrule.findbugs.VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED.name=错误用法 - 传递了多余实际使用的格式化字符串的参数rule.findbugs.HE_EQUALS_USE_HASHCODE.name=不良实践 - 类定义了equals()，但使用了Object.hashCode()rule.findbugs.IJU_BAD_SUITE_METHOD.name=错误用法 - TestCase声明了一个错误的suite方法rule.findbugs.DMI_CONSTANT_DB_PASSWORD.name=安全风险 - 硬编码了数据库密码rule.findbugs.REC_CATCH_EXCEPTION.name=高危 - 捕获了没有抛出的异常rule.findbugs.PS_PUBLIC_SEMAPHORES.name=高危 - 类在公用接口中暴露了同步和信号rule.findbugs.EC_UNRELATED_INTERFACES.name=错误用法 - 调用equals()比较不同的接口类型rule.findbugs.UCF_USELESS_CONTROL_FLOW_NEXT_LINE.name=错误用法 - 执行到下一行的无用流程控制rule.findbugs.LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE.name=试验 - OpenJDK中存在潜在的丢失logger的风险，因为弱引用rule.findbugs.NP_UNWRITTEN_FIELD.name=错误用法 - 读取未初始化的属性rule.findbugs.DMI_UNSUPPORTED_METHOD.name=高危 - 调用不支持的方法rule.findbugs.RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE.name=高危 - 重复比较非空值和nullrule.findbugs.EC_BAD_ARRAY_COMPARE.name=错误用法 - 调用equals()，与==效果一样rule.findbugs.EI_EXPOSE_REP.name=恶意代码漏洞 - 可能通过返回一个可变对象的引用暴露了内部实现rule.findbugs.NP_DEREFERENCE_OF_READLINE_VALUE.name=高危 - 没有判断readLine()的结果是否为空rule.findbugs.UPM_UNCALLED_PRIVATE_METHOD.name=性能 - 从未用到的私有方法rule.findbugs.NP_NULL_ON_SOME_PATH.name=错误用法 - 可能出现空指针引用rule.findbugs.NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT.name=不良实践 - equals()方法没有检测null参数rule.findbugs.EC_NULL_ARG.name=错误用法 - 使用空参数调用equals()rule.findbugs.SE_BAD_FIELD_STORE.name=不良实践 - 非序列化值保存在序列化类的实例变量中rule.findbugs.VO_VOLATILE_REFERENCE_TO_ARRAY.name=多线程错误 - 数组的volatile引用不会把数组元素也当做volatile来引用rule.findbugs.NP_SYNC_AND_NULL_CHECK_FIELD.name=多线程错误 - 同步和空值检测发生在同一个属性上rule.findbugs.DM_EXIT.name=不良实践 - 方法调用了System.exit(...)rule.findbugs.RC_REF_COMPARISON.name=不良实践 - 怀疑进行了引用比较rule.findbugs.SE_NO_SUITABLE_CONSTRUCTOR.name=不良实践 - 类是可序列化的，但是父类没有定义无参数构造方法rule.findbugs.DC_DOUBLECHECK.name=多线程错误 - 可能对属性进行了双重检测rule.findbugs.DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT.name=错误用法 - 在int上调用了Double.longBitsToDoublerule.findbugs.RpC_REPEATED_CONDITIONAL_TEST.name=错误用法 - 重复判断条件rule.findbugs.WMI_WRONG_MAP_ITERATOR.name=性能 - keySet迭代是低效的，使用entrySet代替rule.findbugs.DLS_DEAD_LOCAL_STORE.name=高危 - 未用的局部变量rule.findbugs.INT_BAD_REM_BY_1.name=错误用法 - 整数剩余模1rule.findbugs.RV_RETURN_VALUE_IGNORED_BAD_PRACTICE.name=不良实践 - 方法忽略异常返回值rule.findbugs.SA_LOCAL_SELF_ASSIGNMENT.name=高危 - 局部变量的自我赋值rule.findbugs.MS_SHOULD_BE_FINAL.name=恶意代码漏洞 - 属性不是final，但是应该设置成finalrule.findbugs.SIC_INNER_SHOULD_BE_STATIC.name=性能 - 应该是一个静态内部类rule.findbugs.NP_GUARANTEED_DEREF.name=错误用法 - null值一定会被调用rule.findbugs.SE_READ_RESOLVE_MUST_RETURN_OBJECT.name=不良实践 - readResolve方法必须返回Objectrule.findbugs.NP_LOAD_OF_KNOWN_NULL_VALUE.name=高危 - 加载了已知的null值rule.findbugs.BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION.name=性能 - 基本数据被装箱又被拆箱rule.findbugs.CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE.name=不良实践 - 类定义了clone()但没有实现Cloneablerule.findbugs.CO_ABSTRACT_SELF.name=不良实践 - 抽象类定义了协变的compareTo()方法rule.findbugs.BAC_BAD_APPLET_CONSTRUCTOR.name=试验 - 错误的Applet构造方法依赖未初始化的AppletStubrule.findbugs.EQ_GETCLASS_AND_CLASS_CONSTANT.name=不良实践 - equals方法因为子类失败rule.findbugs.DB_DUPLICATE_SWITCH_CLAUSES.name=高危 - 在两个switch语句中使用了相同的代码rule.findbugs.DB_DUPLICATE_BRANCHES.name=高危 - 在两个分支中使用了相同的代码rule.findbugs.UOE_USE_OBJECT_EQUALS.name=试验 - 在final类上调用了equals，但是没有覆盖Object的equals方法rule.findbugs.FI_USELESS.name=不良实践 - Finalizer除了调用父类的finalizer以外什么也没做rule.findbugs.NP_ALWAYS_NULL.name=错误用法 - 调用了null指针rule.findbugs.DMI_VACUOUS_SELF_COLLECTION_CALL.name=错误用法 - 集合的调用不能被感知rule.findbugs.DLS_DEAD_LOCAL_STORE_IN_RETURN.name=错误用法 - 返回语句中的无用的赋值rule.findbugs.IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD.name=错误用法 - 在run方法中的JUnit检验不能报告给JUnitrule.findbugs.DMI_EMPTY_DB_PASSWORD.name=安全风险 - 空的数据库密码rule.findbugs.DM_BOOLEAN_CTOR.name=性能 - 方法调用了低效的Boolean构造方法；使用Boolean.valueOf(...)代替rule.findbugs.BC_IMPOSSIBLE_DOWNCAST.name=错误用法 - 不可能转型rule.findbugs.BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS.name=不良实践 - Equals方法不应该假设任何有关参数类型的事宜rule.findbugs.RV_EXCEPTION_NOT_THROWN.name=错误用法 - 异常创建后就丢弃了，没有抛出rule.findbugs.VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG.name=错误用法 - 基本类型数组传递给一个期待可变对象类型参数的方法rule.findbugs.LI_LAZY_INIT_UPDATE_STATIC.name=多线程错误 - 错误的延迟初始化和更新静态属性rule.findbugs.SA_FIELD_SELF_ASSIGNMENT.name=错误用法 - 属性自身赋值rule.findbugs.EQ_ALWAYS_FALSE.name=错误用法 - equals方法一直返回falserule.findbugs.DMI_RANDOM_USED_ONLY_ONCE.name=不良实践 - Random对象创建后只用了一次rule.findbugs.NM_CLASS_NOT_EXCEPTION.name=不良实践 - Class没有继承Exception，虽然名字像一个异常rule.findbugs.SA_LOCAL_DOUBLE_ASSIGNMENT.name=高危 - 给局部变量双重赋值rule.findbugs.NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS.name=错误用法 - 方法调用传递null给非空参数 (ALL_TARGETS_DANGEROUS)rule.findbugs.NP_TOSTRING_COULD_RETURN_NULL.name=不良实践 - toString方法可能返回nullrule.findbugs.BC_BAD_CAST_TO_ABSTRACT_COLLECTION.name=高危 - 转换成抽象集合值得怀疑rule.findbugs.NM_LCASE_HASHCODE.name=类定义了hashcode(); 应该是hashCode()吧？rule.findbugs.RU_INVOKE_RUN.name=多线程错误 - 在线程中调用了run（你的意思是再启动一次么？）rule.findbugs.DMI_INVOKING_TOSTRING_ON_ARRAY.name=错误用法 - 调用了数组的toStringrule.findbugs.NM_METHOD_NAMING_CONVENTION.name=方法名应该以小写字母开头rule.findbugs.RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES.name=高危 - 重复比较两个null值rule.findbugs.SA_LOCAL_SELF_COMPUTATION.name=错误用法 - 对一个变量进行无意义的自我计算 (比如 x &amp; x)rule.findbugs.MS_MUTABLE_HASHTABLE.name=恶意代码漏洞 - 属性是可变的Hashtablerule.findbugs.RV_DONT_JUST_NULL_CHECK_READLINE.name=高危 - 方法丢掉了readLine的结果，在检测它是非空之后。rule.findbugs.ES_COMPARING_STRINGS_WITH_EQ.name=不良实践 - 使用== 或 !=比较Stringrule.findbugs.DL_SYNCHRONIZATION_ON_SHARED_CONSTANT.name=多线程错误 - 同步内部String可能导致死锁rule.findbugs.MF_METHOD_MASKS_FIELD.name=错误用法 - 方法定义了一个变量，与实例变量同名。rule.findbugs.EQ_SELF_USE_OBJECT.name=错误用法 - 协变equals()方法定义，继承了Object.equals(Object)rule.findbugs.ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND.name=错误用法 - int值转换成float，然后传递给Math.roundrule.findbugs.GC_UNRELATED_TYPES.name=错误用法 - 泛型参数与方法参数没有相互关系rule.findbugs.BC_IMPOSSIBLE_INSTANCEOF.name=错误用法 - instanceof一直返回falserule.findbugs.SBSC_USE_STRINGBUFFER_CONCATENATION.name=性能 - 方法在循环中使用+进行字符串拼接rule.findbugs.ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL.name=错误用法 - int转换成double，然后传递给Math.ceilrule.findbugs.UG_SYNC_SET_UNSYNC_GET.name=多线程错误 - 未同步的getter方法，同步的setter方法rule.findbugs.RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION.name=错误用法 - 非法的正则表达式rule.findbugs.SA_FIELD_SELF_COMPUTATION.name=错误用法 - 无意义的自我计算 (比如 x &amp; x)rule.findbugs.DMI_SCHEDULED_THREAD_POOL_EXECUTOR_WITH_ZERO_CORE_THREADS.name=错误用法 - 创建了没有任何线程的ScheduledThreadPoolExecutorrule.findbugs.DMI_USELESS_SUBSTRING.name=高危 - 调用substring(0)会返回原值rule.findbugs.IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD.name=高危 - 被继承的或外部的方法的模棱两可的调用rule.findbugs.OS_OPEN_STREAM.name=不良实践 - 方法可能在关闭流时失败rule.findbugs.HE_INHERITS_EQUALS_USE_HASHCODE.name=不良实践 - 类继承了equals()，但使用了Object.hashCode()rule.findbugs.SE_NONFINAL_SERIALVERSIONID.name=不良实践 - serialVersionUID不是final的rule.findbugs.EQ_SELF_NO_OBJECT.name=不良实践 - 协变equals()方法定义rule.findbugs.SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH.name=由于switch语句导致的无用存储rule.findbugs.SW_SWING_METHODS_INVOKED_IN_SWING_THREAD.name=不良实践 - 某些swing方法需要在swing线程中调用rule.findbugs.VA_FORMAT_STRING_ILLEGAL.name=错误用法 - 非法的格式化字符串rule.findbugs.DM_NUMBER_CTOR.name=性能 - 方法调用低效的数字构造方法;使用静态valueOf代替rule.findbugs.RV_REM_OF_RANDOM_INT.name=高危 - 其余32位带符号随机整数rule.findbugs.EQ_COMPARING_CLASS_NAMES.name=错误用法 - equals方法比较类名而不是比较类rule.findbugs.ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD.name=高危 - 通过一个实例方法更新静态属性rule.findbugs.TQ_NEVER_VALUE_USED_WHERE_ALWAYS_REQUIRED.name=错误用法 - 某个值使用了注解标记不会限制类型，但是这个限制是必须的rule.findbugs.NS_NON_SHORT_CIRCUIT.name=高危 - 可疑的非短路逻辑rule.findbugs.VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT.name=错误用法 - 格式化字符串没有前面的参数rule.findbugs.SE_PRIVATE_READ_RESOLVE_NOT_INHERITED.name=高危 - 私有readResolve方法不是继承自父类rule.findbugs.RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE.name=高危 - 对一个已知不是null的值重复进行空值判断rule.findbugs.NM_LCASE_TOSTRING.name=类定义了tostring(); 应该是toString()吧？rule.findbugs.HSC_HUGE_SHARED_STRING_CONSTANT.name=性能 - 巨大的字符串常量在多个类文件中间重复了rule.findbugs.SE_TRANSIENT_FIELD_NOT_RESTORED.name=不良实践 - Transient属性没有再反序列化时被设置rule.findbugs.JLM_JSR166_LOCK_MONITORENTER.name=多线程错误 - 在java.util.concurrent Lock上进行了同步rule.findbugs.EQ_ALWAYS_TRUE.name=错误用法 - equals方法总是返回truerule.findbugs.ISC_INSTANTIATE_STATIC_CLASS.name=不良实践 - 只提供静态方法的类不需要实例化rule.findbugs.ICAST_IDIV_CAST_TO_DOUBLE.name=高危 - int相除的结果转换成double或floatrule.findbugs.RC_REF_COMPARISON_BAD_PRACTICE.name=错误用法 - 可疑的引用与常量的比较rule.findbugs.FI_EXPLICIT_INVOCATION.name=不良实践 - 直接调用finalizerrule.findbugs.ESync_EMPTY_SYNC.name=多线程错误 - 空的同步块rule.findbugs.DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION.name=错误用法 - 不要使用removeAll清空集合rule.findbugs.SE_BAD_FIELD.name=在序列化类中出现了非transient也非serializable的实例属性rule.findbugs.NP_STORE_INTO_NONNULL_FIELD.name=错误用法 - 属性已经标记为NonNull，但是设置了一个null值rule.findbugs.IT_NO_SUCH_ELEMENT.name=不良实践 - 迭代器的next()方法不能抛出NoSuchElementExceptionrule.findbugs.HRS_REQUEST_PARAMETER_TO_HTTP_HEADER.name=安全风险 - HTTP响应拆分漏洞rule.findbugs.DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED.name=高危 - 希望传入Runnable的地方传入了一个Threadrule.findbugs.NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH.name=错误用法 - null值会在exception处理中被用到rule.findbugs.RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE.name=高危 - 已知的null值被重复的检测rule.findbugs.DMI_CALLING_NEXT_FROM_HASNEXT.name=错误用法 - hasNext方法调用了next方法rule.findbugs.HE_HASHCODE_USE_OBJECT_EQUALS.name=不良实践 - 定义了hashCode()的类使用了Object.equals()rule.findbugs.VA_FORMAT_STRING_EXPECTED_MESSAGE_FORMAT_SUPPLIED.name=错误用法 - 需要使用printf样式时使用了MessageFormatrule.findbugs.NP_BOOLEAN_RETURN_NULL.name=不良实践 - 方法返回boolean类型返回了nullrule.findbugs.RI_REDUNDANT_INTERFACES.name=高危 - 类实现了父类一样的接口rule.findbugs.DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE.name=多线程错误 - 在装箱的基本属性上使用了同步rule.findbugs.STCAL_STATIC_CALENDAR_INSTANCE.name=多线程错误 - 静态Calendarrule.findbugs.RR_NOT_CHECKED.name=不良实践 - 方法忽略InputStream.read()的返回值rule.findbugs.IL_INFINITE_RECURSIVE_LOOP.name=错误用法 - 明显的无限递归循环rule.findbugs.DMI_NONSERIALIZABLE_OBJECT_WRITTEN.name=高危 - 非持久化的对象写入了ObjectOutputrule.findbugs.GC_UNCHECKED_TYPE_IN_GENERIC_CALL.name=不良实践 - 泛型调用中使用了未检查的类型rule.findbugs.IMA_INEFFICIENT_MEMBER_ACCESS.name=试验 - 方法访问了一个拥有的类的私有成员rule.findbugs.FI_PUBLIC_SHOULD_BE_PROTECTED.name=恶意代码漏洞 - Finalizer应该是protected，不能是publicrule.findbugs.RV_CHECK_FOR_POSITIVE_INDEXOF.name=高危 - 方法检查检查String.indexOf的结果是否为正数rule.findbugs.ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT.name=高危 - 无符号右移转换为short/byterule.findbugs.DM_STRING_VOID_CTOR.name=性能 - 方法调用了低效的new String()构造方法rule.findbugs.RE_POSSIBLE_UNINTENDED_PATTERN.name=错误用法 - \".\"用作正则表达式rule.findbugs.WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL.name=多线程错误 - 在getClass上使用同步而不是在class文字上rule.findbugs.ICAST_BAD_SHIFT_AMOUNT.name=错误用法 - 右移的数值不在0..31范围内rule.findbugs.SF_SWITCH_FALLTHROUGH.name=Switch语句中一个case失败以后进入了下一个caserule.findbugs.DP_DO_INSIDE_DO_PRIVILEGED.name=不良实践 - 方法调用应该在doPrivileged块中rule.findbugs.NO_NOTIFY_NOT_NOTIFYALL.name=多线程错误 - 使用notify()而不是notifyAll()rule.findbugs.SS_SHOULD_BE_STATIC.name=性能 - 未读取的属性：这个属性是否应该是static的？rule.findbugs.DM_RUN_FINALIZERS_ON_EXIT.name=不良实践 - 方法调用了危险的runFinalizersOnExit方法rule.findbugs.MS_FINAL_PKGPROTECT.name=恶意代码漏洞 - 属性应该同时是final 和 package protected的rule.findbugs.BC_BAD_CAST_TO_CONCRETE_COLLECTION.name=高危 - 转换成具体集合可能有问题rule.findbugs.BIT_IOR_OF_SIGNED_BYTE.name=错误用法 - 在带符号的byte值上进行位OR运算rule.findbugs.MSF_MUTABLE_SERVLET_FIELD.name=多线程错误 - 可变的servlet属性rule.findbugs.SE_BAD_FIELD_INNER_CLASS.name=不良实践 - 非serializable类有一个可序列化的内部类rule.findbugs.BIT_ADD_OF_SIGNED_BYTE.name=错误用法 - 在带符号的byte值上进行位add运算rule.findbugs.FI_FINALIZER_ONLY_NULLS_FIELDS.name=不良实践 - Finalizer中子还有null属性rule.findbugs.DE_MIGHT_IGNORE.name=不良实践 - 方法可能忽略异常rule.findbugs.XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER.name=安全风险 - Servlet反射跨域脚本漏洞rule.findbugs.ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD.name=多线程错误 - 使用同步的属性可能发生改变rule.findbugs.SQL_BAD_PREPARED_STATEMENT_ACCESS.name=错误用法 - 方法尝试访问PreparedStatement参数的索引是0rule.findbugs.DM_CONVERT_CASE.name=国际化 - 考虑使用国际化参数型的调用方法版本rule.findbugs.SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS.name=高危 - 类的transient属性不能序列化rule.findbugs.NN_NAKED_NOTIFY.name=多线程错误 - 未使用同步包裹的notifyrule.findbugs.VA_FORMAT_STRING_MISSING_ARGUMENT.name=错误用法 - 格式化字符串引用的参数丢失rule.findbugs.IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION.name=不良实践 - 父类初始化时使用了子类rule.findbugs.SA_LOCAL_SELF_COMPARISON.name=错误用法 - 自己和自己的值比较rule.findbugs.IM_BAD_CHECK_FOR_ODD.name=高危 - 对奇偶判断不能用于负数rule.findbugs.NP_CLOSING_NULL.name=错误用法 - close()调用了一个永远是null的值rule.findbugs.XSS_REQUEST_PARAMETER_TO_JSP_WRITER.name=安全风险 - JSP反射调用跨域脚本漏洞rule.findbugs.IS_FIELD_NOT_GUARDED.name=多线程错误 - 属性不能保证同步访问rule.findbugs.DM_GC.name=性能 - 直接调用垃圾回收，特别是在性能测试中的可疑代码rule.findbugs.IM_MULTIPLYING_RESULT_OF_IREM.name=错误用法 - 整数乘法的结果是整数rule.findbugs.SE_COMPARATOR_SHOULD_BE_SERIALIZABLE.name=不良实践 - Comparator没有实现Serializablerule.findbugs.HE_HASHCODE_NO_EQUALS.name=不良实践 - 类定义了hashCode()但是没定义equals()rule.findbugs.MF_CLASS_MASKS_FIELD.name=错误用法 - 类定义了属性覆盖了父类的属性rule.findbugs.NM_VERY_CONFUSING_INTENTIONAL.name=不良实践 - 非常迷惑的方法名称（可能是内部方法）rule.findbugs.SR_NOT_CHECKED.name=不良实践 - 方法忽略了InputStream.skip()的结果rule.findbugs.LI_LAZY_INIT_STATIC.name=多线程错误 - 错误的对static属性进行了延迟初始化rule.findbugs.DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION.name=错误用法 - 不能使用反射检测没有标记为runtime rentention的注解的存在rule.findbugs.ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH.name=不良实践 - 方法可能在关闭database资源时因为异常失败rule.findbugs.BIT_IOR.name=错误用法 - 不兼容的位掩码（BIT_IOR）rule.findbugs.ODR_OPEN_DATABASE_RESOURCE.name=不良实践 - 方法可能在关闭database资源时失败rule.findbugs.IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN.name=错误用法 - 参数没有被使用，但是被重新赋值了rule.findbugs.SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING.name=安全风险 - 使用非常量字符串创建了一个PreparedStatementrule.findbugs.UUF_UNUSED_FIELD.name=性能 - 无用的属性rule.findbugs.RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE.name=错误用法 - 对一个已经使用的值进行了null检测rule.findbugs.EQ_OTHER_USE_OBJECT.name=错误用法 - equals()方法定义没有覆盖Object.equals(Object)rule.findbugs.SP_SPIN_ON_FIELD.name=多线程错误 - 方法对一个属性循环复制rule.findbugs.SI_INSTANCE_BEFORE_FINALS_ASSIGNED.name=不良实践 - 在所有静态final属性赋值之前static初始化块创建了一个实例rule.findbugs.NP_ALWAYS_NULL_EXCEPTION.name=错误用法 - 方法的异常路径中引用了空指针rule.findbugs.MS_EXPOSE_REP.name=恶意代码漏洞 - Public static方法可能因为返回了一个数组而暴露内部实现rule.findbugs.VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN.name=高危 - 非布尔参数使用%b进行了格式化rule.findbugs.MS_PKGPROTECT.name=恶意代码漏洞 - 属性应该是package protectedrule.findbugs.NP_NONNULL_RETURN_VIOLATION.name=错误用法 - 方法可能返回null，但是声明了 @NonNullrule.findbugs.J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION.name=不良实践 - 在HttpSession中保存了不可序列化的对象rule.findbugs.NM_SAME_SIMPLE_NAME_AS_SUPERCLASS.name=不良实践 - 类名不应该和父类的名称相同rule.findbugs.DMI_BLOCKING_METHODS_ON_URL.name=性能 - URL的equals 和 hashCode 方法会被堵塞rule.findbugs.HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS.name=错误用法 - 在哈希构造中声明了不能哈希的类rule.findbugs.UR_UNINIT_READ.name=错误用法 - 构造方法中对未初始化的类进行了读取rule.findbugs.WA_NOT_IN_LOOP.name=多线程错误 - Wait不在循环中rule.findbugs.DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR.name=错误用法 - 尝试修改ScheduledThreadPoolExecutor的最大数rule.findbugs.RV_RETURN_VALUE_IGNORED2.name=错误用法 - 方法忽略了返回值rule.findbugs.NM_FIELD_NAMING_CONVENTION.name=属性名应该以小写字母开头rule.findbugs.FB_UNEXPECTED_WARNING.name=试验 - 未期待/未期望的findbugs警告rule.findbugs.BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR.name=错误用法 - 基础类型拆箱后用于三元表达式rule.findbugs.DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED.name=不良实践 - Classloaders应该只在doPrivileged块中被创建rule.findbugs.NM_WRONG_PACKAGE.name=错误用法 - 方法没有覆盖父类的方法，因为参数的包不正确rule.findbugs.IL_CONTAINER_ADDED_TO_ITSELF.name=错误用法 - 一个集合被添加到自身rule.findbugs.CI_CONFUSED_INHERITANCE.name=高危 - 类是final的，但是定义了protected属性rule.findbugs.HE_USE_OF_UNHASHABLE_CLASS.name=错误用法 - 在哈希数据结构中使用的类没有定义hashCode()方法rule.findbugs.IJU_SUITE_NOT_STATIC.name=错误用法 - TestCase实现了非static suite方法rule.findbugs.RS_READOBJECT_SYNC.name=多线程错误 - 类的readObject()方法不是同步的rule.findbugs.AM_CREATES_EMPTY_JAR_FILE_ENTRY.name=不良实践 - 创建了一个空的jar方法入口rule.findbugs.VA_FORMAT_STRING_BAD_CONVERSION_FROM_ARRAY.name=错误用法 - 使用格式化字符串对数组进行了无用的格式化rule.findbugs.SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW.name=switch语句失败抛出异常导致无用的存储rule.findbugs.RV_ABSOLUTE_VALUE_OF_HASHCODE.name=错误用法 - 错误的尝试计算带符号的32位hashcodde的绝对值rule.findbugs.EQ_DONT_DEFINE_EQUALS_FOR_ENUM.name=错误用法 - 枚举定义了协变equals()方法定义rule.findbugs.SA_FIELD_DOUBLE_ASSIGNMENT.name=错误用法 - 对属性进行双重赋值rule.findbugs.DMI_COLLECTION_OF_URLS.name=性能 - URL的Maps 和 sets可能是性能大问题rule.findbugs.NM_SAME_SIMPLE_NAME_AS_INTERFACE.name=不良实践 - 类名不应该和实现的接口名相同rule.findbugs.UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR.name=错误用法 - 构造方法没有初始化属性rule.findbugs.TQ_MAYBE_SOURCE_VALUE_REACHES_NEVER_SINK.name=错误用法 - 值可能带着一个类型修饰符，一直使用的方式是与这个类型修饰符相悖的rule.findbugs.SE_NONLONG_SERIALVERSIONID.name=不良实践 - serialVersionUID不是long型rule.findbugs.RV_REM_OF_HASHCODE.name=高危 - hashCode的结果可能是负数negativerule.findbugs.NS_DANGEROUS_NON_SHORT_CIRCUIT.name=高危 - 潜在危险使用非短跳出逻辑rule.findbugs.USM_USELESS_SUBCLASS_METHOD.name=试验 - 方法代理到父类方法rule.findbugs.ITA_INEFFICIENT_TO_ARRAY.name=性能 - 方法使用了toArray()对空数组参数rule.findbugs.DM_MONITOR_WAIT_ON_CONDITION.name=多线程错误 - 根据条件监控wait()的调用rule.findbugs.BOA_BADLY_OVERRIDDEN_ADAPTER.name=错误用法 - 类覆盖了父类中实现的方法适配器错误rule.findbugs.IC_INIT_CIRCULARITY.name=高危 - 初始化死循环rule.findbugs.NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER.name=不良实践 - 使用的标记是未来java版本中的关键字rule.findbugs.EC_UNRELATED_CLASS_AND_INTERFACE.name=错误用法 - equals()比较无关的类和接口rule.findbugs.TQ_MAYBE_SOURCE_VALUE_REACHES_ALWAYS_SINK.name=错误用法 - 值可能没有携带一个类修饰符，但是使用中会一直需要这个类修饰符rule.findbugs.FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER.name=错误用法 - 测试是否与NaN相等rule.findbugs.NM_CONFUSING.name=不良实践 - 迷惑的方法名rule.findbugs.VA_FORMAT_STRING_ARG_MISMATCH.name=错误用法 - 格式化字符串参数的数目与占位符不相等rule.findbugs.NP_NULL_ON_SOME_PATH_EXCEPTION.name=错误用法 - 方法的异常路径中可能引用空指针rule.findbugs.DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE.name=多线程错误 - 同步装箱基本类型可能导致死锁rule.findbugs.IJU_TEARDOWN_NO_SUPER.name=错误用法 - TestCase定义的tearDown没有调用super.tearDown()rule.findbugs.SE_READ_RESOLVE_IS_STATIC.name=错误用法 - readResolve方法没有生命为static方法rule.findbugs.NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE.name=高危 - 这个路径上空指针引用是不可实现的rule.findbugs.UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS.name=错误用法 - 匿名内部类中定义的不可调用的方法rule.findbugs.VA_FORMAT_STRING_BAD_CONVERSION.name=错误用法 - 提供的参数类型与格式化标记不符rule.findbugs.EC_ARRAY_AND_NONARRAY.name=错误用法 - equals()用来比较数组和非数组rule.findbugs.NM_BAD_EQUAL.name=类定义了equal(Object)，应该是equals(Object)吧？rule.findbugs.EC_UNRELATED_TYPES_USING_POINTER_EQUALITY.name=错误用法 - 使用指针比较不同的类型rule.findbugs.STI_INTERRUPTED_ON_CURRENTTHREAD.name=错误用法 - currentThread()调用的不必要用法，调用了interrupted()rule.findbugs.RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION.name=错误用法 - File.separator用做正则表达式rule.findbugs.MWN_MISMATCHED_WAIT.name=多线程错误 - 不匹配的wait()rule.findbugs.IL_INFINITE_LOOP.name=错误用法 - 明显的无限循环rule.findbugs.NP_IMMEDIATE_DEREFERENCE_OF_READLINE.name=高危 - 立刻使用了readLine()的结果rule.findbugs.SC_START_IN_CTOR.name=多线程错误 - 构造方法调用了Thread.start()rule.findbugs.STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE.name=多线程错误 - 静态DateFormatrule.findbugs.HE_EQUALS_NO_HASHCODE.name=不良实践 - 类定义了equals()，但是没有hashCode()rule.findbugs.UL_UNRELEASED_LOCK.name=多线程错误 - 方法没有在任何路径中释放锁rule.findbugs.PZLA_PREFER_ZERO_LENGTH_ARRAYS.name=高危 - 考虑返回空数组而不是nullrule.findbugs.SKIPPED_CLASS_TOO_BIG.name=高危 - 类太大不能分析rule.findbugs.NP_ARGUMENT_MIGHT_BE_NULL.name=错误用法 - 方法没有检查空参数rule.findbugs.UM_UNNECESSARY_MATH.name=性能 - 方法常量调用了静态Math类方法rule.findbugs.NM_WRONG_PACKAGE_INTENTIONAL.name=不良实践 - 方法没有覆盖父类的方法因为参数包名错误rule.findbugs.NP_NONNULL_PARAM_VIOLATION.name=错误用法 - 方法传递null给一个非空参数rule.findbugs.BIT_AND_ZZ.name=错误用法 - 检查 ((...) &amp; 0) == 0 是否成立rule.findbugs.HRS_REQUEST_PARAMETER_TO_COOKIE.name=安全风险 - HTTP cookie可能来自不被信任的输入rule.findbugs.SQL_BAD_RESULTSET_ACCESS.name=错误用法 - 方法尝试访问一个ResultSet，但是使用的index是0rule.findbugs.INT_VACUOUS_COMPARISON.name=高危 - 整形的空比较rule.findbugs.EQ_COMPARETO_USE_OBJECT_EQUALS.name=不良实践 - 类定义了compareTo(...)，但使用了Object.equals()rule.findbugs.DMI_HARDCODED_ABSOLUTE_FILENAME.name=高危 - 类包含一个硬编码的绝对路径rule.findbugs.DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES.name=错误用法 - 集合不应该包含自身rule.findbugs.URF_UNREAD_FIELD.name=性能 - 读不到的属性rule.findbugs.DLS_OVERWRITTEN_INCREMENT.name=错误用法 - 重写了自增rule.findbugs.BIT_SIGNED_CHECK.name=不良实践 - 检测带符号的位运算rule.findbugs.UWF_NULL_FIELD.name=错误用法 - 属性曾经设置为nullrule.findbugs.DE_MIGHT_DROP.name=不良实践 - 方法可能抛出异常rule.findbugs.DMI_BAD_MONTH.name=错误用法 - 对于month错误的常量值rule.findbugs.MS_MUTABLE_ARRAY.name=恶意代码漏洞 - 属性是可变数组rule.findbugs.SE_INNER_CLASS.name=不良实践 - 可序列化的内部类rule.findbugs.OS_OPEN_STREAM_EXCEPTION_PATH.name=不良实践 - 方法可能在关闭流时因为异常而失败rule.findbugs.AT_OPERATION_SEQUENCE_ON_CONCURRENT_ABSTRACTION.name=并发抽象的顺序调用可能不是原子的rule.findbugs.BX_UNBOXING_IMMEDIATELY_REBOXED.name=装箱的值被拆箱，然后立刻重新装箱了rule.findbugs.CO_COMPARETO_RESULTS_MIN_VALUE.name=compareTo()或compare()返回Integer.MIN_VALUErule.findbugs.DLS_DEAD_LOCAL_STORE_SHADOWS_FIELD.name=无用的局部变量可能与实例属性同名rule.findbugs.DMI_ARGUMENTS_WRONG_ORDER.name=方法参数顺序翻转rule.findbugs.DMI_BIGDECIMAL_CONSTRUCTED_FROM_DOUBLE.name=由double构造BigDecimal时没有指定精确度rule.findbugs.DMI_DOH.name=一个明显不合理的方法调用rule.findbugs.DMI_ENTRY_SETS_MAY_REUSE_ENTRY_OBJECTS.name=一个入口的添加可能因为重用Entry对象导致失败rule.findbugs.DM_DEFAULT_ENCODING.name=信任默认字符编码rule.findbugs.ICAST_INT_2_LONG_AS_INSTANT.name=int转换成long，用来当做绝对时间rule.findbugs.INT_BAD_COMPARISON_WITH_INT_VALUE.name=错误比较int值和long常量rule.findbugs.JML_JSR166_CALLING_WAIT_RATHER_THAN_AWAIT.name=在util.concurrent抽象中使用监控样式的wait方法rule.findbugs.NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD.name=读取了未初始化的public或protected属性rule.findbugs.OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE.name=方法可能因为checked exception导致清理流或资源失败rule.findbugs.PZ_DONT_REUSE_ENTRY_OBJECTS_IN_ITERATORS.name=不用在iterator里重用entry对象rule.findbugs.RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE.name=compareTo返回的值与指定的值进行检测rule.findbugs.RV_NEGATING_RESULT_OF_COMPARETO.name=调换了compareTo()/compare()结果的正负rule.findbugs.RV_RETURN_VALUE_IGNORED_INFERRED.name=方法忽略了返回值，这是正常的吗？rule.findbugs.SA_LOCAL_SELF_ASSIGNMENT_INSTEAD_OF_FIELD.name=局部变量给自己赋值而不是赋值到实例变量中rule.findbugs.URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD.name=未被读取的public/protected属性rule.findbugs.UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD.name=未被使用的public 或 protected 属性rule.findbugs.UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD.name=未初始化的public 或 protected 属性rule.findbugs.VA_FORMAT_STRING_USES_NEWLINE.name=格式化代码应该使用%n代替\\nrule.findbugs.VO_VOLATILE_INCREMENT.name=volatile的自增操作不是原子的","categories":[{"name":"findbugs","slug":"findbugs","permalink":"https://lossingdawn.top/categories/findbugs/"}],"tags":[{"name":"findbugs","slug":"findbugs","permalink":"https://lossingdawn.top/tags/findbugs/"}]},{"title":"枚举类工具","slug":"80-枚举类工具","date":"2017-04-19T02:22:00.000Z","updated":"2019-07-27T17:07:16.976Z","comments":true,"path":"p/zh-CN/35732.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/35732.html","excerpt":"","text":"枚举类是程序中常用的一种类型，当经常面对说明与标识混乱的情况。在此记录一个枚举类的写法，方便标识与说明的绑定基类：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public abstract class StandardType &#123; private String key; private String title; public StandardType(String key, String title) &#123; this.title = title; this.key = key; &#125; public String getTitle() &#123; return title; &#125; public static String getTitle(StandardType[] values, String key) &#123; StandardType val = StandardType.getEnum(values, key); if (val == null) &#123; return null; &#125; else &#123; return val.getTitle(); &#125; &#125; public String getKey() &#123; return key; &#125; public static String getKey(StandardType[] values, String title) &#123; for (StandardType val : values) &#123; if (val.getTitle().equals(title)) &#123; return val.getKey(); &#125; &#125; return null; &#125; public static StandardType getEnum(StandardType[] values, String key) &#123; for (StandardType val : values) &#123; if (val.getKey().equals(key)) &#123; return val; &#125; &#125; return null; &#125; public String toString() &#123; return key; &#125; public boolean equals(StandardType type) &#123; if (type == null) &#123; return false; &#125; return this.key.equals(type.getKey()); &#125; /** * get value options based on values * * @param values * @return */ public static List&lt;Map&lt;String, String&gt;&gt; getOpts(StandardType[] values) &#123; List&lt;Map&lt;String, String&gt;&gt; opts = new ArrayList&lt;Map&lt;String, String&gt;&gt;(); Map&lt;String, String&gt; opt = null; for (StandardType val : values) &#123; opt = new HashMap&lt;String, String&gt;(); opt.put(\"key\", val.getKey()); opt.put(\"title\", val.getTitle()); opts.add(opt); &#125; return opts; &#125; /** * get value options based on values(Fuzzy query) * * @param values * @return */ public static List&lt;Map&lt;String, String&gt;&gt; getSimilarOpts(StandardType[] values, String input) &#123; List&lt;Map&lt;String, String&gt;&gt; opts = new ArrayList&lt;Map&lt;String, String&gt;&gt;(); Map&lt;String, String&gt; opt = null; for (StandardType val : values) &#123; if (val.getTitle().contains(input)) &#123; opt = new HashMap&lt;String, String&gt;(); opt.put(\"key\", val.getKey()); opt.put(\"title\", val.getTitle()); opts.add(opt); &#125; &#125; return opts; &#125;&#125;枚举类：1234567891011121314/** * 支付方式 */ public static class PayWay extends StandardType &#123; public final static PayWay WeChatPay = new PayWay(\"WeChatPay\", \"微信支付\"); public final static PayWay AliPay = new PayWay(\"AliPay\", \"支付宝支付\"); public final static PayWay UnionPay = new PayWay(\"UnionPay\", \"银联支付\"); public final static PayWay CashPay = new PayWay(\"CashPay\", \"现金支付\"); public final static PayWay[] values = &#123; WeChatPay, AliPay, UnionPay, CashPay &#125;; public PayWay(String key, String title) &#123; super(key, title); &#125; &#125;使用：12345678910111213public static void main(String[] args) &#123; PayWay.AliPay.toString();// AliPay // dome1 StandardType patWay = PayWay.getEnum(PayWay.values, \"AliPay\"); patWay.getKey();// AliPay patWay.getTitle();// 支付宝支付 // dome2 PayWay.getKey(PayWay.values, \"支付宝支付\");// AliPay PayWay.getTitle(PayWay.values, \"AliPay\");// 支付宝支付 // dome3 List&lt;Map&lt;String, String&gt;&gt; listMap1 = PayWay.getOpts(PayWay.values);//所有map List&lt;Map&lt;String, String&gt;&gt; listMap2 = PayWay.getSimilarOpts(PayWay.values, \"支\");//一条支付宝的map &#125;","categories":[{"name":"java","slug":"java","permalink":"https://lossingdawn.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://lossingdawn.top/tags/java/"}]},{"title":"java.util.LinkedHashMap Cannot Be Cast To","slug":"80-java-util-LinkedHashMap-cannot-be-cast-to","date":"2017-04-17T06:39:00.000Z","updated":"2019-07-27T17:05:13.493Z","comments":true,"path":"p/zh-CN/20934.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/20934.html","excerpt":"","text":"Jackson转换泛型List出现错误java.util.LinkedHashMap cannot be cast to com.xxx12ObjectMapper mapper = new ObjectMapper();mapper.readValue(new File(fileAPI.getRoot(), jsonFileName), Map.class);当使用Jackson解析具体的bean时，应该使用尽量详尽的本来解析，而使用Map.class、List.class解析时，会对具体的bean解析不出使用new TypeReference&lt;List&gt;(){}，或者具体的Object.class，注：Object为具体的解析类","categories":[{"name":"java","slug":"java","permalink":"https://lossingdawn.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://lossingdawn.top/tags/java/"}]},{"title":"Bulk更新mongodb的脚本","slug":"5-bulk更新mongodb的脚本","date":"2017-03-22T05:43:00.000Z","updated":"2019-07-27T17:03:31.865Z","comments":true,"path":"p/zh-CN/58022.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/58022.html","excerpt":"","text":"bulk批处理mongodb，比普通的js脚本来的更快一些。官方网址：https://docs.mongodb.com/manual/reference/method/Bulk/bulk支持的方法：Name Description Bulk.insert()Adds an insert operation to a list of operations. Bulk.find()Specifies the query condition for an update or a remove operation. Bulk.find.removeOne()Adds a single document remove operation to a list of operations. Bulk.find.remove()Adds a multiple document remove operation to a list of operations. Bulk.find.replaceOne()Adds a single document replacement operation to a list of operations. Bulk.find.updateOne()Adds a single document update operation to a list of operations. Bulk.find.update()Adds amulti update operation to a list of operations. Bulk.find.upsert()Specifiesupsert: true for an update operation. Bulk.execute()Executes a list of operations in bulk. Bulk.getOperations()Returns an array of write operations executed in theBulk() operations object. Bulk.tojson()Returns a JSON document that contains the number of operations and batches in theBulk() operations object. Bulk.toString()Returns the Bulk.tojson() results as a string.bulk插入示例：12345 var bulk = db.items.initializeUnorderedBulkOp();bulk.insert( &#123; item: \"abc123\", defaultQty: 100, status: \"A\", points: 100 &#125; );bulk.insert( &#123; item: \"ijk123\", defaultQty: 200, status: \"A\", points: 200 &#125; );bulk.insert( &#123; item: \"mop123\", defaultQty: 0, status: \"P\", points: 0 &#125; );bulk.execute();bulk更新示例：123456789101112131415161718192021222324252627/** * 批量更新数据库对象 * 1. 按条件批量更新 * 2. 无条件批量更新 *//** 1. 按条件批量更新 **/// step 1: get key-valuevar idArray = [];var valueArray = [];var idx = -1;db.conch_ChargeSchedule.find(&#123;'predictChargeValue':&#123;$exists:false&#125;&#125;).forEach(function(obj)&#123; idx++; idArray[idx]=obj._id; valueArray[idx]=obj.planValue;&#125;);// step 2: updatevar bulk = db.conch_ChargeSchedule.initializeUnorderedBulkOp();for(var i=0; i&lt;idArray.length; i++)&#123; bulk.find( &#123; _id: idArray[i] &#125; ).update(&#123; $set: &#123; predictChargeValue: valueArray[i] &#125; &#125;);&#125;bulk.execute();/** 2. 无条件批量更新 **/var bulk = db.conch_ChargeSchedule.initializeUnorderedBulkOp();bulk.find(&#123;&#125;).update(&#123; $set: &#123; isPlanValueUpdatable: true, isStatusUpdatable:true, isStartDateUpdatable:true &#125; &#125;);bulk.execute();123var bulk = db.items.initializeUnorderedBulkOp();bulk.find( &#123; status: \"D\" &#125; ).updateOne( &#123; $set: &#123; status: \"I\", points: \"0\" &#125; &#125; );bulk.execute();打印字符串：12345var bulk = db.items.initializeOrderedBulkOp();bulk.insert( &#123; item: \"abc123\", status: \"A\", defaultQty: 500, points: 5 &#125; );bulk.insert( &#123; item: \"ijk123\", status: \"A\", defaultQty: 100, points: 10 &#125; );bulk.find( &#123; status: \"D\" &#125; ).removeOne();bulk.toString();移除：123var bulk = db.items.initializeUnorderedBulkOp();bulk.find( &#123; status: \"D\" &#125; ).remove();bulk.execute();替换：123var bulk = db.items.initializeUnorderedBulkOp();bulk.find( &#123; item: \"abc123\" &#125; ).replaceOne( &#123; item: \"abc123\", status: \"P\", points: 100 &#125; );bulk.execute();插入并更新：123456789var bulk = db.items.initializeUnorderedBulkOp();bulk.find( &#123; status: \"P\", item: null &#125; ).upsert().updateOne( &#123; $setOnInsert: &#123; defaultQty: 0, inStock: true &#125;, $currentDate: &#123; lastModified: true &#125;, $set: &#123; points: \"0\" &#125; &#125;);bulk.execute();获得历史：12345678var bulk = db.items.initializeUnorderedBulkOp();for (var i = 1; i &lt;= 1500; i++) &#123; bulk.insert( &#123; x: i &#125; );&#125;bulk.execute();bulk.getOperations();// 获得操作历史普通的js脚本更新mongodb库，为单线程阻塞方式，有数据大小限制，数据大了容易断掉。bulk的则不会出现这种状况，效率max","categories":[{"name":"db","slug":"db","permalink":"https://lossingdawn.top/categories/db/"},{"name":"mongo","slug":"db/mongo","permalink":"https://lossingdawn.top/categories/db/mongo/"}],"tags":[{"name":"db","slug":"db","permalink":"https://lossingdawn.top/tags/db/"},{"name":"mongo","slug":"mongo","permalink":"https://lossingdawn.top/tags/mongo/"}]},{"title":"Html提示框插件","slug":"10-html提示框插件","date":"2016-06-16T01:33:00.000Z","updated":"2019-07-27T17:04:54.592Z","comments":true,"path":"p/zh-CN/34881.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/34881.html","excerpt":"","text":"最近工作需要，用到各式各样的提示框，寻找了很久，发现一个的第三方的插件很好用，各种样式、接口良好、允许自定义。官网：http://layer.layui.com/使用需要先引入jq1.8以上：12&lt;script src=\"http://libs.baidu.com/jquery/1.9.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;script src=\"layer/layer.js\"&gt;&lt;/script&gt;","categories":[{"name":"html","slug":"html","permalink":"https://lossingdawn.top/categories/html/"}],"tags":[{"name":"html","slug":"html","permalink":"https://lossingdawn.top/tags/html/"},{"name":"web","slug":"web","permalink":"https://lossingdawn.top/tags/web/"},{"name":"layui","slug":"layui","permalink":"https://lossingdawn.top/tags/layui/"}]},{"title":"ListView在ScrollView中不显示全部的问题","slug":"2-ListView在ScrollView中不显示全部的问题","date":"2015-09-22T02:27:00.000Z","updated":"2019-07-27T17:06:02.788Z","comments":true,"path":"p/zh-CN/59950.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/59950.html","excerpt":"","text":"在实际应用中，我们可能会遇到把ListView放到ScrollView中的情况，在这种情况下，ListView的滑动属性与ScrollView的滑动出现冲突，从而ListView只显示一项。这里提供一种解决方案，就是设置ListView中每个Item的高度显示之，使他失去滑动的属性，从而适应ScrollView的滑动。只需在填充数据之后设置即可：1234567891011121314151617181920212223/** * 通过设置它的高度，让它“放弃”自身滚动属性，而放置到ScrollView中使用的。 * * @param lv */ private void setListViewHeight(ListView lv) &#123; ListAdapter la = lv.getAdapter(); if (null == la) &#123; return; &#125; // calculate height of all items. int h = 0; final int cnt = la.getCount(); for (int i = 0; i &lt; cnt; i++) &#123; View item = la.getView(i, null, lv); item.measure(0, 0); h += item.getMeasuredHeight(); &#125; // reset ListView height ViewGroup.LayoutParams lp = lv.getLayoutParams(); lp.height = h + (lv.getDividerHeight() * (cnt - 1)); lv.setLayoutParams(lp); &#125;","categories":[{"name":"android","slug":"android","permalink":"https://lossingdawn.top/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://lossingdawn.top/tags/android/"}]},{"title":"安卓图片加载框架--Universal-Image-Loader","slug":"2-安卓图片加载框架-Universal-Image-Loader","date":"2015-09-18T09:05:00.000Z","updated":"2019-07-27T17:06:56.197Z","comments":true,"path":"p/zh-CN/17352.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/17352.html","excerpt":"","text":"今天来介绍图片加载的框架Android-Universal-Image-LoaderGITHUB上的下载路径为：https://github.com/nostra13/Android-Universal-Image-Loader也可以自行百度下载。首先来封装的一个类CacheTool ，由于其他加载图片的方法有点繁琐，所以这里仅封装了一个简单实用的加载方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125import android.content.Context;import android.graphics.Bitmap;import android.graphics.Bitmap.CompressFormat;import android.net.Uri;import android.os.Environment;import android.widget.ImageView;import java.io.File;import com.ncct.app.R;import com.nostra13.universalimageloader.cache.disc.impl.UnlimitedDiscCache;import com.nostra13.universalimageloader.cache.disc.naming.Md5FileNameGenerator;import com.nostra13.universalimageloader.cache.memory.impl.UsingFreqLimitedMemoryCache;import com.nostra13.universalimageloader.core.DisplayImageOptions;import com.nostra13.universalimageloader.core.ImageLoader;import com.nostra13.universalimageloader.core.ImageLoaderConfiguration;import com.nostra13.universalimageloader.core.assist.ImageLoadingListener;import com.nostra13.universalimageloader.core.assist.QueueProcessingType;import com.nostra13.universalimageloader.core.download.BaseImageDownloader;/** * 图片加载框架 * * @author jiang * */public class CacheTool &#123; private static File cacheDir = Environment.getDataDirectory(); private static DisplayImageOptions options = new DisplayImageOptions.Builder().showStubImage(R.drawable.loading_img) .showImageForEmptyUri(R.drawable.loading_error).showImageOnFail(R.drawable.loading_error) .cacheInMemory(true).cacheOnDisc(true).bitmapConfig(Bitmap.Config.RGB_565).build(); private static ImageLoaderConfiguration config; public static void Init(Context context) &#123; config = new ImageLoaderConfiguration.Builder(context).memoryCacheExtraOptions(480, 800) // max // width, // max // height，即保存的每个缓存文件的最大长宽 .discCacheExtraOptions(480, 800, CompressFormat.JPEG, 75, null) // Can // slow // ImageLoader, // use // it // carefully // (Better // don't // use // it)/设置缓存的详细信息，最好不要设置这个 .threadPoolSize(3)// 线程池内加载的数量 .threadPriority(Thread.NORM_PRIORITY - 2).denyCacheImageMultipleSizesInMemory() .memoryCache(new UsingFreqLimitedMemoryCache(2 * 1024 * 1024)) // You // can // pass // your // own // memory // cache // implementation/你可以通过自己的内存缓存实现 .memoryCacheSize(2 * 1024 * 1024).discCacheSize(50 * 1024 * 1024) .discCacheFileNameGenerator(new Md5FileNameGenerator())// 将保存的时候的URI名称用MD5 // 加密 .tasksProcessingOrder(QueueProcessingType.LIFO).discCacheFileCount(100) // 缓存的文件数量 // .discCache(new UnlimitedDiscCache(cacheDir))// 自定义缓存路径 .defaultDisplayImageOptions(DisplayImageOptions.createSimple()) .imageDownloader(new BaseImageDownloader(context, 5 * 1000, 30 * 1000)) // connectTimeout // (5 // s), // readTimeout // (30 // s)超时时间 .writeDebugLogs() // Remove for release app .build();// 开始构建 // Initialize ImageLoader with configuration. ImageLoader.getInstance().init(config); &#125; /** * 加载图片并监听回调结果 * * @param iv * @param url * @param mImageLoadingListener */ public static void displayImg(ImageView iv, String url, ImageLoadingListener mImageLoadingListener) &#123; ImageLoader.getInstance().displayImage(url, iv, options, mImageLoadingListener); &#125; /** * 加载图片 * * @param iv * @param url */ public static void displayImg(ImageView iv, String url) &#123; ImageLoader.getInstance().displayImage(url, iv, options); &#125; /** * 清除内存 */ public static void clearMemoryCache() &#123; ImageLoader.getInstance().clearMemoryCache(); &#125; /** * 清除缓存 */ public static void clearDiskCache() &#123; ImageLoader.getInstance().clearDiscCache(); &#125; /** * 得到某个图片的缓存路径 * * @param imageUrl * @return */ public static String getImagePath(String imageUrl) &#123; return ImageLoader.getInstance().getDiscCache().get(imageUrl).getPath(); &#125;&#125;封装好了，里面都有详细的介绍，这里介绍下上面的中的ImageLoadingListener 接口回调，按ctrl + 鼠标左键可以进入jar包里的java文件：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/******************************************************************************* * Copyright 2011-2013 Sergey Tarasevich * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. *******************************************************************************/package com.nostra13.universalimageloader.core.assist;import android.graphics.Bitmap;import android.view.View;/** * Listener for image loading process.&lt;br /&gt; * You can use &#123;@link SimpleImageLoadingListener&#125; for implementing only needed methods. * * @author Sergey Tarasevich (nostra13[at]gmail[dot]com) * @see SimpleImageLoadingListener * @see FailReason * @since 1.0.0 */public interface ImageLoadingListener &#123; /** * Is called when image loading task was started * * @param imageUri Loading image URI * @param view View for image */ void onLoadingStarted(String imageUri, View view); /** * Is called when an error was occurred during image loading * * @param imageUri Loading image URI * @param view View for image. Can be &lt;b&gt;null&lt;/b&gt;. * @param failReason &#123;@linkplain FailReason The reason&#125; why image loading was failed */ void onLoadingFailed(String imageUri, View view, FailReason failReason); /** * Is called when image is loaded successfully (and displayed in View if one was specified) * * @param imageUri Loaded image URI * @param view View for image. Can be &lt;b&gt;null&lt;/b&gt;. * @param loadedImage Bitmap of loaded and decoded image */ void onLoadingComplete(String imageUri, View view, Bitmap loadedImage); /** * Is called when image loading task was cancelled because View for image was reused in newer task * * @param imageUri Loading image URI * @param view View for image. Can be &lt;b&gt;null&lt;/b&gt;. */ void onLoadingCancelled(String imageUri, View view);&#125;从以上代码中我们可以了解到接口中我们可以监听到开始、失败、完成、取消的动作。现在开始使用吧：12345678910private ImageView My_Head;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.personcenter); My_Head = (ImageView) findViewById(R.id.My_Head); String Url = \"http://pic.nipic.com/2007-11-09/200711912453162_2.jpg\"; CacheTool.displayImg(My_Head , Url );&#125;Mark一下，暂存一个直接通过URL获取bitmap的函数，未作内存处理。1234567891011121314151617/** * 获取指定路径的图片 * * @param urlpath * @return * @throws Exception */ public Bitmap getImage(String urlpath) throws Exception &#123; URL url = new URL(urlpath); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(\"GET\"); conn.setConnectTimeout(5000); Bitmap bitmap = null; InputStream inputStream = conn.getInputStream(); bitmap = BitmapFactory.decodeStream(inputStream); return bitmap; &#125;","categories":[{"name":"android","slug":"android","permalink":"https://lossingdawn.top/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://lossingdawn.top/tags/android/"}]},{"title":"移动应用图片的福音--七牛云存储","slug":"2-移动应用图片的福音-七牛云存储","date":"2015-09-18T08:35:00.000Z","updated":"2019-07-27T17:07:23.328Z","comments":true,"path":"p/zh-CN/45182.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/45182.html","excerpt":"","text":"本篇来介绍移动应用图片存储的第三方，官方网址：http://www.qiniu.com/首先，在七牛上要注册开发者账号，需要认证身份证信息。认证完之后，我们来开始进行安卓端的开发。一、准备信息进行图片的上传与下载，我们需要准备几个信息，首先是空间名，然后是域名，再者是密钥对。如下图：二、安卓端图片上传首先我们需要导入JAR包，网址：http://developer.qiniu.com/docs/v6/sdk/android-sdk.html现在来编写上传相关的程序：123456789101112131415161718192021private volatile boolean isCancelled = false;// 取消标志 static String AccessKey =七牛上的公钥; static String SecretKey =七牛上的私钥; UploadManager uploadManager; /** *uploadManager有两种初始化方法，一种是默认配置，一种的自动逸配置 */ // 默认配置 uploadManager=new UploadManager(); //自定义配置 Configuration config= new Configuration.Builder().chunkSize(256 * 1024) // 分片上传时，每片的大小。 // 默认 // 256K .putThreshhold(512 * 1024) // 启用分片上传阀值。默认 512K .connectTimeout(10) // 链接超时。默认 10秒 .responseTimeout(60) // 服务器响应超时。默认 60秒 // .recorder(recorder) // recorder 分片上传时，已上传片记录器。默认 null // .recorder(recorder, keyGen) // keyGen // 分片上传时，生成标识符，用于片记录器区分是那个文件的上传记录 .build(); // 重用 uploadManager。一般地，只需要创建一个 uploadManager 对象 uploadManager = new UploadManager(config);初始化配置搞定了，下面来进行上传操作：1234567891011121314151617181920212223String _uploadToken = getUploadToken(scope); uploadManager.put(SAVE_FILE_DIRECTORY, // 本地上传路径、文件、字符串 key, // 网站上的名字 _uploadToken, // 验证信息 new UpCompletionHandler() &#123; @Override public void complete(String key, ResponseInfo info, JSONObject response) &#123; Log.e(\"qiniu\", info.toString()); Log.i(\"是否成功\", String.valueOf(info.isOK())); &#125; &#125;, new UploadOptions(null, // 自定义变量，key必须以 x: 开始。 \"webp\", // 指定文件的mimeType。 false, // 是否验证上传文件。 new UpProgressHandler() &#123; // 上传进度回调。 public void progress(String key, double percent) &#123; Log.i(\"qiniu\", key + \": \" + percent); &#125; &#125;, new UpCancellationSignal() &#123; // 取消上传，当isCancelled()返回true时，不再执行更多上传。 public boolean isCancelled() &#123; return isCancelled; &#125; &#125;) );在上传的操作中唯一需要我们头疼的就是_uploadToken，下面来介绍如何生成一个_uploadToken令牌信息：12345678910111213141516171819202122232425262728293031323334353637383940414243444546public String getUploadToken(String scope) &#123; // 构造上传策略 JSONObject json = new JSONObject(); long dataline = System.currentTimeMillis() / 1000 + 3600; String uploadToken = null; try &#123; json.put(\"deadline\", dataline);// 有效时间为一个小时 json.put(\"scope\", scope);// 上传空间 String encodedPutPolicy = UrlSafeBase64.encodeToString(json.toString().getBytes()); byte[] sign = HmacSHA1Encrypt(encodedPutPolicy, SecretKey); String encodedSign = UrlSafeBase64.encodeToString(sign); uploadToken = AccessKey + ':' + encodedSign + ':' + encodedPutPolicy;// 登录信息token=公钥：加密的json信息：原始json信息 &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return uploadToken;&#125;/////////////// ************************************//////////////////////////** * 使用 HMAC-SHA1 签名方法对对encryptText进行签名 * * @param encryptText * 被签名的字符串 * @param encryptKey * 密钥 * @return * @throws Exception */private static final String MAC_NAME = \"HmacSHA1\";private static final String ENCODING = \"UTF-8\";private byte[] HmacSHA1Encrypt(String encryptText, String encryptKey) throws Exception &#123; byte[] data = encryptKey.getBytes(ENCODING); // 根据给定的字节数组构造一个密钥,第二参数指定一个密钥算法的名称 SecretKey secretKey = new SecretKeySpec(data, MAC_NAME); // 生成一个指定 Mac 算法 的 Mac 对象 Mac mac = Mac.getInstance(MAC_NAME); // 用给定密钥初始化 Mac 对象 mac.init(secretKey); byte[] text = encryptText.getBytes(ENCODING); // 完成 Mac 操作 return mac.doFinal(text);&#125;好了现在我们就可以成功上传了。三、编写其他操作1、取消操作123456/** * 点击取消按钮，让 UpCancellationSignal#isCancelled() 方法返回 true ，以停止上传 */public void cancell() &#123; isCancelled = true;&#125;2、删除操作1234567891011121314151617181920212223242526272829303132333435363738/** * 删除指定空间、名称的资源 * * @param bucket 空间名 * @param fileName 文件名 * @return */public boolean deleteFile(String bucket, String fileName) &#123; try &#123; String entryUrl = bucket + \":\" + fileName; String encodedEntryURI = UrlSafeBase64.encodeToString(entryUrl.getBytes()); String host = \"http://rs.qiniu.com\"; String path = \"/delete/\" + encodedEntryURI; String url = host + path; byte[] sign = HmacSHA1Encrypt(path + \"\\n\", SecretKey); String encodedSign = UrlSafeBase64.encodeToString(sign); String authorization = AccessKey + ':' + encodedSign; HttpClient httpClient = new DefaultHttpClient(); HttpPost mothod = new HttpPost(url); mothod.setHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); mothod.setHeader(\"Authorization\", \"QBox \" + authorization); // 连接超时时间 httpClient.getParams().setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 20000); // 读取超时时间 httpClient.getParams().setParameter(CoreConnectionPNames.SO_TIMEOUT, 20000); HttpResponse response = httpClient.execute(mothod); StatusLine statusLine = response.getStatusLine(); int statusCode = statusLine.getStatusCode(); if (statusCode == HttpStatus.SC_OK) &#123; Log.e(\"删除结果\", \"successful\"); return true; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; Log.e(\"删除结果\", \"false\"); return false;&#125;好了，暂时就先到这里，虽然进行了一些封装，但是对自己的封装不很满意所以暂时不发了，以后封装完善了再发吧，这些已经足够新手理解了。下篇介绍获取网络图片并显示。主要用到目前最好的图片加载框架ImageLoad。","categories":[{"name":"android","slug":"android","permalink":"https://lossingdawn.top/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://lossingdawn.top/tags/android/"},{"name":"qiniu","slug":"qiniu","permalink":"https://lossingdawn.top/tags/qiniu/"},{"name":"cloud","slug":"cloud","permalink":"https://lossingdawn.top/tags/cloud/"}]},{"title":"（转）Android自定义控件","slug":"2-（转）android自定义控件","date":"2015-08-10T06:31:00.000Z","updated":"2019-08-25T16:45:47.760Z","comments":true,"path":"p/zh-CN/61104.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/61104.html","excerpt":"","text":"原帖地址：http://my.oschina.net/wangjunhe/blog/99764创建新的控件：作为一个有创意的开发者，你经常会遇到安卓原生控件无法满足你的需求。为了优化你的界面和工作流程，安卓允许你去继承已经存在的控件或者实现你自己的控件。那么最好的方式去创建一个新的控件是什么？ 这主要取决你想要完成什么。1.有些基本功能原生控件都能提供，所以这个时候你只需要继承并对控件进行扩展。通过重写它的事件，onDraw,但是始终都保持都父类方法的调用。2.组合控件 就是通过合并几个控件的功能来生成一个控件。3.完完整整创建一个新的控件。1.修改存在的控件例子：123456789101112131415161718192021222324252627282930313233 public class MyTextView extends TextView &#123; public MyTextView(Context context, AttributeSet ats, int defStyle) &#123; super(context, ats, defStyle); &#125; public MyTextView(Context context) &#123; super(context); &#125; public MyTextView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public void onDraw(Canvas canvas) &#123; // 在画布上画文本之下的内容 // 保证默认的文本渲染 super.onDraw(canvas); // 在画布上画文本之上的内容 &#125; @Override public boolean onKeyDown(int keyCode, KeyEvent keyEvent) &#123; // 写自己的控制 // 保持父类默认的控制 return super.onKeyDown(keyCode, keyEvent); &#125;&#125;2.组合控件1.最简单的方式，是定义了XML布局文件，然后用include实现重用。（。。。这也算啊。。。）2.去合并一个控件 通常你自定义的控件需要继承一个ViewGroup（通常就是Layout），就像：123456789 public class MyCompoundView extends LinearLayout &#123; public MyCompoundView(Context context) &#123; super(context); &#125; public MyCompoundView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125;&#125;就像activity，比较好的设计一个混合的控件UI布局是使用一个外部的layout资源。这里我们模拟定义一个：1234567891011121314151617&lt;?xml version=”1.0” encoding=”utf-8”?&gt; &lt;LinearLayout xmlns:android=”http://schemas.android.com/apk/res/android” android:orientation=”vertical” android:layout_width=”match_parent” android:layout_height=”wrap_content”&gt; &lt;EditText android:id=”@+id/editText” android:layout_width=”match_parent” android:layout_height=”wrap_content” /&gt; &lt;Button android:id=”@+id/clearButton” android:layout_width=”match_parent” android:layout_height=”wrap_content” android:text=”Clear” /&gt; &lt;/LinearLayout&gt;** 然后在构造函数初始化的时候：**123456789101112131415161718192021222324 public class ClearableEditText extends LinearLayout &#123; EditText editText; Button clearButton; public ClearableEditText(Context context) &#123; super(context); // Inflate the view from the layout resource. String infService = Context.LAYOUT_INFLATER_SERVICE; LayoutInflater li; li = (LayoutInflater) getContext().getSystemService(infService); /*这句很关键，解析反射资源文件，然后将布局附加到当前的控件，也就是this*/ li.inflate(R.layout.clearable_edit_text, this, true); /* 因为反射成功后的布局已经附加上了，那么直接可以findViewById*/ editText = (EditText) findViewById(R.id.editText); clearButton = (Button) findViewById(R.id.clearButton); // 下面自定义的方法就是为控件注册监听，不解释了 hookupButton(); &#125;&#125;使用：在activity_main.xml &lt;com.example.customview.MyCompoundView android:layout_width=“match_parent” android:layout_height=“wrap_content” /&gt; 3. 完完全全自定义控件通常是继承View或者SurfaceView ，View类提供一个Canvas（画布）和一系列的画的方法，还有Paint（画笔）。使用它们去创建一个自定义的UI。你可以重写事件，包括屏幕接触或者按键按下等等，用来提供与用户交互。1.如果你不需要快速重画和3D图像的效果，那么让View作为父类提供一个轻量级的解决方案。2.如若不然，就需要使用SurfaceView作为父类，这样你就可以提供一个后台线程去画和使用OPENGL去实现你的图像。这个就相对重量级了，如果你的视图需要经常更新，然后由需要显示比较复杂的图像信息（尤其是在游戏和3D可视化），SurfaceView将是更好的选择。在这里我们讨论前者，后者后期再讨论。一般你需要重写2个方法： 1.onMeasure什么是onMeasure?下面转载一段文章：View在屏幕上显示出来要先经过measure（计算）和layout（布局）. 1、什么时候调用onMeasure方法？ 当控件的父元素正要放置该控件时调用.父元素会问子控件一个问题，“你想要用多大地方啊？”，然后传入两个参数——widthMeasureSpec和heightMeasureSpec. 这两个参数指明控件可获得的空间以及关于这个空间描述的元数据.更好的方法是你传递View的高度和宽度到setMeasuredDimension方法里,这样可以直接告诉父控件，需要多大地方放置子控件.widthMeasureSpec和heightMeasureSpec这2个参数都是整形是出于效率的考虑，所以经常要做的就是对其解码=&gt;121. int specMode = MeasureSpec.getMode(measureSpec);1. int specSize = MeasureSpec.getSize(measureSpec);依据specMode的值，（MeasureSpec有3种模式分别是UNSPECIFIED, EXACTLY和AT_MOST）如果是AT_MOST，specSize 代表的是最大可获得的空间； 如果是EXACTLY，specSize 代表的是精确的尺寸； 如果是UNSPECIFIED，对于控件尺寸来说，没有任何参考意义。2、那么这些模式和我们平时设置的layout参数fill_parent, wrap_content有什么关系呢？ 经过代码测试就知道，当我们设置width或height为fill_parent时，容器在布局时调用子 view的measure方法传入的模式是EXACTLY，因为子view会占据剩余容器的空间，所以它大小是确定的。 而当设置为 wrap_content时，容器传进去的是AT_MOST, 表示子view的大小最多是多少，这样子view会根据这个上限来设置自己的尺寸。当子view的大小设置为精确值时，容器传入的是EXACTLY, 而MeasureSpec的UNSPECIFIED模式表示你没有指定大小。View的onMeasure方法默认行为是当模式为UNSPECIFIED时，设置尺寸为mMinWidth(通常为0)或者背景drawable的最小尺寸，当模式为EXACTLY或者AT_MOST时，尺寸设置为传入的MeasureSpec的大小。 有个观念需要纠正的是，fill_parent应该是子view会占据剩下容器的空间，而不会覆盖前面已布局好的其他view空间，当然后面布局子 view就没有空间给分配了，所以fill_parent属性对布局顺序很重要。以前所想的是把所有容器的空间都占满了，难怪google在2.2版本里 把fill_parent的名字改为match_parent. 在两种情况下，你必须绝对的处理这些限制。在一些情况下，它可能会返回超出这些限制的尺寸，在这种情况下，你可以让父元素选择如何对待超出的View，使用裁剪还是滚动等技术。 接下来的框架代码给出了处理View测量的典型实现：12345678910111213141516171819202122232425262728293031@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int measuredHeight = measureHeight(heightMeasureSpec); int measuredWidth = measureWidth(widthMeasureSpec); setMeasuredDimension(measuredHeight, measuredWidth); // 记住这句可不能省。&#125; private int measureHeight(int measureSpec) &#123; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); // Default size if no limits are specified. int result = 500; if (specMode == MeasureSpec.AT_MOST) &#123; // Calculate the ideal size of your // control within this maximum size. // If your control fills the available // space return the outer bound. result = specSize; &#125; else if (specMode == MeasureSpec.EXACTLY) &#123; // If your control can fit within these bounds return that value. result = specSize; &#125; return result;&#125; private int measureWidth(int measureSpec) &#123; // 代码基本类似measureHeight&#125;总结：通过12int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec);这2个值，然后计算自己想要占有的宽和高。2.onDraw这个不解释了。（后期会细说canvas和paint）","categories":[{"name":"android","slug":"android","permalink":"https://lossingdawn.top/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://lossingdawn.top/tags/android/"}]},{"title":"Android值类型转换","slug":"2-Android值类型转换","date":"2015-06-04T08:58:00.000Z","updated":"2019-07-27T17:03:21.695Z","comments":true,"path":"p/zh-CN/36850.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/36850.html","excerpt":"","text":"各种数字类型转换成字符串型：String s = String.valueOf(value); // 其中 value 为任意一种数字类型。字符串型转换成各种数字类型：1234567String s = \"169\";byte b = Byte.parseByte( s );short t = Short.parseShort( s );int i = Integer.parseInt( s );long l = Long.parseLong( s );Float f = Float.parseFloat( s );Double d = Double.parseDouble( s );","categories":[{"name":"android","slug":"android","permalink":"https://lossingdawn.top/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://lossingdawn.top/tags/android/"}]},{"title":"【Android UI】顶部or底部菜单的循环滑动效果一","slug":"2-【Android-UI】顶部or底部菜单的循环滑动效果一","date":"2015-04-29T23:45:00.000Z","updated":"2019-07-27T17:06:48.110Z","comments":true,"path":"p/zh-CN/15985.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/15985.html","excerpt":"","text":"实现了分页的滑动效果，做的demo流畅运行 注：貌似支持的样式（控件）有一定的限制，我试过短信的listview页面，暂无法实现滑动效果java文件:MainActivity.java、Activity1.java、Activity2.java、Activity3.java、Activity4.javaMainActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172package com.example.tabhostmove;import android.app.Activity;import android.app.TabActivity;import android.content.Intent;import android.os.Bundle;import android.util.Log;import android.view.GestureDetector;import android.view.Menu;import android.view.MenuItem;import android.view.MotionEvent;import android.widget.TabHost;import android.widget.TabHost.TabSpec;public class MainActivity extends TabActivity &#123; private TabHost tabHost; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); init(); &#125; private void init() &#123; // TODO Auto-generated method stub tabHost = getTabHost(); // 页面1 TabSpec spec1 = tabHost.newTabSpec(\"1\"); spec1.setIndicator(\"1\", getResources().getDrawable(R.drawable.ic_launcher)); Intent intent1 = new Intent(this, Activity1.class); spec1.setContent(intent1); // 页面2 TabSpec spec2 = tabHost.newTabSpec(\"2\"); spec2.setIndicator(\"2\", getResources().getDrawable(R.drawable.ic_launcher)); Intent intent2 = new Intent(this, Activity2.class); spec2.setContent(intent2); // 页面3 TabSpec spec3 = tabHost.newTabSpec(\"3\"); spec3.setIndicator(\"3\", getResources().getDrawable(R.drawable.ic_launcher)); Intent intent3 = new Intent(this, Activity3.class); spec3.setContent(intent3); // 页面4 TabSpec spec4 = tabHost.newTabSpec(\"4\"); spec4.setIndicator(\"4\", getResources().getDrawable(R.drawable.ic_launcher)); Intent intent4 = new Intent(this, Activity4.class); spec4.setContent(intent4); tabHost.addTab(spec1); tabHost.addTab(spec2); tabHost.addTab(spec3); tabHost.addTab(spec4); &#125; private GestureDetector detector = new GestureDetector(new GestureDetector.SimpleOnGestureListener() &#123; @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123; if ((e2.getRawX() - e1.getRawX()) &gt; 80) &#123; showNext(); return true; &#125; if ((e1.getRawX() - e2.getRawX()) &gt; 80) &#123; showPre(); return true; &#125; return super.onFling(e1, e2, velocityX, velocityY); &#125; &#125;); @Override public boolean onTouchEvent(MotionEvent event) &#123; detector.onTouchEvent(event); return super.onTouchEvent(event); &#125; /** * 当前页面索引 */ int i = 0; /** * 显示下一个页面 */ protected void showNext() &#123; // 三元表达式控制3个页面的循环. //tabHost.setCurrentTab(i = i == 3 ? i = 0 : ++i); //Log.i(\"kennet\", i + \"\"); //四个页面的下一个循环 switch(i) &#123; case 0: i++; tabHost.setCurrentTab(i); break; case 1: i++; tabHost.setCurrentTab(i); break; case 2: i++; tabHost.setCurrentTab(i); break; case 3: i=0; tabHost.setCurrentTab(i); break; &#125; &#125; /** * 显示前一个页面 */ protected void showPre() &#123; // 三元表达式控制3个页面的循环. //tabHost.setCurrentTab(i = i == 0 ? i = 3 : --i); //四个页面的上一个循环 switch(i) &#123; case 0: i=3; tabHost.setCurrentTab(i); break; case 1: i--; tabHost.setCurrentTab(i); break; case 2: i--; tabHost.setCurrentTab(i); break; case 3: i--; tabHost.setCurrentTab(i); break; &#125; &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.main, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); if (id == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(item); &#125;&#125;xml布局文件：activity_main.xml、activit1.xml、activit2.xml、activit3.xml、activit4.xmlactivity_main.xml12345678910111213141516171819202122232425&lt;TabHost xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@android:id/tabhost\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;LinearLayout android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:orientation=\"vertical\" &gt; &lt;TabWidget android:id=\"@android:id/tabs\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" /&gt; &lt;FrameLayout android:id=\"@android:id/tabcontent\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" &gt; &lt;/FrameLayout&gt; &lt;/LinearLayout&gt;&lt;/TabHost&gt;注：activity1、2、3、4是测试的页面，随便建几个即可，别忘了在AndroidManifest.xml里注册页面的活动实现效果：","categories":[{"name":"android","slug":"android","permalink":"https://lossingdawn.top/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://lossingdawn.top/tags/android/"}]},{"title":"【Android UI】侧滑栏的使用（HorizontalScrollView控件的使用）","slug":"2-【Android-UI】侧滑栏的使用（HorizontalScrollView控件的使用）","date":"2015-04-29T08:12:00.000Z","updated":"2019-07-27T17:06:45.030Z","comments":true,"path":"p/zh-CN/48435.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/48435.html","excerpt":"","text":"主要的用到的控件：HorizontalScrollView主要的功能：把几张图片解析成一张图片，在一个容器中呈现。布局文件xmlside_bar_scollview.xml//显示view的容器123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;HorizontalScrollView android:id=\"@+id/MyScrollView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;LinearLayout android:id=\"@+id/ll_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizontal\" &gt; &lt;/LinearLayout&gt; &lt;/HorizontalScrollView&gt;&lt;/LinearLayout&gt;home.xml//显示的主页面1234567891011121314&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:background=\"@drawable/home_bg\"&gt; &lt;TextView android:id=\"@+id/textView1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"主页\" /&gt;&lt;/LinearLayout&gt;menu.xml//显示的菜单页面12345678910111213&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@drawable/menu_bg\"&gt; &lt;TextView android:id=\"@+id/textView1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"菜单\" /&gt;&lt;/FrameLayout&gt;MainActivity.java//主活动12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.example.side_bar_scrollview;import android.annotation.SuppressLint;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.view.ViewTreeObserver.OnGlobalLayoutListener;import android.widget.HorizontalScrollView;import android.widget.LinearLayout;public class MainActivity extends Activity &#123; private HorizontalScrollView scrollview; private LinearLayout view_layout; private int width; private int height; private View home_view; private View menu_view; private float rate=0.4f; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //关联界面ID setContentView(R.layout.side_bar_scollview); //关联控件ID scrollview=(HorizontalScrollView) findViewById(R.id.MyScrollView); view_layout=(LinearLayout) findViewById(R.id.ll_layout); //监听布局 MyLayoutListener(); //隐藏滚动条 scrollview.setHorizontalScrollBarEnabled(false); &#125; /** * 监听布局的变化 * 1.getViewTreeObserver --- view事件的观察者 * 2.addOnGlobalLayoutListener * 当在一个视图树中全局布局发生改变或者视图树中的某个视图的可视状态发生改变时， * 所要调用的回调函数的接口类 * */ private void MyLayoutListener()&#123; scrollview.getViewTreeObserver().addOnGlobalLayoutListener( new OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; // TODO Auto-generated method stub //移除之前已经注册的全局布局的回调函数，使图片不会循环连在一起 view_layout.getViewTreeObserver() .removeOnGlobalLayoutListener(this); //获取最后一次调用measure()测量得到的scrollview的宽和高 height = scrollview.getMeasuredHeight(); width = scrollview.getMeasuredWidth(); //解析主页和菜单的布局 home_view=getLayoutInflater().inflate(R.layout.home, null); menu_view=getLayoutInflater().inflate(R.layout.menu, null); //添加view到view_layout view_layout.addView(menu_view, (int)(width*rate), height); view_layout.addView(home_view, width, height); &#125; &#125;); &#125;&#125;效果图：","categories":[{"name":"android","slug":"android","permalink":"https://lossingdawn.top/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://lossingdawn.top/tags/android/"}]},{"title":"Android问题解决","slug":"2-Android问题解决","date":"2015-04-26T11:26:00.000Z","updated":"2019-07-27T17:03:25.342Z","comments":true,"path":"p/zh-CN/30030.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/30030.html","excerpt":"","text":"1、clean之后R文件消失clean之后R文件消失是因为布局的XML文件存在错误，无法编译你的资源文件，所以无法自动生成R文件，在Problem、LogCat等界面查看错误的原因，把错误改正即可；此外还有可能是引用问题，查看开头的import是否错误的引用了android的组件，把他删掉，重新引用具体包的路径。","categories":[{"name":"android","slug":"android","permalink":"https://lossingdawn.top/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://lossingdawn.top/tags/android/"}]},{"title":"Android 设置 横屏 竖屏","slug":"2-Android-设置-横屏-竖屏","date":"2015-04-26T10:59:00.000Z","updated":"2019-07-27T17:03:17.396Z","comments":true,"path":"p/zh-CN/57847.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/57847.html","excerpt":"","text":"方法一：在AndroidManifest.xml中配置如果不想让软件在横竖屏之间切换，最简单的办法就是在项目的AndroidManifest.xml中找到你所指定的activity中加上android:screenOrientation属性，他有以下几个参数：“unspecified”:默认值 由系统来判断显示方向.判定的策略是和设备相关的，所以不同的设备会有不同的显示方向. “landscape”:横屏显示（宽比高要长） “portrait”:竖屏显示(高比宽要长) “user”:用户当前首选的方向 “behind”:和该Activity下面的那个Activity的方向一致(在Activity堆栈中的) “sensor”:有物理的感应器来决定。如果用户旋转设备这屏幕会横竖屏切换。 “nosensor”:忽略物理感应器，这样就不会随着用户旋转设备而更改了（&quot;unspecified&quot;设置除外）。方法二：在java代码中设置设置横屏代码：setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);//横屏设置竖屏代码：setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);//竖屏因为横屏有两个方向的横法，而这个设置横屏的语句，如果不是默认的横屏方向，会把已经横屏的屏幕旋转180°。所以可以先判断是否已经为横屏了，如果不是再旋转，不会让用户觉得转的莫名其妙啦！代码如下：if(this.getResources().getConfiguration().orientation ==Configuration.ORIENTATION_PORTRAIT){ setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);}","categories":[{"name":"android","slug":"android","permalink":"https://lossingdawn.top/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://lossingdawn.top/tags/android/"}]},{"title":"Uses-Permission权限列表","slug":"2-uses-permission权限列表","date":"2015-04-08T03:55:00.000Z","updated":"2019-07-27T17:06:31.006Z","comments":true,"path":"p/zh-CN/50489.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/50489.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350android.permission.ACCESS_CHECKIN_PROPERTIES允许读写访问”properties”表在checkin数据库中，改值可以修改上传android.permission.ACCESS_COARSE_LOCATION允许一个程序访问CellID或WiFi来获取粗略的位置android.permission.ACCESS_FINE_LOCATION允许一个程序访问精良位置(如GPS)android.permission.ACCESS_LOCATION_EXTRA_COMMANDS允许应用程序访问额外的位置提供命令android.permission.ACCESS_MOCK_LOCATION允许程序创建模拟位置用于测试android.permission.ACCESS_NETWORK_STATE允许程序访问有关的网络信息android.permission.ACCESS_SURFACE_FLINGER允许程序使用SurfaceFlinger底层特性android.permission.ACCESS_WIFI_STATE允许程序访问Wi-Fi网络状态信息android.permission.ACCOUNT_MANAGER允许一个应用程序启动账户认证，该权限只能系统去设置android.permission.AUTHENTICATE_ACCOUNTS允许应用程序的验证账户扮演一个账户管理者android.permission.BATTERY_STATS允许程序更新手机电池统计信android.permission.BIND_APPWIDGET许应用告诉AppWidget哪个应用能够访问该AppWidget的数据android.permission.BIND_DEVICE_ADMIN必须通过关机接收者的请求，来确保只有系统能够与之交互android.permission.BIND_INPUT_METHOD必须通过InputMethodService的请求，来确保只有系统能够与之绑定android.permission.BIND_WALLPAPER必须通过WallpaperService的请求，来确保只有系统能够与之绑定android.permission.BLUETOOTH允许程序连接到已配对的蓝牙设备android.permission.BLUETOOTH_ADMIN允许程序发现和配对蓝牙设备android.permission.BRICK请求能够禁用设备(非常危险)android.permission.BROADCAST_PACKAGE_REMOVED允许应用发出一个程序包被移除的广播消息android.permission.BROADCAST_SMS允许应用发出一个收到短信的消息android.permission.BROADCAST_STICKY允许应用发出一个与intent相连的消息 android.permission.BROADCAST_WAP_PUSH允许应用发出一个收到WAP PUSH的广播消息android.permission.CALL_PHONE允许一个程序初始化一个电话拨号，不需通过拨号用户界面需要用户确认android.permission.CALL_PRIVILEGED允许一个程序拨打任何号码，包含紧急号码无需通过拨号用户界面需要用户确认android.permission.CAMERA请求访问使用照相设备android.permission.CHANGE_COMPONENT_ENABLED_STATE允许一个程序是否改变一个组件或其他的启用或禁用android.permission.CHANGE_CONFIGURATION允许一个程序修改当前设置，如本地化android.permission.CHANGE_NETWORK_STATE允许程序改变网络连接状态android.permission.CHANGE_WIFI_STATE允许程序改变Wi-Fi连接状态android.permission.CLEAR_APP_CACHE允许一个程序在设备中清除所有安装的程序的缓存android.permission.CLEAR_APP_USER_DATA允许一个程序清除用户数据android.permission.CONTROL_LOCATION_UPDATES允许启用禁止位置更新提示从无线模块android.permission.DELETE_CACHE_FILES允许程序删除缓存文件android.permission.DELETE_PACKAGES允许一个程序删除包android.permission.DEVICE_POWER允许访问底层电源管理android.permission.DIAGNOSTIC允许程序RW诊断资源android.permission.DISABLE_KEYGUARD允许程序禁用键盘锁android.permission.DUMP允许程序返回状态抓取信息从系统服务android.permission.EXPAND_STATUS_BAR允许一个程序扩展收缩在状态栏,android开发网提示应该是一个类似Windows Mobile中的托盘程序android.permission.FACTORY_TEST作为一个工厂测试程序，运行在root用户android.permission.FLASHLIGHT允许访问闪光灯,其中HTC Dream不包含闪光灯android.permission.FORCE_BACK允许应用强制执行返回操作而不论是不是最终的activity android.permission.GET_ACCOUNTS允许访问在Accounts Service中的一个帐户列表android.permission.GET_PACKAGE_SIZE允许一个程序获取任何package占用空间容量android.permission.GET_TASKS允许一个程序获取信息有关当前或最近运行的任务，一个缩略的任务状态，是否活动等等android.permission.GLOBAL_SEARCH可以被内容提供者用来允许使用全程搜索他们的数据android.permission.HARDWARE_TEST允许访问硬件android.permission.INJECT_EVENTS允许一个程序截获用户事件如按键、触摸、轨迹球等等到一个时间流android.permission.INSTALL_PACKAGES允许一个程序安装packagesandroid.permission.INTERNAL_SYSTEM_WINDOW允许打开窗口使用系统用户界面android.permission.INTERNET允许程序打开网络socketsandroid.permission.KILL_BACKGROUND_PROCESSES允许应用去呼叫killBackgroundProcesses方法android.permission.MANAGE_ACCOUNTS允许程序去管理账户列表(在账户管理者中)android.permission.MANAGE_APP_TOKENS允许程序管理(创建、催后、 z- order默认向z轴推移)程序引用在窗口管理器中android.permission.MASTER_CLEAR目前还没有明确的解释android.permission.MODIFY_AUDIO_SETTINGS允许程序修改全局音频设置android.permission.MODIFY_PHONE_STATE允许修改话机状态，如电源，人机接口等android.permission.MODIFY_FORMAT_FILESYSTEMS允许格式化可移除的存储仓库的文件系统android.permission.MOUNT_UNMOUNT_FILESYSTEMS允许挂载和反挂载文件系统可移动存储android.permission.PERSISTENT_ACTIVITY允许一个程序设置他的activities显示android.permission.PROCESS_OUTGOING_CALLS允许程序监视、修改有关播出电话android.permission.READ_CALENDAR允许程序读取用户日历数据android.permission.READ_CONTACTS允许程序读取用户联系人数据android.permission.READ_FRAME_BUFFER允许程序屏幕波或和更多常规的访问帧缓冲数据android.permission.READ_HISTORY_BOOKMARKS允许应用去读取(非写)用户浏览历史和书签android.permission.READ_INPUT_STATE允许程序返回当前按键状态android.permission.READ_LOGS允许程序读取底层系统日志文件android.permission.READ_OWNER_DATA允许程序读取所有者数据android.permission.READ_PHONE_STATE允许读取电话的状态android.permission.READ_SMS允许程序读取短信息(Allows an application to read SMS messages.)android.permission.READ_SYNC_SETTINGS允许程序读取同步设置android.permission.READ_SYNC_STATS允许程序读取同步状态android.permission.REBOOT请求能够重新启动设备android.permission.RECEIVE_BOOT_COMPLETED允许一个程序接收到 ACTION_BOOT_COMPLETED广播在系统完成启动android.permission.RECEIVE_MMS允许一个程序监控将收到MMS彩信,记录或处理android.permission.RECEIVE_SMS允许程序监控一个将收到短信息，记录或处理android.permission.RECEIVE_WAP_PUSH允许程序监控将收到WAP PUSH信息android.permission.RECORD_AUDIO允许程序录制音频android.permission.REORDER_TASKS允许程序改变Z轴排列任务android.permission.RESTART_PACKAGES允许程序重新启动其他程序(此值已废弃使用)android.permission.SEND_SMS允许程序发送SMS短信android.permission.SET_ACTIVITY_WATCHER允许程序监控或控制activities已经启动全局系统中android.permission.SET_ALWAYS_FINISH允许程序控制是否活动间接完成在处于后台时android.permission.SET_ANIMATION_SCALE修改全局信息比例android.permission.SET_DEBUG_APP配置一个程序用于调试android.permission.SET_ORIENTATION允许底层访问设置屏幕方向和实际旋转android.permission.SET_PREFERRED_APPLICATIONS允许一个程序修改列表参数PackageManager.addPackageToPreferred()和PackageManager.removePackageFromPreferred()方法 android.permission.SET_PROCESS_LIMIT允许设置最大的运行进程数量android.permission.SET_TIME允许应用设置系统时间android.permission.SET_TIME_ZONE允许程序设置系统时区时间android.permission.SET_WALLPAPER允许程序设置壁纸 android.permission.SET_WALLPAPER_HINTS允许程序设置壁纸hitsandroid.permission.SIGNAL_PERSISTENT_PROCESSES允许程序请求发送信号到所有显示的进程中android.permission.STATUS_BAR允许程序打开、关闭或禁用状态栏及图标android.permission.SUBSCRIBED_FEEDS_READ允许一个程序访问订阅RSS Feed内容提供android.permission.SUBSCRIBED_FEEDS_WRITE系统暂时保留改设置,android.permission.SYSTEM_ALERT_WINDOW允许一个程序打开窗口使用 TYPE_SYSTEM_ALERT，显示在其他所有程序的顶层android.permission.UPDATE_DEVICE_STATS允许应用更新设备资料信息android.permission.USE_CREDENTIALS允许应用从管理器得到授权请求android.permission.VIBRATE允许访问振动设备android.permission.WAKE_LOCK允许使用PowerManager的 WakeLocks保持进程在休眠时从屏幕消失 android.permission.WRITE_APN_SETTINGS允许程序写入API设置android.permission.WRITE_CALENDAR允许一个程序写入但不读取用户日历数据android.permission.WRITE_CONTACTS允许程序写入但不读取用户联系人数据android.permission.WRITE_EXTERNAL_STORAGE允许应用写（非读）用户的外部存储器android.permission.WRITE_GSERVICES允许程序修改Google服务地图android.permission.WRITE_HISTORY_BOOKMARKS允许应用写（非读）用户的浏览器历史和书签android.permission.WRITE_OWNER_DATA允许一个程序写入但不读取所有者数据android.permission.WRITE_SECURE_SETTINGS允许应用写或读当前系统设置android.permission.WRITE_SETTINGS允许程序读取或写入系统设置android.permission.WRITE_SMS允许程序写短信android.permission.WRITE_SYNC_SETTINGS允许程序写入同步设置","categories":[{"name":"android","slug":"android","permalink":"https://lossingdawn.top/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://lossingdawn.top/tags/android/"}]},{"title":"delegate委托的例子，实现对Form中控件的更新","slug":"1-delegate委托的例子，实现对Form中控件的更新","date":"2014-12-05T07:44:00.000Z","updated":"2019-07-27T17:04:10.236Z","comments":true,"path":"p/zh-CN/3615.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/3615.html","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading;using System.Threading.Tasks;using System.Windows.Forms;namespace Invoketest&#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); &#125; public void UpdateForm(string param1, string parm2) &#123; this.textBox1.Text = param1 + parm2; &#125; public delegate void UpdateForm_dl(string str1, string str2); private void Calldelegate() &#123; /*在Windows窗体应用程序中使用this.Invoke 在WPF应用程序中使用this.Dispatcher.Invoke*/ this.BeginInvoke(new UpdateForm_dl(UpdateForm), new object[] &#123; \"我是文本框\", \"haha\" &#125;); //this.Dispatcher.BeginInvoke(new UpdateForm_dl(UpdateForm), new object[] &#123; \"我是文本框\", \"haha\" &#125;); &#125; public void DoWork() &#123; Calldelegate(); &#125; private void Form1_Load(object sender, EventArgs e) &#123; &#125; private void button1_Click(object sender, EventArgs e) &#123; Thread thread = new Thread(new ThreadStart(DoWork)); thread.Start(); &#125; &#125;&#125;","categories":[{"name":"c#","slug":"c","permalink":"https://lossingdawn.top/categories/c/"}],"tags":[{"name":"c#","slug":"c","permalink":"https://lossingdawn.top/tags/c/"}]},{"title":"C#中用WMI实现对驱动的查询","slug":"1-C-中用WMI实现对驱动的查询","date":"2014-11-26T08:00:00.000Z","updated":"2019-07-27T17:03:42.518Z","comments":true,"path":"p/zh-CN/29155.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/29155.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Management;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace WMI_驱动&#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); &#125; private void button1_Click(object sender, EventArgs e) &#123; listView1.Items.Clear(); //SelectQuery selectQuery = new SelectQuery(\"select * from win32_logicaldisk\");//硬盘盘符 SelectQuery selectQuery = new SelectQuery(\"select * from Win32_DiskDrive\");//硬盘序列号 ManagementObjectSearcher search = new ManagementObjectSearcher(selectQuery); foreach (ManagementObject Driver in search.Get()) &#123; ListViewItem lvi = new ListViewItem(new string[] &#123; Driver[\"Name\"].ToString(), Driver[\"Description\"].ToString() &#125;, -1); listView1.Items.Add(lvi); &#125; &#125; private void button2_Click(object sender, EventArgs e) &#123; listView1.Items.Clear(); SelectQuery selectQuery = new SelectQuery(\"select * from Win32_SystemDriver\");//驱动程序 ManagementObjectSearcher search = new ManagementObjectSearcher(selectQuery); foreach (ManagementObject Driver in search.Get()) &#123; ListViewItem lvi = new ListViewItem(new string[] &#123; Driver[\"Name\"].ToString(), Driver[\"Description\"].ToString() &#125;, -1); listView1.Items.Add(lvi); &#125; &#125; private void button3_Click(object sender, EventArgs e) &#123; listView1.Items.Clear(); SelectQuery selectQuery = new SelectQuery(\"select * from Win32_USBController\");//USB控制器 ManagementObjectSearcher search = new ManagementObjectSearcher(selectQuery); foreach (ManagementObject Driver in search.Get()) &#123; ListViewItem lvi = new ListViewItem(new string[] &#123; Driver[\"Name\"].ToString(), Driver[\"Description\"].ToString() &#125;, -1); //ListViewItem lvi = new ListViewItem(new string[] &#123; Driver[\"Name\"].ToString(),\"\" &#125;,-1); listView1.Items.Add(lvi); &#125; SelectQuery selectQuery2 = new SelectQuery(\"select * from Win32_USBHub\");//USB集线器 ManagementObjectSearcher search2 = new ManagementObjectSearcher(selectQuery2); foreach (ManagementObject Driver in search2.Get()) &#123; ListViewItem lvi = new ListViewItem(new string[] &#123; Driver[\"Name\"].ToString(), Driver[\"Description\"].ToString() &#125;, -1); //ListViewItem lvi = new ListViewItem(new string[] &#123; Driver[\"Name\"].ToString(),\"\" &#125;,-1); listView1.Items.Add(lvi); &#125; &#125; private void Form1_Load(object sender, EventArgs e) &#123; listView1.Columns.Clear();//清空列记录 ColumnHeader cZh = new ColumnHeader();//创建一个列 cZh.Text = \"名称\";//列名 cZh.Width = 300; ColumnHeader cCh = new ColumnHeader(); cCh.Text = \"描述\"; cCh.Width = 600; listView1.Columns.AddRange(new ColumnHeader[] &#123; cZh, cCh &#125;);//将这两列加入listView1 listView1.View = View.Details;//列的显示模式 &#125; private void button4_Click(object sender, EventArgs e) &#123; listView1.Items.Clear(); SelectQuery selectQuery = new SelectQuery(\"select * from Win32_Printer \");//打印机 ManagementObjectSearcher search = new ManagementObjectSearcher(selectQuery); foreach (ManagementObject Driver in search.Get()) &#123; ListViewItem lvi = new ListViewItem(new string[] &#123; Driver[\"Name\"].ToString(),\"\" &#125;, -1); listView1.Items.Add(lvi); &#125; &#125; private void button5_Click(object sender, EventArgs e) &#123; listView1.Items.Clear(); SelectQuery selectQuery = new SelectQuery(\"select * from Win32_PrinterConfiguration \");//打印机设置 ManagementObjectSearcher search = new ManagementObjectSearcher(selectQuery); foreach (ManagementObject Driver in search.Get()) &#123; ListViewItem lvi = new ListViewItem(new string[] &#123; Driver[\"Name\"].ToString(), \"\" &#125;, -1); listView1.Items.Add(lvi); &#125; &#125; private void button6_Click(object sender, EventArgs e) &#123; listView1.Items.Clear(); SelectQuery selectQuery = new SelectQuery(\"select * from Win32_PrintJob \");//打印机任务 ManagementObjectSearcher search = new ManagementObjectSearcher(selectQuery); foreach (ManagementObject Driver in search.Get()) &#123; ListViewItem lvi = new ListViewItem(new string[] &#123; Driver[\"Name\"].ToString(), \"\" &#125;, -1); listView1.Items.Add(lvi); &#125; &#125; private void button7_Click(object sender, EventArgs e) &#123; listView1.Items.Clear(); SelectQuery selectQuery = new SelectQuery(\"select * from Win32_TCPIPPrinterPort \");//打印机端口 ManagementObjectSearcher search = new ManagementObjectSearcher(selectQuery); foreach (ManagementObject Driver in search.Get()) &#123; ListViewItem lvi = new ListViewItem(new string[] &#123; Driver[\"Name\"].ToString(), \"\" &#125;, -1); listView1.Items.Add(lvi); &#125; &#125; private void button8_Click(object sender, EventArgs e) &#123; listView1.Items.Clear(); SelectQuery selectQuery = new SelectQuery(\"select * from Win32_PointingDevice \");//点输入设备，鼠标 ManagementObjectSearcher search = new ManagementObjectSearcher(selectQuery); foreach (ManagementObject Driver in search.Get()) &#123; ListViewItem lvi = new ListViewItem(new string[] &#123; Driver[\"Name\"].ToString(), Driver[\"Description\"].ToString() &#125;, -1); listView1.Items.Add(lvi); &#125; &#125; private void button9_Click(object sender, EventArgs e) &#123; listView1.Items.Clear(); SelectQuery selectQuery = new SelectQuery(\"select * from Win32_Keyboard\");//键盘 ManagementObjectSearcher search = new ManagementObjectSearcher(selectQuery); foreach (ManagementObject Driver in search.Get()) &#123; ListViewItem lvi = new ListViewItem(new string[] &#123; Driver[\"Name\"].ToString(), Driver[\"Description\"].ToString() &#125;, -1); listView1.Items.Add(lvi); &#125; &#125; private void button10_Click(object sender, EventArgs e) &#123; listView1.Items.Clear(); SelectQuery selectQuery = new SelectQuery(\"select * from Win32_Printer \");//打印机 ManagementObjectSearcher search = new ManagementObjectSearcher(selectQuery); foreach (ManagementObject Driver in search.Get()) &#123; ListViewItem lvi = new ListViewItem(new string[] &#123; Driver[\"Name\"].ToString(), \"\" &#125;, -1); listView1.Items.Add(lvi); &#125; &#125; &#125; &#125;仅仅实现了查询的功能，后续有待加入与设备管理器类似的管理功能！","categories":[{"name":"c#","slug":"c","permalink":"https://lossingdawn.top/categories/c/"}],"tags":[{"name":"c#","slug":"c","permalink":"https://lossingdawn.top/tags/c/"}]},{"title":"C#窗体实现打开关闭VM虚拟机","slug":"1-C-窗体实现打开关闭VM虚拟机","date":"2014-11-08T11:59:00.000Z","updated":"2019-07-27T17:03:53.870Z","comments":true,"path":"p/zh-CN/878.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/878.html","excerpt":"","text":"vixclass.cs//定义开机、关机等函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139 using System;using System.Collections.Generic;using System.Linq;using System.Runtime.InteropServices;using System.Text;using System.Threading.Tasks;using VixCOM;namespace dome&#123; class vixclass &#123; public VixCOM.IVixLib IvixLib; public ulong m_vixError; public VixCOM.IHost m_hostHandle; public VixCOM.IVM m_vmHandle;// public VixCOM.IJob jobHandle; public vixclass() &#123; IvixLib = new VixCOM.VixLibClass(); m_vixError=0; m_hostHandle = null; m_vmHandle = null; //jobHandle = null; &#125; public ulong GetError() &#123; return m_vixError; &#125; /// &lt;summary&gt; /// 创建链接 /// &lt;/summary&gt; public bool Connect(string _hostname,string _username, string _password) &#123; int hostType = VixCOM.Constants.VIX_SERVICEPROVIDER_VMWARE_WORKSTATION; int vixVersion = VixCOM.Constants.VIX_API_VERSION; vixVersion = -1; int[] propertyIds = new int[1] &#123; VixCOM.Constants.VIX_PROPERTY_JOB_RESULT_HANDLE &#125;; object results = new object(); IJob jobHandle = IvixLib.Connect(vixVersion, hostType, _hostname, 0, _username, _password, 0, null, null); //jobHandle = IvixLib.Connect(vixVersion, hostType, hostname, 0, user, password, 0, null, null); m_vixError = jobHandle.Wait(propertyIds, ref results); if (m_vixError == VixCOM.Constants.VIX_OK) &#123; object[] objectArray = (object[])results; m_hostHandle = (VixCOM.IHost)objectArray[0]; return true; &#125; return false; &#125; /// &lt;summary&gt; ///打开vmxPath的虚拟机 /// &lt;/summary&gt; public bool OpenVm(string vmxPath) &#123; IJob jobHandle = m_hostHandle.OpenVM(vmxPath, null); int[] propertyIds = new int[1] &#123; VixCOM.Constants.VIX_PROPERTY_JOB_RESULT_HANDLE &#125;; object results = new object(); m_vixError = jobHandle.Wait(propertyIds, ref results); if (m_vixError == VixCOM.Constants.VIX_OK) &#123; object[] objectArray = (object[])results; m_vmHandle = (VixCOM.IVM)objectArray[0]; return true; &#125; return false; &#125; /// &lt;summary&gt; /// 启动虚拟机 /// &lt;/summary&gt; public bool PowerOn() &#123; IJob jobHandle = m_vmHandle.PowerOn(VixCOM.Constants.VIX_VMPOWEROP_LAUNCH_GUI, null, null); m_vixError = jobHandle.WaitWithoutResults(); if (m_vixError == VixCOM.Constants.VIX_OK) &#123; // jobHandle = m_vmHandle.WaitForToolsInGuest(300, null); m_vixError = jobHandle.WaitWithoutResults(); &#125; return (m_vixError == VixCOM.Constants.VIX_OK); &#125; /// &lt;summary&gt; /// 关闭虚拟机 /// &lt;/summary&gt; public bool PowerOff() &#123; IJob jobHandle = m_vmHandle.PowerOff(VixCOM.Constants.VIX_VMPOWEROP_NORMAL, null); m_vixError = jobHandle.WaitWithoutResults(); return (m_vixError == VixCOM.Constants.VIX_OK); &#125; /// &lt;summary&gt; /// 重启虚拟机 /// &lt;/summary&gt; public bool Restart() &#123; IJob jobHandle = m_vmHandle.Reset(VixCOM.Constants.VIX_VMPOWEROP_NORMAL, null); m_vixError = jobHandle.WaitWithoutResults(); return (m_vixError == VixCOM.Constants.VIX_OK); &#125; &#125;&#125;Form1.cs//主窗体，textbox1//记录选择的虚拟机的路径btnselect//选择路径btnstart//打开虚拟机btnclose//关闭虚拟机12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace dome&#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); &#125; private void btnselect_Click(object sender, EventArgs e) &#123; OpenFileDialog loSaveFile = new OpenFileDialog(); loSaveFile.Filter = \".vmx文件(*.vmx)|*.vmx\"; if (loSaveFile.ShowDialog() == DialogResult.OK) &#123; this.textBox1.Text = loSaveFile.FileName; &#125; &#125; private void btnstart_Click(object sender, EventArgs e) &#123; try &#123; vixclass vix = new vixclass(); string vmxpath = textBox1.Text; vix.Connect(null, \"Administrator\", null); vix.OpenVm(@vmxpath); vix.PowerOn(); &#125; catch(Exception ex) &#123; MessageBox.Show(ex.ToString()); &#125; &#125; private void btnclose_Click(object sender, EventArgs e) &#123; try &#123; vixclass vix = new vixclass(); string vmxpath = textBox1.Text; vix.Connect(null , \"Administrator\", null); vix.OpenVm(@vmxpath); vix.PowerOff(); &#125; catch (Exception ex) &#123; MessageBox.Show(ex.ToString()); &#125; &#125; private void Form1_Load(object sender, EventArgs e) &#123; &#125; &#125;&#125;注：添加引用：VixCOM.DLL","categories":[{"name":"c#","slug":"c","permalink":"https://lossingdawn.top/categories/c/"}],"tags":[{"name":"c#","slug":"c","permalink":"https://lossingdawn.top/tags/c/"}]},{"title":"C#控制台打开VM虚拟机","slug":"1-C-控制台打开VM虚拟机","date":"2014-11-05T12:40:00.000Z","updated":"2019-07-27T17:03:46.743Z","comments":true,"path":"p/zh-CN/19762.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/19762.html","excerpt":"","text":"添加引用-&gt;VixCOM.dll (在vix文件夹下)VixWrapper.cs1using System; using System.Collections.Generic; using System.Linq; using System.Runtime.InteropServices; using System.Text; using VixCOM; namespace VMHelper &#123; class VixWrapper &#123; VixCOM.IVixLib vixLib = null; ulong m_vixError; VixCOM.IHost m_hostHandle = null; VixCOM.IVM m_vmHandle = null; public ulong GetError() &#123; return m_vixError; &#125; public VixWrapper() &#123; try &#123; vixLib = new VixCOM.VixLibClass(); &#125; catch (COMException comExc) &#123; System.Diagnostics.Trace.WriteLine(comExc.Message + \"\\n\"); throw; &#125; &#125; /// &lt;summary&gt; /// Creates a host handle /// &lt;/summary&gt; /// &lt;returns&gt;true if succeeded, otherwise false&lt;/returns&gt; public bool Connect(string hostName, string userName, string password) &#123; int hostType = string.IsNullOrEmpty(hostName) ? VixCOM.Constants.VIX_SERVICEPROVIDER_VMWARE_WORKSTATION : VixCOM.Constants.VIX_SERVICEPROVIDER_VMWARE_SERVER; int vixVersion = VixCOM.Constants.VIX_API_VERSION; vixVersion = -1; VixCOM.IJob jobHandle = vixLib.Connect(vixVersion, hostType, null, 0, userName, password, 0, null, null); int[] propertyIds = new int[1] &#123; VixCOM.Constants.VIX_PROPERTY_JOB_RESULT_HANDLE &#125;; object results = new object(); m_vixError = jobHandle.Wait(propertyIds, ref results); if (m_vixError == VixCOM.Constants.VIX_OK) &#123; object[] objectArray = (object[])results; m_hostHandle = (VixCOM.IHost)objectArray[0]; return true; &#125; return false; &#125; /// &lt;summary&gt; /// Opens the virtual machine specified in vmxFilePath /// &lt;/summary&gt; /// &lt;param name=”vmxFilePath”&gt;The virtual machine vmx file to open&lt;/param&gt; /// &lt;returns&gt;true if succeeded, otherwise false&lt;/returns&gt; public bool OpenVm(string vmxFilePath) &#123; IJob jobHandle = m_hostHandle.OpenVM(vmxFilePath, null); int[] propertyIds = new int[1] &#123; VixCOM.Constants.VIX_PROPERTY_JOB_RESULT_HANDLE &#125;; object results = new object(); m_vixError = jobHandle.Wait(propertyIds, ref results); if (m_vixError == VixCOM.Constants.VIX_OK) &#123; object[] objectArray = (object[])results; m_vmHandle = (VixCOM.IVM)objectArray[0]; return true; &#125; return false; &#125; /// &lt;summary&gt; /// Power on the virtual machine /// &lt;/summary&gt; /// &lt;returns&gt;true if succeeded, otherwise false&lt;/returns&gt; public bool PowerOn() &#123; IJob jobHandle = m_vmHandle.PowerOn(VixCOM.Constants.VIX_VMPOWEROP_LAUNCH_GUI, null, null); m_vixError = jobHandle.WaitWithoutResults(); if (m_vixError == VixCOM.Constants.VIX_OK) &#123; jobHandle = m_vmHandle.WaitForToolsInGuest(300, null); m_vixError = jobHandle.WaitWithoutResults(); &#125; return (m_vixError == VixCOM.Constants.VIX_OK); &#125; /// &lt;summary&gt; /// Starts a snapshot of a virtual machine /// &lt;/summary&gt; /// &lt;param name=”snapshot_name”&gt;The name of the snapshot to start&lt;/param&gt; /// &lt;returns&gt;true if succeeded, otherwise false&lt;/returns&gt; public bool RevertToLastSnapshot() &#123; ISnapshot snapshot = null; m_vixError = m_vmHandle.GetRootSnapshot(0, out snapshot); if (m_vixError == VixCOM.Constants.VIX_OK) &#123; IJob jobHandle = m_vmHandle.RevertToSnapshot(snapshot, 0, null, null); m_vixError = jobHandle.WaitWithoutResults(); &#125; return (m_vixError == VixCOM.Constants.VIX_OK); &#125; /// &lt;summary&gt; /// Login to the virtual machine /// &lt;/summary&gt; /// &lt;returns&gt;true if succeeded, otherwise false&lt;/returns&gt; public bool LogIn(string username, string password) &#123; IJob jobHandle = m_vmHandle.LoginInGuest(username, password, 0, null); m_vixError = jobHandle.WaitWithoutResults(); return (m_vixError == VixCOM.Constants.VIX_OK); &#125; /// &lt;summary&gt; /// Creates the directory in the Virtual Machine /// &lt;/summary&gt; /// &lt;param name=”pathName”&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public bool CreateDirectoryInVm(string pathName) &#123; IJob jobHandle = m_vmHandle.CreateDirectoryInGuest(pathName, null, null); m_vixError = jobHandle.WaitWithoutResults(); return (m_vixError == VixCOM.Constants.VIX_OK); &#125; /// &lt;summary&gt; /// Copies a file from the host machine to the virtual machine /// &lt;/summary&gt; /// &lt;param name=”sourceFile”&gt;The source file on the host machine&lt;/param&gt; /// &lt;param name=”destinationFile”&gt;The destination on the VM&lt;/param&gt; /// &lt;returns&gt;true if succeeded, otherwise false&lt;/returns&gt; public bool CopyFileToVm(string sourceFile, string destinationFile) &#123; // // Copy files from host to guest // IJob jobHandle = m_vmHandle.CopyFileFromHostToGuest(sourceFile, destinationFile, 0, null, null); m_vixError = jobHandle.WaitWithoutResults(); return (m_vixError == VixCOM.Constants.VIX_OK); &#125; /// &lt;summary&gt; /// Copies a file from the virtual machine to the host machine /// &lt;/summary&gt; /// &lt;param name=”sourceFile”&gt;The source file on the virtual machine&lt;/param&gt; /// &lt;param name=”destinationFile”&gt;The destination on the host machine&lt;/param&gt; /// &lt;returns&gt;true if succeeded, otherwise false&lt;/returns&gt; public bool CopyFileFromVm(string sourceFile, string destinationFile) &#123; // // Copy files from host to guest // IJob jobHandle = m_vmHandle.CopyFileFromGuestToHost(sourceFile, destinationFile, 0, null, null); m_vixError = jobHandle.WaitWithoutResults(); return (m_vixError == VixCOM.Constants.VIX_OK); &#125; /// &lt;summary&gt; /// Runs a program on the virtual machine /// &lt;/summary&gt; /// &lt;param name=”exePath”&gt;The path of the program on the virtual machine&lt;/param&gt; /// &lt;param name=”parameters”&gt;The parameters to pass to the executable&lt;/param&gt; /// &lt;param name=”resultCode”&gt;The result code returned from the program that ran on the VM&lt;/param&gt; /// &lt;returns&gt;true if succeeded, otherwise false&lt;/returns&gt; public bool RunProgram(string exePath, string parameters, out int resultCode) &#123; resultCode = -1; IJob jobHandle = m_vmHandle.RunProgramInGuest(exePath, parameters, VixCOM.Constants.VIX_RUNPROGRAM_ACTIVATE_WINDOW, null, null); // clientData int[] propertyIds = new int[1] &#123; VixCOM.Constants.VIX_PROPERTY_JOB_RESULT_GUEST_PROGRAM_EXIT_CODE &#125;; object results = new object(); m_vixError = jobHandle.Wait(propertyIds, ref results); if (m_vixError == VixCOM.Constants.VIX_OK) &#123; object[] objectArray = (object[])results; resultCode = (int)objectArray[0]; return true; &#125; return false; &#125; /// &lt;summary&gt; /// Power off the virtual machine /// &lt;/summary&gt; /// &lt;returns&gt;true if succeeded, otherwise false&lt;/returns&gt; public bool PowerOff() &#123; IJob jobHandle = m_vmHandle.PowerOff(VixCOM.Constants.VIX_VMPOWEROP_NORMAL, null); m_vixError = jobHandle.WaitWithoutResults(); return (m_vixError == VixCOM.Constants.VIX_OK); &#125; /// &lt;summary&gt; /// Restart the virtual machine /// &lt;/summary&gt; /// &lt;returns&gt;true if succeeded, otherwise false&lt;/returns&gt; public bool Restart() &#123; IJob jobHandle = m_vmHandle.Reset(VixCOM.Constants.VIX_VMPOWEROP_NORMAL, null); m_vixError = jobHandle.WaitWithoutResults(); return (m_vixError == VixCOM.Constants.VIX_OK); &#125; &#125; &#125;Program.cs123456789101112131415161718192021222324252627282930313233343536using System;using System.Collections.Generic;using System.Linq;using System.Runtime.InteropServices;using System.Text;using VMHelper;namespace VixWrapperTest&#123; class Program &#123; static void Main(string[] args) &#123; try &#123; //VixWrapper.VixWrapper vix = new VixWrapper.VixWrapper(); VixWrapper wrapper = new VixWrapper(); wrapper.Connect(null, \"Administrator\", null); wrapper.OpenVm(@\"E:\\win xp\\Windows XP Professional.vmx\");//安装好的虚拟机.vmx的实际路径 wrapper.PowerOn(); wrapper.PowerOff(); &#125; catch (Exception e) &#123; Console.WriteLine(e.ToString()); &#125; &#125; &#125;&#125;本程序实现了通过VS控制台打开vm虚拟机的功能，有兴趣的可以去调用剩下的函数，做个时延函数，然后完成其他任务。","categories":[{"name":"c#","slug":"c","permalink":"https://lossingdawn.top/categories/c/"}],"tags":[{"name":"c#","slug":"c","permalink":"https://lossingdawn.top/tags/c/"}]},{"title":"C# U盘扫描","slug":"1-C-U盘扫描","date":"2014-10-27T06:59:00.000Z","updated":"2019-07-27T17:03:39.164Z","comments":true,"path":"p/zh-CN/21847.html","link":"","permalink":"https://lossingdawn.top/p/zh-CN/21847.html","excerpt":"","text":"无意中看到的一个例程，保留一份。以供后用。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Text;using System.IO;using System.Windows.Forms;using System.Runtime.InteropServices; namespace USB&#123; public partial class USB : Form &#123; public USB() &#123; InitializeComponent(); &#125; public const int WM_DEVICECHANGE = 0x219; public const int DBT_DEVICEARRIVAL = 0x8000; public const int DBT_CONFIGCHANGECANCELED = 0x0019; public const int DBT_CONFIGCHANGED = 0x0018; public const int DBT_CUSTOMEVENT = 0x8006; public const int DBT_DEVICEQUERYREMOVE = 0x8001; public const int DBT_DEVICEQUERYREMOVEFAILED = 0x8002; public const int DBT_DEVICEREMOVECOMPLETE = 0x8004; public const int DBT_DEVICEREMOVEPENDING = 0x8003; public const int DBT_DEVICETYPESPECIFIC = 0x8005; public const int DBT_DEVNODES_CHANGED = 0x0007; public const int DBT_QUERYCHANGECONFIG = 0x0017; public const int DBT_USERDEFINED = 0xFFFF; // 逻辑卷标 public const int DBT_DEVTYP_VOLUME = 0x00000002; // private LockScreen Ls = new LockScreen(); public string ID = \"\"; public string Value; public string[] item; [StructLayout(LayoutKind.Sequential)] public struct DEV_BROADCAST_VOLUME &#123; public int dbcv_size; public int dbcv_devicetype; public int dbcv_reserved; public int dbcv_unitmask; &#125; protected override void WndProc(ref Message m) &#123; try &#123; if (m.Msg == WM_DEVICECHANGE) &#123; switch (m.WParam.ToInt32()) &#123; case WM_DEVICECHANGE: break; case DBT_DEVICEARRIVAL://U盘有插入 this.timer1.Enabled = true; DriveInfo[] s = DriveInfo.GetDrives(); foreach (DriveInfo DriveI in s) &#123; if (DriveI.DriveType == DriveType.Removable) &#123; // Ls.Show(); // this.Hide(); // MessageBox.Show(\"sss\"); break; &#125; int devType = Marshal.ReadInt32(m.LParam, 4); if (devType == DBT_DEVTYP_VOLUME) &#123; DEV_BROADCAST_VOLUME vol; vol = (DEV_BROADCAST_VOLUME)Marshal.PtrToStructure(m.LParam, typeof(DEV_BROADCAST_VOLUME)); ID = vol.dbcv_unitmask.ToString(\"x\"); this.Text = IO(ID); this.Tag = IO(ID); //if (item.Length ==0||IO(ID)!=this.Tag.ToString ()) //&#123; //&#125; &#125; this.label1.Text = this.Text; &#125; break; case DBT_CONFIGCHANGECANCELED: break; case DBT_CONFIGCHANGED: break; case DBT_CUSTOMEVENT: break; case DBT_DEVICEQUERYREMOVE: break; case DBT_DEVICEQUERYREMOVEFAILED: break; case DBT_DEVICEREMOVECOMPLETE: //U盘卸载 DriveInfo[] I = DriveInfo.GetDrives(); foreach (DriveInfo DrInfo in I) &#123; int devType = Marshal.ReadInt32(m.LParam, 4); if (devType == DBT_DEVTYP_VOLUME) &#123; DEV_BROADCAST_VOLUME vol; vol = (DEV_BROADCAST_VOLUME)Marshal.PtrToStructure(m.LParam, typeof(DEV_BROADCAST_VOLUME)); ID = vol.dbcv_unitmask.ToString(\"x\"); this.Text = IO(ID) + \"盘退出！\\n\"; &#125; this.label1.Text += this.Text; // MessageBox.Show(\"U盘已经卸载\", \"信息提示\", MessageBoxButtons.OK, MessageBoxIcon.Information); &#125; break; case DBT_DEVICEREMOVEPENDING: break; case DBT_DEVICETYPESPECIFIC: break; case DBT_DEVNODES_CHANGED: break; case DBT_QUERYCHANGECONFIG: break; case DBT_USERDEFINED: break; default: break; &#125; &#125; &#125; catch (Exception ex) &#123; throw new Exception(ex.Message); &#125; base.WndProc(ref m); &#125; private void USB_Load(object sender, EventArgs e) &#123; &#125; public string IO(string ff) &#123; switch (ff) &#123; case \"1\": Value = \"A:\"; break; case \"2\": Value = \"B:\"; break; case \"4\": Value = \"C:\"; break; case \"8\": Value = \"D:\"; break; case \"10\": Value = \"E:\"; break; case \"20\": Value = \"F:\"; break; case \"40\": Value = \"G:\"; break; case \"80\": Value = \"H:\"; break; case \"100\": Value = \"I:\"; break; case \"200\": Value = \"J:\"; break; case \"400\": Value = \"K:\"; break; case \"800\": Value = \"L:\"; break; case \"1000\": Value = \"M:\"; break; case \"2000\": Value = \"N:\"; break; case \"4000\": Value = \"O:\"; break; case \"8000\": Value = \"P:\"; break; case \"10000\": Value = \"Q:\"; break; case \"20000\": Value = \"R:\"; break; case \"40000\": Value = \"S:\"; break; case \"80000\": Value = \"T:\"; break; case \"100000\": Value = \"U:\"; break; case \"200000\": Value = \"V:\"; break; case \"400000\": Value = \"W:\"; break; case \"800000\": Value = \"X:\"; break; case \"1000000\": Value = \"Y:\"; break; case \"2000000\": Value = \"Z:\"; break; default: break; &#125; return Value; &#125; private void timer1_Tick(object sender, EventArgs e) &#123; // this.Text = ID; &#125; &#125;&#125;","categories":[{"name":"c#","slug":"c","permalink":"https://lossingdawn.top/categories/c/"}],"tags":[{"name":"c#","slug":"c","permalink":"https://lossingdawn.top/tags/c/"}]}]}